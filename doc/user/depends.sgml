<!--

  Copyright (c) 2001, 2002, 2003 Steven Knight

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
  KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

-->

<!--



=head2 The C<Salt> method

The C<Salt> method adds a constant value to the signature calculation
for every derived file.  It is invoked as follows:

  Salt $string;

Changing the Salt value will force a complete rebuild of every derived
file.  This can be used to force rebuilds in certain desired
circumstances.  For example,

  Salt `uname -s`;

Would force a complete rebuild of every derived file whenever the
operating system on which the build is performed (as reported by C<uname
-s>) changes.

-->

  <para>

  So far we've seen how &SCons; handles one-time builds.
  But the real point of a build tool like &SCons;
  is to rebuild the necessary things,
  and only the necessary thing, when source files change.
  Put another way,
  &SCons; should <emphasis>not</emphasis>
  waste time rebuilding things that have already been built.
  You can see this at work simply be re-invoking &SCons;
  after building our simple &hello; example:

  </para>

  <literallayout>
     % <userinput>scons</userinput>
     cc -c hello.c -o hello.o
     cc -o hello hello.o
     % <userinput>scons</userinput>
     %
  </literallayout>

  <para>

  The second time it is executed,
  &SCons; realizes that the &hello; program
  is up-to-date with respect to the current &hello_c; source file,
  and avoids rebuilding it.
  You can see this more clearly by naming
  the &hello; program explicitly on the command line:

  </para>

  <literallayout>
     % <userinput>scons hello</userinput>
     cc -c hello.c -o hello.o
     cc -o hello hello.o
     % <userinput>scons hello</userinput>
     scons: `hello' is up to date.
     %
  </literallayout>

  <para>

  Note that &SCons; only reports "...is up to date"
  for target files named explicitly on the command line,
  to avoid cluttering the output.

  </para>

  <section>
  <title>MD5 Signatures</title>

    <para>

    &SCons; keeps track of whether a file has changed
    based on the file's contents,
    not the modification time.
    This means that you may be surprised by the
    behavior of &SCons; if you are used to the
    &Make; convention of forcing
    a rebuild by updating the file's
    modification time like so:

    </para>

    <literallayout>
       % <userinput>scons hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       % <userinput>touch hello.c</userinput>
       % <userinput>scons hello</userinput>
       scons: `hello' is up to date.
       %
    </literallayout>

    <para>

    This avoids unnecessary rebuilds when,
    for example, someone rewrites the
    contents of a file without making a change.
    But if the contents of the file really change,
    then &SCons; detects the change
    and rebuilds the program as required:

    </para>

    <literallayout>
       % <userinput>scons hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       % <userinput>edit hello.c</userinput>
           [CHANGE THE CONTENTS OF hello.c]
       % <userinput>scons hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       %
    </literallayout>

  </section>

  <section>
  <title>Implicit Dependencies</title>

    <para>

    Now suppose that our "Hello, World!" program
    actually has a <literal>#include</literal> line
    to include &hello_h; file in the compilation:

    </para>

    <programlisting>
       #include "hello.h" 
       int
       main()
       {
           printf("Hello, %s!\n", string);
       }
    </programlisting>

    <para>

    And, for completeness, the &hello_h; file looks like this:

    </para>

    <programlisting>
       #define string    "world"
    </programlisting>

    <para>

    In this case, we want &SCons; to recognize that,
    if the contents of the &hello_h; file change,
    the &hello; program must be recompiled.
    To do this, we need to modify the
    &SConstruct; file like so:

    </para>

    <programlisting>
       env = Environment(CPPPATH = '.')  XXX IS CPPPATH NECESSARY?
       hello = env.Program('hello.c')
    </programlisting>

    <para>

    The &CPPPATH; assignment in the &Environment; call
    tells &SCons; to look in the current directory
    (<literal>'.'</literal>)
    for any files included by C source files
    (<filename>.c</filename> or <filename>.h</filename> files).
    With this assignment in the &SConstruct file:

    </para>

    <literallayout>
       % <userinput>scons hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       % <userinput>scons hello</userinput>
       scons: `hello' is up to date.
       % <userinput>edit hello.h</userinput>
           [CHANGE THE CONTENTS OF hello.h]
       % <userinput>scons hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       %
    </literallayout>

    <para>

    &SCons; knows that the &hello;
    program must be rebuilt
    because it scans the contents of
    the &hello_c; file
    for the <literal>#include</literal> lines that indicate
    another file is being included in the compilation.
    &SCons; records these as
    <emphasis>implicit dependencies</emphasis>
    of the target file,
    Consequently,
    when the &hello_h; file changes,
    &SCons; realizes that the &hello_c; file includes it,
    and rebuilds the resulting &hello; program
    that depends on both the &hello_c; and &hello_h; files.

    </para>

  </section>

  <section>
  <title>Caching Implicit Dependencies</title>

    <para>

    Scanning each file for <literal>#include</literal> lines
    does take some extra processing time.
    When you're doing a full build of a large system,
    the scanning time is a small percentage
    of the overall time spent on the build.
    You're most likely to notice the scanning time,
    however, when you rebuild all or part of a large system:
    &SCons; will take some extra time to "think about"
    what must be built before it issues the
    first build command,
    or decides that nothing must be rebuilt.

 <!--
 Isn't this expensive? The answer is, it depends. If you do a full build of a
 large system, the scanning time is insignificant. If you do a rebuild of a
 large system, then Cons will spend a fair amount of time thinking about it
 before it decides that nothing has to be done (although not necessarily more
 time than make!). The good news is that Cons makes it very easy to
 intelligently subset your build, when you are working on localized changes.
 -->

    </para>

    <para>

    In practice, having &SCons; scan files saves time
    relative to the amount of potential time
    lost to tracking down subtle problems
    introduced by incorrect dependencies.
    Nevertheless, the "waiting time"
    while &SCons; scans files can annoy
    individual developers waiting for their builds.
    Consequently, &SCons; lets you cache
    the implicit dependencies

    </para>

    <literallayout>
       % <userinput>scons --implicit-cache hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       % <userinput>scons hello</userinput>
       scons: `hello' is up to date.
    </literallayout>

    <para>

    &SCons; does not cache implicit dependencies like this by default
    because XXX

    </para>

  </section>

  <section>
  <title>The &Ignore; Method</title>

    <para>

    Sometimes it makes sense 
    to not rebuild a program,
    even if a dependency file changes.
    In this case,
    you would tell &SCons; specifically
    to ignore a dependency as follows:

    </para>

    <programlisting>
       env = Environment()
       hello = env.Program('hello.c')
       env.Ignore(hello, 'hello.h')
    </programlisting>

    <!-- XXX mention that you can use arrays for target and source? -->

    <literallayout>
       % <userinput>scons hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       % <userinput>scons hello</userinput>
       scons: `hello' is up to date.
       % <userinput>edit hello.h</userinput>
           [CHANGE THE CONTENTS OF hello.h]
       % <userinput>scons hello</userinput>
       scons: `hello' is up to date.
    </literallayout>

    <para>

    Now, the above example is a little contrived,
    because it's hard to imagine a real-world situation
    where you wouldn't to rebuild &hello;
    if the &hello_h; file changed.
    A more realistic example
    might be if the &hello;
    program is being built in a
    directory that is shared between multiple systems
    that have different copies of the
    &stdio_h; include file.
    In that case,
    &SCons; would notice the differences between
    the different systems' copies of &stdio_h;
    and would rebuild &hello;
    each time you change systems.
    You could avoid these rebuilds as follows:

    </para>

    <programlisting>
       env = Environment()
       hello = env.Program('hello.c')
       env.Ignore(hello, '/usr/include/stdio.h')
    </programlisting>

  </section>

  <section>
  <title>The &Depends; Method</title>

    <para>

    On the other hand,
    sometimes a file depends on another
    file that the scanner(s) in &SCons; will not detect.
    For this situation,
    &SCons; allows you to specific that one file explicitly
    depends on another file,
    and must be rebuilt whenever that file changes,
    using the &Depends; method:

    </para>

    <programlisting>
       env = Environment()
       hello = env.Program('hello.c')
       env.Depends(hello, 'other_file')
    </programlisting>

    <!-- XXX mention that you can use arrays for target and source? -->

    <literallayout>
       % <userinput>scons hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       % <userinput>scons hello</userinput>
       scons: `hello' is up to date.
       % <userinput>edit other_file</userinput>
           [CHANGE THE CONTENTS OF other_file]
       % <userinput>scons hello</userinput>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
    </literallayout>

  </section>

  <!-->

  <section>
  <title>The &Salt; Method</title>

    <para>

    X

    </para>

  </section>

  -->

  <section>
  <title>Time Stamps</title>

    <para>

    X

    </para>

  </section>

  <section>
  <title>The &SourceSignature; Method</title>

    <para>

    X

    </para>

  </section>
