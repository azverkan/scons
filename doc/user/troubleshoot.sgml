<!--

  __COPYRIGHT__

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be included
  in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
  KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

-->

  <para>

  The experience of configuring any
  software build tool to build a large code base
  usually, at some point,
  involves trying to figure out why
  the tool is behaving a certain way,
  and how to get it to behave the way you want.
  &SCons; is no different.

  </para>

  <section>
  <title>Why is That Target Being Rebuilt?  the &debug-explain; Option</title>

    <para>

    Let's take a simple example of
    a misconfigured build
    that causes a target to be rebuilt
    every time &SCons; is run:

    </para>

    <programlisting>
      # Intentionally misspell the output file name in the
      # command used to create the file:
      Command('file.out', 'file.in', 'cp $SOURCE file.oout')
    </programlisting>

    <para>

    (Note to Windows users:  The POSIX &cp; command
    copies the first file named on the command line
    to the second file.
    In our example, it copies the &file_in; file
    to the &file_out; file.)

    </para>

    <para>

    Now if we run &SCons; multiple on this example,
    we see that it re-runs the &cp;
    command every time:

    </para>

    <screen>
      % <userinput>scons -Q</userinput>
      cp file.in file.oout
      % <userinput>scons -Q</userinput>
      cp file.in file.oout
      % <userinput>scons -Q</userinput>
      cp file.in file.oout
    </screen>

    <para>

    In this example,
    the underlying cause is obvious:
    we've intentionally misspelled the output file name
    in the &cp; command,
    so the command doesn't actually
    build the &file_out; file that we've told &SCons; to expect.
    But if the problem weren't obvious,
    it would be helpful
    to specify the &debug-explain; option
    on the command line
    to have &SCons; tell us very specifically
    why it's decided to rebuild the target:

    </para>

    <screen>
      % <userinput>scons -Q --debug=explain</userinput>
      scons: building `file.out' because it doesn't exist
      cp file.in file.oout
    </screen>

    <para>

    If this had been a more complicated example
    involving a lot of build output,
    having &SCons; tell us that
    it's trying to rebuild the target file
    because it doesn't exist
    would be an important clue
    that something was wrong with
    the command that we invoked to build it.

    </para>

    <para>

    The &debug-explain; option also comes in handy
    to help figure out what input file changed.
    Given a simple configuration that builds
    a program from three source files,
    changing one of the source files
    and rebuilding with the &debug-explain;
    option shows very specifically
    why &SCons; rebuilds the files that it does:

    </para>

    

    <screen>
      % <userinput>scons -Q</userinput>
      cc -c -o file1.o file1.c
      cc -c -o file2.o file2.c
      cc -c -o file3.o file3.c
      cc -o prog file1.o file2.o file3.o
      % <userinput>edit file2.c</userinput>
          [CHANGE THE CONTENTS OF file2.c]
      % <userinput>scons -Q --debug=explain</userinput>
      scons: rebuilding `file2.o' because `file2.c' changed
      cc -c -o file2.o file2.c
      scons: rebuilding `prog' because `file2.o' changed
      cc -o prog file1.o file2.o file3.o
    </screen>

    <para>

    This becomes even more helpful
    in identifying when a file is rebuilt
    due to a change in an implicit dependency,
    such as an incuded <filename>.h</filename> file.
    If the <filename>file1.c</filename>
    and <filename>file3.c</filename> files
    in our example
    both included a &hello_h; file,
    then changing that included file
    and re-running &SCons; with the &debug-explain; option
    will pinpoint that it's the change to the included file
    that starts the chain of rebuilds:

    </para>

    

    <screen>
      % <userinput>scons -Q</userinput>
      cc -I. -c -o file1.o file1.c
      cc -I. -c -o file2.o file2.c
      cc -I. -c -o file3.o file3.c
      cc -o prog file1.o file2.o file3.o
      % <userinput>edit hello.h</userinput>
          [CHANGE THE CONTENTS OF hello.h]
      % <userinput>scons -Q --debug=explain</userinput>
      scons: rebuilding `file1.o' because `hello.h' changed
      cc -I. -c -o file1.o file1.c
      scons: rebuilding `file3.o' because `hello.h' changed
      cc -I. -c -o file3.o file3.c
      scons: rebuilding `prog' because:
                 `file1.o' changed
                 `file3.o' changed
      cc -o prog file1.o file2.o file3.o
    </screen>

  </section>

  <section>
  <title>What's in That Construction Environment?  the &Dump; Method</title>

    <para>

    When you create a construction environment,
    &SCons; populates it
    with construction variables that are set up
    for various compilers, linkers and utilities
    that it finds on your system.
    Although this is usually helpful and what you want,
    it might be frustrating if &SCons;
    doesn't set certain variables that you
    expect to be sit.
    In situations like this,
    it's sometimes helpful to use the
    construction environment &Dump; method
    to print all or some of
    the construction variables.
    Note that the &Dump; method
    <emphasis>returns</emphasis>
    the representation of the variables
    in the environment
    for you to print (or otherwise manipulate):

    </para>

    

    <para>

    On a POSIX system with gcc installed,
    this might generate:

    </para>

    <screen>
      % <userinput>scons</userinput>
      scons: Reading SConscript files ...
      { 'BUILDERS': {},
        'CPPSUFFIXES': [ '.c',
                         '.C',
                         '.cxx',
                         '.cpp',
                         '.c++',
                         '.cc',
                         '.h',
                         '.H',
                         '.hxx',
                         '.hpp',
                         '.hh',
                         '.F',
                         '.fpp',
                         '.FPP',
                         '.S',
                         '.spp',
                         '.SPP'],
        'DSUFFIXES': ['.d'],
        'Dir': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829dcb4&gt;,
        'ENV': {'PATH': '/usr/local/bin:/bin:/usr/bin'},
        'ESCAPE': &lt;function escape at 0x837d2a4&gt;,
        'File': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829e0fc&gt;,
        'IDLSUFFIXES': ['.idl', '.IDL'],
        'INSTALL': &lt;function copyFunc at 0x829db9c&gt;,
        'LIBPREFIX': 'lib',
        'LIBPREFIXES': '$LIBPREFIX',
        'LIBSUFFIX': '.a',
        'LIBSUFFIXES': ['$LIBSUFFIX', '$SHLIBSUFFIX'],
        'OBJPREFIX': '',
        'OBJSUFFIX': '.o',
        'PDFPREFIX': '',
        'PDFSUFFIX': '.pdf',
        'PLATFORM': 'posix',
        'PROGPREFIX': '',
        'PROGSUFFIX': '',
        'PSPAWN': &lt;function piped_env_spawn at 0x837d384&gt;,
        'PSPREFIX': '',
        'PSSUFFIX': '.ps',
        'RDirs': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829e46c&gt;,
        'SCANNERS': [],
        'SHELL': 'sh',
        'SHLIBPREFIX': '$LIBPREFIX',
        'SHLIBSUFFIX': '.so',
        'SHOBJPREFIX': '$OBJPREFIX',
        'SHOBJSUFFIX': '$OBJSUFFIX',
        'SPAWN': &lt;function spawnvpe_spawn at 0x8377fdc&gt;,
        'TEMPFILE': &lt;class SCons.Defaults.NullCmdGenerator at 0x829ddec&gt;,
        'TOOLS': [],
        '_CPPDEFFLAGS': '${_defines(CPPDEFPREFIX, CPPDEFINES, CPPDEFSUFFIX, __env__)}',
        '_CPPINCFLAGS': '$( ${_concat(INCPREFIX, CPPPATH, INCSUFFIX, __env__, RDirs, TARGET)} $)',
        '_LIBDIRFLAGS': '$( ${_concat(LIBDIRPREFIX, LIBPATH, LIBDIRSUFFIX, __env__, RDirs, TARGET)} $)',
        '_LIBFLAGS': '${_concat(LIBLINKPREFIX, LIBS, LIBLINKSUFFIX, __env__)}',
        '__RPATH': '$_RPATH',
        '_concat': &lt;function _concat at 0x829dc0c&gt;,
        '_defines': &lt;function _defines at 0x829dc7c&gt;,
        '_stripixes': &lt;function _stripixes at 0x829dc44&gt;}
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
    </screen>

    <para>

    On a Windows system with Visual C++
    the output might look like:

    </para>

    <screen>
      C:\><userinput>scons</userinput>
      scons: Reading SConscript files ...
      { 'BUILDERS': {'Object': &lt;SCons.Memoize.MultiStepBuilder object at 0x83493e4&gt;, 'SharedObject': &lt;SCons.Memoize.MultiStepBuilder object at 0x8349fec&gt;, 'StaticObject': &lt;SCons.Memoize.MultiStepBuilder object at 0x83493e4&gt;, 'PCH': &lt;SCons.Memoize.BuilderBase object at 0x83418cc&gt;, 'RES': &lt;SCons.Memoize.BuilderBase object at 0x8367cec&gt;},
        'CC': 'cl',
        'CCCOM': &lt;SCons.Memoize.FunctionAction object at 0x8340454&gt;,
        'CCCOMFLAGS': '$CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS /c $SOURCES /Fo$TARGET $CCPCHFLAGS $CCPDBFLAGS',
        'CCFLAGS': ['/nologo'],
        'CCPCHFLAGS': ['${(PCH and "/Yu%s /Fp%s"%(PCHSTOP or "",File(PCH))) or ""}'],
        'CCPDBFLAGS': ['${(PDB and "/Z7") or ""}'],
        'CFILESUFFIX': '.c',
        'CPPDEFPREFIX': '/D',
        'CPPDEFSUFFIX': '',
        'CPPSUFFIXES': [ '.c',
                         '.C',
                         '.cxx',
                         '.cpp',
                         '.c++',
                         '.cc',
                         '.h',
                         '.H',
                         '.hxx',
                         '.hpp',
                         '.hh',
                         '.F',
                         '.fpp',
                         '.FPP',
                         '.S',
                         '.spp',
                         '.SPP'],
        'CXX': '$CC',
        'CXXCOM': '$CXX $CXXFLAGS $CCCOMFLAGS',
        'CXXFILESUFFIX': '.cc',
        'CXXFLAGS': ['$CCFLAGS', '$(', '/TP', '$)'],
        'DSUFFIXES': ['.d'],
        'Dir': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829dcb4&gt;,
        'ENV': { 'INCLUDE': 'C:\\Program Files\\Microsoft Visual Studio/VC98\\include',
                 'LIB': 'C:\\Program Files\\Microsoft Visual Studio/VC98\\lib',
                 'PATH': 'C:\\Program Files\\Microsoft Visual Studio\\Common\\tools\\WIN95;C:\\Program Files\\Microsoft Visual Studio\\Common\\MSDev98\\bin;C:\\Program Files\\Microsoft Visual Studio\\Common\\tools;C:\\Program Files\\Microsoft Visual Studio/VC98\\bin',
                 'PATHEXT': '.COM;.EXE;.BAT;.CMD'},
        'ESCAPE': &lt;function &lt;lambda&gt; at 0x82339ec&gt;,
        'File': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829e0fc&gt;,
        'IDLSUFFIXES': ['.idl', '.IDL'],
        'INCPREFIX': '/I',
        'INCSUFFIX': '',
        'INSTALL': &lt;function copyFunc at 0x829db9c&gt;,
        'LIBPREFIX': '',
        'LIBPREFIXES': ['$LIBPREFIX'],
        'LIBSUFFIX': '.lib',
        'LIBSUFFIXES': ['$LIBSUFFIX'],
        'MAXLINELENGTH': 2048,
        'MSVS': {'VERSION': '6.0', 'VERSIONS': ['6.0']},
        'MSVS_VERSION': '6.0',
        'OBJPREFIX': '',
        'OBJSUFFIX': '.obj',
        'PCHCOM': '$CXX $CXXFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS /c $SOURCES /Fo${TARGETS[1]} /Yc$PCHSTOP /Fp${TARGETS[0]} $CCPDBFLAGS $PCHPDBFLAGS',
        'PCHPDBFLAGS': ['${(PDB and "/Yd") or ""}'],
        'PDFPREFIX': '',
        'PDFSUFFIX': '.pdf',
        'PLATFORM': 'win32',
        'PROGPREFIX': '',
        'PROGSUFFIX': '.exe',
        'PSPAWN': &lt;function piped_spawn at 0x8372bc4&gt;,
        'PSPREFIX': '',
        'PSSUFFIX': '.ps',
        'RC': 'rc',
        'RCCOM': '$RC $_CPPDEFFLAGS $_CPPINCFLAGS $RCFLAGS /fo$TARGET $SOURCES',
        'RCFLAGS': [],
        'RDirs': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829e46c&gt;,
        'SCANNERS': [],
        'SHCC': '$CC',
        'SHCCCOM': &lt;SCons.Memoize.FunctionAction object at 0x83494bc&gt;,
        'SHCCFLAGS': ['$CCFLAGS'],
        'SHCXX': '$CXX',
        'SHCXXCOM': '$SHCXX $SHCXXFLAGS $CCCOMFLAGS',
        'SHCXXFLAGS': ['$CXXFLAGS'],
        'SHELL': None,
        'SHLIBPREFIX': '',
        'SHLIBSUFFIX': '.dll',
        'SHOBJPREFIX': '$OBJPREFIX',
        'SHOBJSUFFIX': '$OBJSUFFIX',
        'SPAWN': &lt;function spawn at 0x8374c34&gt;,
        'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME': 1,
        'TEMPFILE': &lt;class SCons.Platform.win32.TempFileMunge at 0x835edc4&gt;,
        'TOOLS': ['msvc'],
        '_CPPDEFFLAGS': '${_defines(CPPDEFPREFIX, CPPDEFINES, CPPDEFSUFFIX, __env__)}',
        '_CPPINCFLAGS': '$( ${_concat(INCPREFIX, CPPPATH, INCSUFFIX, __env__, RDirs, TARGET)} $)',
        '_LIBDIRFLAGS': '$( ${_concat(LIBDIRPREFIX, LIBPATH, LIBDIRSUFFIX, __env__, RDirs, TARGET)} $)',
        '_LIBFLAGS': '${_concat(LIBLINKPREFIX, LIBS, LIBLINKSUFFIX, __env__)}',
        '_concat': &lt;function _concat at 0x829dc0c&gt;,
        '_defines': &lt;function _defines at 0x829dc7c&gt;,
        '_stripixes': &lt;function _stripixes at 0x829dc44&gt;}
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
    </screen>

    <para>

    The construction environments in these examples have
    actually been restricted to just gcc and Visual C++,
    respectively.
    In a real-life situation,
    the construction environments will
    likely contain a great many more variables.

    </para>

    <para>

    To make it easier to see just what you're
    interested in,
    the &Dump; method allows you to
    specify a specific constrcution variable
    that you want to disply.
    For example,
    it's not unusual to want to verify
    the external environment used to execute build commands,
    to make sure that the PATH and other
    environment variables are set up the way they should be.
    You can do this as follows:

    </para>

    

    <para>

    Which might display the following when executed on a POSIX system:

    </para>

    <screen>
      % <userinput>scons</userinput>
      scons: Reading SConscript files ...
      {'PATH': '/usr/local/bin:/bin:/usr/bin'}
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
    </screen>

    <para>

    And the following when executed on a Windows system:

    </para>

    <screen>
      C:\><userinput>scons</userinput>
      scons: Reading SConscript files ...
      { 'INCLUDE': 'C:\\Program Files\\Microsoft Visual Studio/VC98\\include',
        'LIB': 'C:\\Program Files\\Microsoft Visual Studio/VC98\\lib',
        'PATH': 'C:\\Program Files\\Microsoft Visual Studio\\Common\\tools\\WIN95;C:\\Program Files\\Microsoft Visual Studio\\Common\\MSDev98\\bin;C:\\Program Files\\Microsoft Visual Studio\\Common\\tools;C:\\Program Files\\Microsoft Visual Studio/VC98\\bin',
        'PATHEXT': '.COM;.EXE;.BAT;.CMD'}
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
    </screen>

  </section>
