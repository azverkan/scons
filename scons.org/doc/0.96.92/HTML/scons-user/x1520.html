<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Canned Build Options</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="SCons User Guide 0.96.92"
HREF="book1.html"><LINK
REL="UP"
TITLE="Controlling a Build From the Command Line"
HREF="c1271.html"><LINK
REL="PREVIOUS"
TITLE="Reading Build Options From a File"
HREF="x1498.html"><LINK
REL="NEXT"
TITLE="Adding Multiple Command-Line Build Options at Once"
HREF="x1706.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>SCons User Guide 0.96.92</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x1498.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Controlling a Build From the Command Line</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1706.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="AEN1520"
>Canned Build Options</A
></H1
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> provides a number of functions
    that provide ready-made behaviors
    for various types of command-line build options.

    </P
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN1524"
>True/False Values:  the <TT
CLASS="FUNCTION"
>BoolOption</TT
> Build Option</A
></H2
><P
>&#13;      It's often handy to be able to specify an
      option that controls a simple Boolean variable
      with a <TT
CLASS="LITERAL"
>true</TT
> or <TT
CLASS="LITERAL"
>false</TT
> value.
      It would be even more handy to accomodate
      users who have different preferences for how to represent
      <TT
CLASS="LITERAL"
>true</TT
> or <TT
CLASS="LITERAL"
>false</TT
> values.
      The <TT
CLASS="FUNCTION"
>BoolOption</TT
> function
      makes it easy to accomodate a variety of
      common values that represent
      <TT
CLASS="LITERAL"
>true</TT
> or <TT
CLASS="LITERAL"
>false</TT
>.

      </P
><P
>&#13;      The <TT
CLASS="FUNCTION"
>BoolOption</TT
> function takes three arguments:
      the name of the build option,
      the default value of the build option,
      and the help string for the option.
      It then returns appropriate information for
      passing to the <TT
CLASS="FUNCTION"
>Add</TT
> method of an <TT
CLASS="FUNCTION"
>Options</TT
> object, like so:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(BoolOption('RELEASE', 'Set to build for release', 0))
           env = Environment(options = opts,
                             CPPDEFINES={'RELEASE_BUILD' : '${RELEASE}'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      With this build option,
      the <VAR
CLASS="VARNAME"
>RELEASE</VAR
> variable can now be enabled by
      setting it to the value <TT
CLASS="LITERAL"
>yes</TT
>
      or <TT
CLASS="LITERAL"
>t</TT
>:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q RELEASE=yes foo.o</KBD
>
        cc -DRELEASE_BUILD=1 -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q RELEASE=t foo.o</KBD
>
        cc -DRELEASE_BUILD=1 -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Other values that equate to <TT
CLASS="LITERAL"
>true</TT
> include
      <TT
CLASS="LITERAL"
>y</TT
>,
      <TT
CLASS="LITERAL"
>1</TT
>,
      <TT
CLASS="LITERAL"
>on</TT
>
      and
      <TT
CLASS="LITERAL"
>all</TT
>.

      </P
><P
>&#13;      Conversely, <VAR
CLASS="VARNAME"
>RELEASE</VAR
> may now be given a <TT
CLASS="LITERAL"
>false</TT
>
      value by setting it to
      <TT
CLASS="LITERAL"
>no</TT
>
      or
      <TT
CLASS="LITERAL"
>f</TT
>:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q RELEASE=no foo.o</KBD
>
        cc -DRELEASE_BUILD=0 -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q RELEASE=f foo.o</KBD
>
        cc -DRELEASE_BUILD=0 -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Other values that equate to <TT
CLASS="LITERAL"
>true</TT
> include
      <TT
CLASS="LITERAL"
>n</TT
>,
      <TT
CLASS="LITERAL"
>0</TT
>,
      <TT
CLASS="LITERAL"
>off</TT
>
      and
      <TT
CLASS="LITERAL"
>none</TT
>.

      </P
><P
>&#13;      Lastly, if a user tries to specify
      any other value,
      <TT
CLASS="APPLICATION"
>SCons</TT
> supplies an appropriate error message:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q RELEASE=bad_value foo.o</KBD
>
        
        scons: *** Error converting option: RELEASE
        Invalid value for boolean option: bad_value
        File "SConstruct", line 4, in ?
      </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN1573"
>Single Value From a List:  the <TT
CLASS="FUNCTION"
>EnumOption</TT
> Build Option</A
></H2
><P
>&#13;      Suppose that we want a user to be able to
      set a <VAR
CLASS="VARNAME"
>COLOR</VAR
> option
      that selects a background color to be
      displayed by an application,
      but that we want to restrict the
      choices to a specific set of allowed colors.
      This can be set up quite easily
      using the <TT
CLASS="FUNCTION"
>EnumOption</TT
>,
      which takes a list of <VAR
CLASS="VARNAME"
>allowed_values</VAR
>      in addition to the variable name,
      default value,
      and help text arguments:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(EnumOption('COLOR', 'Set background color', 'red',
                               allowed_values=('red', 'green', 'blue')))
           env = Environment(options = opts,
                             CPPDEFINES={'COLOR' : '"${COLOR}"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      The user can now explicity set the <VAR
CLASS="VARNAME"
>COLOR</VAR
> build option
      to any of the specified allowed values:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=red foo.o</KBD
>
        cc -DCOLOR="red" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=blue foo.o</KBD
>
        cc -DCOLOR="blue" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=green foo.o</KBD
>
        cc -DCOLOR="green" -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      But, almost more importantly,
      an attempt to set <VAR
CLASS="VARNAME"
>COLOR</VAR
>
      to a value that's not in the list
      generates an error message:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=magenta foo.o</KBD
>
        
        scons: *** Invalid value for option COLOR: magenta
        File "SConstruct", line 5, in ?
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      The <TT
CLASS="FUNCTION"
>EnumOption</TT
> function also supports a way
      to map alternate names to allowed values.
      Suppose, for example,
      that we want to allow the user
      to use the word <TT
CLASS="LITERAL"
>navy</TT
> as a synonym for
      <TT
CLASS="LITERAL"
>blue</TT
>.
      We do this by adding a <VAR
CLASS="VARNAME"
>map</VAR
> dictionary
      that will map its key values
      to the desired legal value:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(EnumOption('COLOR', 'Set background color', 'red',
                               allowed_values=('red', 'green', 'blue'),
                               map={'navy':'blue'}))
           env = Environment(options = opts,
                             CPPDEFINES={'COLOR' : '"${COLOR}"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      As desired, the user can then use
      <TT
CLASS="LITERAL"
>navy</TT
> on the command line,
      and <TT
CLASS="APPLICATION"
>SCons</TT
> will translate it into <TT
CLASS="LITERAL"
>blue</TT
>
      when it comes time to use the <VAR
CLASS="VARNAME"
>COLOR</VAR
>
      option to build a target:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=navy foo.o</KBD
>
        cc -DCOLOR="blue" -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      By default, when using the <TT
CLASS="FUNCTION"
>EnumOption</TT
> function,
      arguments that differ
      from the legal values
      only in case
      are treated as illegal values:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=Red foo.o</KBD
>
        
        scons: *** Invalid value for option COLOR: Red
        File "SConstruct", line 5, in ?
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=BLUE foo.o</KBD
>
        
        scons: *** Invalid value for option COLOR: BLUE
        File "SConstruct", line 5, in ?
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=nAvY foo.o</KBD
>
        
        scons: *** Invalid value for option COLOR: nAvY
        File "SConstruct", line 5, in ?
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      The <TT
CLASS="FUNCTION"
>EnumOption</TT
> function can take an additional
      <VAR
CLASS="VARNAME"
>ignorecase</VAR
> keyword argument that,
      when set to <TT
CLASS="LITERAL"
>1</TT
>,
      tells <TT
CLASS="APPLICATION"
>SCons</TT
> to allow case differences
      when the values are specified:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(EnumOption('COLOR', 'Set background color', 'red',
                               allowed_values=('red', 'green', 'blue'),
                               map={'navy':'blue'},
                               ignorecase=1))
           env = Environment(options = opts,
                             CPPDEFINES={'COLOR' : '"${COLOR}"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Which yields the output:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=Red foo.o</KBD
>
        cc -DCOLOR="Red" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=BLUE foo.o</KBD
>
        cc -DCOLOR="BLUE" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=nAvY foo.o</KBD
>
        cc -DCOLOR="blue" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=green foo.o</KBD
>
        cc -DCOLOR="green" -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Notice that an <VAR
CLASS="VARNAME"
>ignorecase</VAR
> value of <TT
CLASS="LITERAL"
>1</TT
>
      preserves the case-spelling that the user supplied.
      If you want <TT
CLASS="APPLICATION"
>SCons</TT
> to translate the names
      into lower-case,
      regardless of the case used by the user,
      specify an <VAR
CLASS="VARNAME"
>ignorecase</VAR
> value of <TT
CLASS="LITERAL"
>2</TT
>:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(EnumOption('COLOR', 'Set background color', 'red',
                               allowed_values=('red', 'green', 'blue'),
                               map={'navy':'blue'},
                               ignorecase=2))
           env = Environment(options = opts,
                             CPPDEFINES={'COLOR' : '"${COLOR}"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Now <TT
CLASS="APPLICATION"
>SCons</TT
> will use values of
      <TT
CLASS="LITERAL"
>red</TT
>,
      <TT
CLASS="LITERAL"
>green</TT
> or
      <TT
CLASS="LITERAL"
>blue</TT
>
      regardless of how the user spells
      those values on the command line:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=Red foo.o</KBD
>
        cc -DCOLOR="red" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=nAvY foo.o</KBD
>
        cc -DCOLOR="blue" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLOR=GREEN foo.o</KBD
>
        cc -DCOLOR="green" -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN1638"
>Multiple Values From a List:  the <TT
CLASS="FUNCTION"
>ListOption</TT
> Build Option</A
></H2
><P
>&#13;      Another way in which you might want to allow users
      to control build option is to
      specify a list of one or more legal values.
      <TT
CLASS="APPLICATION"
>SCons</TT
> supports this through the <TT
CLASS="FUNCTION"
>ListOption</TT
> function.
      If, for example, we want a user to be able to set a
      <VAR
CLASS="VARNAME"
>COLORS</VAR
> option to one or more of the legal list of values:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(ListOption('COLORS', 'List of colors', 0,
                               ['red', 'green', 'blue']))
           env = Environment(options = opts,
                             CPPDEFINES={'COLORS' : '"${COLORS}"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      A user can now specify a comma-separated list
      of legal values,
      which will get translated into a space-separated
      list for passing to the any build commands:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLORS=red,blue foo.o</KBD
>
        cc -DCOLORS="red blue" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLORS=blue,green,red foo.o</KBD
>
        cc -DCOLORS="blue green red" -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      In addition, the <TT
CLASS="FUNCTION"
>ListOption</TT
> function
      allows the user to specify explicit keywords of
      <TT
CLASS="LITERAL"
>all</TT
> or <TT
CLASS="LITERAL"
>none</TT
>
      to select all of the legal values,
      or none of them, respectively:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLORS=all foo.o</KBD
>
        cc -DCOLORS="red green blue" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q COLORS=none foo.o</KBD
>
        cc -DCOLORS="" -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      And, of course, an illegal value
      still generates an error message:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q COLORS=magenta foo.o</KBD
>
        
        scons: *** Error converting option: COLORS
        Invalid value(s) for option: magenta
        File "SConstruct", line 5, in ?
      </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN1660"
>Path Names:  the <TT
CLASS="FUNCTION"
>PathOption</TT
> Build Option</A
></H2
><P
>&#13;      <TT
CLASS="APPLICATION"
>SCons</TT
> supports a <TT
CLASS="FUNCTION"
>PathOption</TT
> function
      to make it easy to create a build option
      to control an expected path name.
      If, for example, you need to
      define a variable in the preprocessor
      that control the location of a
      configuration file:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(PathOption('CONFIG',
                               'Path to configuration file',
                               '/etc/my_config'))
           env = Environment(options = opts,
                             CPPDEFINES={'CONFIG_FILE' : '"$CONFIG"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      This then allows the user to
      override the <VAR
CLASS="VARNAME"
>CONFIG</VAR
> build option
      on the command line as necessary:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q foo.o</KBD
>
        cc -DCONFIG_FILE="/etc/my_config" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q CONFIG=/usr/local/etc/other_config foo.o</KBD
>
        scons: `foo.o' is up to date.
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      By default, <TT
CLASS="FUNCTION"
>PathOption</TT
> checks to make sure
      that the specified path exists and generates an error if it
      doesn't:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q CONFIG=/does/not/exist foo.o</KBD
>
        
        scons: *** Path for option CONFIG does not exist: /does/not/exist
        File "SConstruct", line 6, in ?
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      <TT
CLASS="FUNCTION"
>PathOption</TT
> provides a number of methods
      that you can use to change this behavior.
      If you want to ensure that any specified paths are,
      in fact, files and not directories,
      use the <TT
CLASS="FUNCTION"
>PathOption.PathIsFile</TT
> method:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(PathOption('CONFIG',
                               'Path to configuration file',
                               '/etc/my_config',
                               PathOption.PathIsFile))
           env = Environment(options = opts,
                             CPPDEFINES={'CONFIG_FILE' : '"$CONFIG"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Conversely, to ensure that any specified paths are
      directories and not files,
      use the <TT
CLASS="FUNCTION"
>PathOption.PathIsDir</TT
> method:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(PathOption('DBDIR',
                               'Path to database directory',
                               '/var/my_dbdir',
                               PathOption.PathIsDir))
           env = Environment(options = opts,
                             CPPDEFINES={'DBDIR' : '"$DBDIR"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      If you want to make sure that any specified paths
      are directories,
      and you would like the directory created
      if it doesn't already exist,
      use the <TT
CLASS="FUNCTION"
>PathOption.PathIsDirCreate</TT
> method:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(PathOption('DBDIR',
                               'Path to database directory',
                               '/var/my_dbdir',
                               PathOption.PathIsDirCreate))
           env = Environment(options = opts,
                             CPPDEFINES={'DBDIR' : '"$DBDIR"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Lastly, if you don't care whether the path exists,
      is a file, or a directory,
      use the <TT
CLASS="FUNCTION"
>PathOption.PathAccept</TT
> method
      to accept any path that the user supplies:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(PathOption('OUTPUT',
                               'Path to output file or directory',
                               None,
                               PathOption.PathAccept))
           env = Environment(options = opts,
                             CPPDEFINES={'OUTPUT' : '"$OUTPUT"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN1689"
>Enabled/Disabled Path Names: the <TT
CLASS="FUNCTION"
>PackageOption</TT
> Build Option</A
></H2
><P
>&#13;      Sometimes you want to give users
      even more control over a path name variable,
      allowing them to explicitly enable or
      disable the path name
      by using <TT
CLASS="LITERAL"
>yes</TT
> or <TT
CLASS="LITERAL"
>no</TT
> keywords,
      in addition to allow them
      to supply an explicit path name.
      <TT
CLASS="APPLICATION"
>SCons</TT
> supports the <TT
CLASS="FUNCTION"
>PackageOption</TT
>
      function to support this:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>           opts = Options('custom.py')
           opts.Add(PackageOption('PACKAGE',
                                  'Location package',
                                  '/opt/location'))
           env = Environment(options = opts,
                             CPPDEFINES={'PACKAGE' : '"$PACKAGE"'})
           env.Program('foo.c')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      When the <TT
CLASS="FILENAME"
>SConscript</TT
> file uses the <TT
CLASS="FUNCTION"
>PackageOption</TT
> funciton,
      user can now still use the default
      or supply an overriding path name,
      but can now explicitly set the
      specified variable to a value
      that indicates the package should be enabled
      (in which case the default should be used)
      or disabled:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % <KBD
CLASS="USERINPUT"
>scons -Q foo.o</KBD
>
        cc -DPACKAGE="/opt/location" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q PACKAGE=/usr/local/location foo.o</KBD
>
        cc -DPACKAGE="/usr/local/location" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q PACKAGE=yes foo.o</KBD
>
        cc -DPACKAGE="1" -c -o foo.o foo.c
        % <KBD
CLASS="USERINPUT"
>scons -Q PACKAGE=no foo.o</KBD
>
        cc -DPACKAGE="0" -c -o foo.o foo.c
      </PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x1498.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1706.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Reading Build Options From a File</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1271.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Adding Multiple Command-Line Build Options at Once</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>