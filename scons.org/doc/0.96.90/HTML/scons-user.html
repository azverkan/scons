<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<title>SCons User Guide 0.96.90</title>
<meta name="GENERATOR" content=
"Modular DocBook HTML Stylesheet Version 1.76b+ ">
</head>
<body class="BOOK" bgcolor="#FFFFFF" text="#000000" link="#0000FF"
vlink="#840084" alink="#0000FF">
<div class="BOOK"><a name="AEN1"></a>
<div class="TITLEPAGE">
<h1 class="TITLE"><a name="AEN2"></a>SCons User Guide 0.96.90</h1>

<h3 class="AUTHOR"><a name="AEN4"></a>Steven Knight</h3>

<p class="COPYRIGHT">Copyright &copy; 2004 by Steven Knight</p>

<div class="LEGALNOTICE"><a name="AEN12"></a><a name="AEN13"></a>
<blockquote class="BLOCKQUOTE">
<p>&#13; SCons User's Guide Copyright (c) 2004 Steven Knight</p>
</blockquote>
</div>

<span class="RELEASEINFO">version 0.96.90<br>
</span>
<hr>
</div>

<div class="TOC">
<dl>
<dt><b>Table of Contents</b></dt>

<dt><a href="#CHAP-PREFACE">Preface</a></dt>

<dd>
<dl>
<dt><a href="#AEN29"><tt class="APPLICATION">SCons</tt>
Principles</a></dt>

<dt><a href="#AEN54">A Caveat About This Guide's
Completeness</a></dt>

<dt><a href="#AEN62">Acknowledgements</a></dt>

<dt><a href="#AEN83">Contact</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-BUILD-INSTALL">Building and Installing <tt
class="APPLICATION">SCons</tt></a></dt>

<dd>
<dl>
<dt><a href="#AEN102">Installing Python</a></dt>

<dt><a href="#AEN124">Installing <tt class="APPLICATION">SCons</tt>
From Pre-Built Packages</a></dt>

<dd>
<dl>
<dt><a href="#AEN129">Installing <tt class="APPLICATION">SCons</tt>
on Red Hat (and Other RPM-based) Linux Systems</a></dt>

<dt><a href="#AEN149">Installing <tt class="APPLICATION">SCons</tt>
on Debian Linux Systems</a></dt>

<dt><a href="#AEN157">Installing <tt class="APPLICATION">SCons</tt>
on Windows Systems</a></dt>
</dl>
</dd>

<dt><a href="#AEN166">Building and Installing <tt class=
"APPLICATION">SCons</tt> on Any System</a></dt>

<dd>
<dl>
<dt><a href="#AEN194">Building and Installing Multiple Versions of
<tt class="APPLICATION">SCons</tt> Side-by-Side</a></dt>

<dt><a href="#AEN218">Installing <tt class="APPLICATION">SCons</tt>
in Other Locations</a></dt>

<dt><a href="#AEN236">Building and Installing <tt class=
"APPLICATION">SCons</tt> Without Administrative Privileges</a></dt>
</dl>
</dd>
</dl>
</dd>

<dt><a href="#CHAP-SIMPLE">Simple Builds</a></dt>

<dd>
<dl>
<dt><a href="#AEN256">Building Simple C / C++ Programs</a></dt>

<dt><a href="#AEN288">Building Object Files</a></dt>

<dt><a href="#AEN307">Simple Java Builds</a></dt>

<dt><a href="#AEN328">Cleaning Up After a Build</a></dt>

<dt><a href="#AEN348">The <tt class="FILENAME">SConstruct</tt>
File</a></dt>

<dd>
<dl>
<dt><a href="#AEN358"><tt class="FILENAME">SConstruct</tt> Files
Are Python Scripts</a></dt>

<dt><a href="#AEN370"><tt class="APPLICATION">SCons</tt> Functions
Are Order-Independent</a></dt>
</dl>
</dd>

<dt><a href="#AEN420">Making the <tt class="APPLICATION">SCons</tt>
Output Less Verbose</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-LESS-SIMPLE">Less Simple Things to Do With
Builds</a></dt>

<dd>
<dl>
<dt><a href="#AEN443">Specifying the Name of the Target (Output)
File</a></dt>

<dt><a href="#AEN467">Compiling Multiple Source Files</a></dt>

<dt><a href="#AEN489">Specifying Single Files Vs. Lists of
Files</a></dt>

<dt><a href="#AEN507">Making Lists of Files Easier to Read</a></dt>

<dt><a href="#AEN533">Keyword Arguments</a></dt>

<dt><a href="#AEN544">Compiling Multiple Programs</a></dt>

<dt><a href="#AEN558">Sharing Source Files Between Multiple
Programs</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-LIBRARIES">Building and Linking with
Libraries</a></dt>

<dd>
<dl>
<dt><a href="#AEN578">Building Libraries</a></dt>

<dd>
<dl>
<dt><a href="#AEN597">Building Static Libraries Explicitly: the <tt
class="FUNCTION">StaticLibrary</tt> Builder</a></dt>

<dt><a href="#AEN611">Building Shared (DLL) Libraries: the <tt
class="FUNCTION">SharedLibrary</tt> Builder</a></dt>
</dl>
</dd>

<dt><a href="#AEN628">Linking with Libraries</a></dt>

<dt><a href="#AEN655">Finding Libraries: the <tt class=
"ENVAR">$LIBPATH</tt> Construction Variable</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-NODES">Node Objects</a></dt>

<dd>
<dl>
<dt><a href="#AEN686">Builder Methods Return Lists of Target
Nodes</a></dt>

<dt><a href="#AEN717">Explicitly Creating File and Directory
Nodes</a></dt>

<dt><a href="#AEN737">Printing <tt class="CLASSNAME">Node</tt> File
Names</a></dt>

<dt><a href="#AEN749">Using a <tt class="CLASSNAME">Node</tt>'s
File Name as a String</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-DEPENDS">Dependencies</a></dt>

<dd>
<dl>
<dt><a href="#AEN785">Deciding When a Source File Has Changed: the
<tt class="FUNCTION">SourceSignatures</tt> Function</a></dt>

<dd>
<dl>
<dt><a href="#AEN792">MD5 Source File Signatures</a></dt>

<dt><a href="#AEN816">Source File Time Stamps</a></dt>
</dl>
</dd>

<dt><a href="#AEN830">Deciding When a Target File Has Changed: the
<tt class="FUNCTION">TargetSignatures</tt> Function</a></dt>

<dd>
<dl>
<dt><a href="#AEN836">Build Signatures</a></dt>

<dt><a href="#AEN856">File Contents</a></dt>
</dl>
</dd>

<dt><a href="#AEN874">Implicit Dependencies: The <tt class=
"ENVAR">$CPPPATH</tt> Construction Variable</a></dt>

<dt><a href="#AEN931">Caching Implicit Dependencies</a></dt>

<dd>
<dl>
<dt><a href="#AEN950">The <tt class=
"LITERAL">--implicit-deps-changed</tt> Option</a></dt>

<dt><a href="#AEN962">The <tt class=
"LITERAL">--implicit-deps-unchanged</tt> Option</a></dt>
</dl>
</dd>

<dt><a href="#AEN975">Ignoring Dependencies: the <tt class=
"FUNCTION">Ignore</tt> Method</a></dt>

<dt><a href="#AEN995">Explicit Dependencies: the <tt class=
"FUNCTION">Depends</tt> Method</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-ENVIRONMENTS">Construction Environments</a></dt>

<dd>
<dl>
<dt><a href="#AEN1035">Multiple <tt class="LITERAL">Construction
Environments</tt></a></dt>

<dt><a href="#AEN1075">Copying <tt class="LITERAL">Construction
Environments</tt></a></dt>

<dt><a href="#AEN1095">Fetching Values From a <tt class=
"LITERAL">Construction Environment</tt></a></dt>

<dt><a href="#AEN1118">Expanding Values From a <tt class=
"LITERAL">Construction Environment</tt></a></dt>

<dt><a href="#AEN1148">Modifying a <tt class="LITERAL">Construction
Environment</tt></a></dt>

<dd>
<dl>
<dt><a href="#AEN1153">Replacing Values in a <tt class=
"LITERAL">Construction Environment</tt></a></dt>

<dt><a href="#AEN1185">Appending to the End of Values in a <tt
class="LITERAL">Construction Environment</tt></a></dt>

<dt><a href="#AEN1203">Appending to the Beginning of Values in a
<tt class="LITERAL">Construction Environment</tt></a></dt>
</dl>
</dd>
</dl>
</dd>

<dt><a href="#CHAP-ENV">Controlling the External Environment Used
to Execute Build Commands</a></dt>

<dd>
<dl>
<dt><a href="#AEN1252">Propagating <tt class="VARNAME">PATH</tt>
From the External Environment</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-COMMAND-LINE">Controlling a Build From the
Command Line</a></dt>

<dd>
<dl>
<dt><a href="#AEN1276">Not Having to Specify Command-Line Options
Each Time: the <tt class="VARNAME">SCONSFLAGS</tt> Environment
Variable</a></dt>

<dt><a href="#AEN1301">Getting at Command-Line Targets</a></dt>

<dt><a href="#AEN1317">Controlling the Default Targets</a></dt>

<dd>
<dl>
<dt><a href="#AEN1367">Getting at the List of Default
Targets</a></dt>
</dl>
</dd>

<dt><a href="#AEN1398">Getting at the List of Build Targets,
Regardless of Origin</a></dt>

<dt><a href="#AEN1423">Command-Line <tt class=
"VARNAME">variable</tt>=<tt class="VARNAME">value</tt> Build
Options</a></dt>

<dt><a href="#AEN1457">Controlling Command-Line Build
Options</a></dt>

<dt><a href="#AEN1483">Providing Help for Command-Line Build
Options</a></dt>

<dt><a href="#AEN1498">Reading Build Options From a File</a></dt>

<dt><a href="#AEN1520">Canned Build Options</a></dt>

<dd>
<dl>
<dt><a href="#AEN1524">True/False Values: the <tt class=
"FUNCTION">BoolOption</tt> Build Option</a></dt>

<dt><a href="#AEN1573">Single Value From a List: the <tt class=
"FUNCTION">EnumOption</tt> Build Option</a></dt>

<dt><a href="#AEN1638">Multiple Values From a List: the <tt class=
"FUNCTION">ListOption</tt> Build Option</a></dt>

<dt><a href="#AEN1660">Path Names: the <tt class=
"FUNCTION">PathOption</tt> Build Option</a></dt>

<dt><a href="#AEN1689">Enabled/Disabled Path Names: the <tt class=
"FUNCTION">PackageOption</tt> Build Option</a></dt>
</dl>
</dd>

<dt><a href="#AEN1706">Adding Multiple Command-Line Build Options
at Once</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-HELP">Providing Build Help: the <tt class=
"FUNCTION">Help</tt> Function</a></dt>

<dt><a href="#CHAP-INSTALL">Installing Files in Other Directories:
the <tt class="FUNCTION">Install</tt> Builder</a></dt>

<dd>
<dl>
<dt><a href="#AEN1775">Installing Multiple Files in a
Directory</a></dt>

<dt><a href="#AEN1785">Installing a File Under a Different
Name</a></dt>

<dt><a href="#AEN1796">Installing Multiple Files Under Different
Names</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-FACTORIES">Platform-Independent File System
Manipulation</a></dt>

<dd>
<dl>
<dt><a href="#AEN1812">Copying Files or Directories: The <tt class=
"FUNCTION">Copy</tt> Factory</a></dt>

<dt><a href="#AEN1842">Deleting Files or Directories: The <tt
class="FUNCTION">Delete</tt> Factory</a></dt>

<dt><a href="#AEN1865">Moving (Renaming) Files or Directories: The
<tt class="FUNCTION">Move</tt> Factory</a></dt>

<dt><a href="#AEN1874">Updating the Modification Time of a File:
The <tt class="FUNCTION">Touch</tt> Factory</a></dt>

<dt><a href="#AEN1883">Creating a Directory: The <tt class=
"FUNCTION">Mkdir</tt> Factory</a></dt>

<dt><a href="#AEN1892">Changing File or Directory Permissions: The
<tt class="FUNCTION">Chmod</tt> Factory</a></dt>

<dt><a href="#AEN1901">Executing an action immediately: the <tt
class="FUNCTION">Execute</tt> Function</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-PRECIOUS">Preventing Removal of Targets: the <tt
class="FUNCTION">Precious</tt> Function</a></dt>

<dt><a href="#CHAP-HIERARCHICAL">Hierarchical Builds</a></dt>

<dd>
<dl>
<dt><a href="#AEN1945"><tt class="FILENAME">SConscript</tt>
Files</a></dt>

<dt><a href="#AEN1973">Path Names Are Relative to the <tt class=
"FILENAME">SConscript</tt> Directory</a></dt>

<dt><a href="#AEN1999">Top-Level Path Names in Subsidiary <tt
class="FILENAME">SConscript</tt> Files</a></dt>

<dt><a href="#AEN2020">Absolute Path Names</a></dt>

<dt><a href="#AEN2030">Sharing Environments (and Other Variables)
Between <tt class="FILENAME">SConscript</tt> Files</a></dt>

<dd>
<dl>
<dt><a href="#AEN2042">Exporting Variables</a></dt>

<dt><a href="#AEN2070">Importing Variables</a></dt>

<dt><a href="#AEN2093">Returning Values From an <tt class=
"FILENAME">SConscript</tt> File</a></dt>
</dl>
</dd>
</dl>
</dd>

<dt><a href="#CHAP-SEPARATE">Separating Source and Build
Directories</a></dt>

<dd>
<dl>
<dt><a href="#AEN2122">Specifying a Build Directory as Part of an
<tt class="FILENAME">SConscript</tt> Call</a></dt>

<dt><a href="#AEN2152">Why <tt class="APPLICATION">SCons</tt>
Duplicates Source Files in a Build Directory</a></dt>

<dt><a href="#AEN2169">Telling <tt class="APPLICATION">SCons</tt>
to Not Duplicate Source Files in the Build Directory</a></dt>

<dt><a href="#AEN2185">The <tt class="FUNCTION">BuildDir</tt>
Function</a></dt>

<dt><a href="#AEN2214">Using <tt class="FUNCTION">BuildDir</tt>
With an <tt class="FILENAME">SConscript</tt> File</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-VARIANTS">Variant Builds</a></dt>

<dt><a href="#CHAP-BUILDERS-WRITING">Writing Your Own
Builders</a></dt>

<dd>
<dl>
<dt><a href="#AEN2257">Writing Builders That Execute External
Commands</a></dt>

<dt><a href="#AEN2266">Attaching a Builder to a <tt class=
"LITERAL">Construction Environment</tt></a></dt>

<dt><a href="#AEN2322">Letting <tt class="APPLICATION">SCons</tt>
Handle The File Suffixes</a></dt>

<dt><a href="#AEN2343">Builders That Execute Python
Functions</a></dt>

<dt><a href="#AEN2379">Builders That Create Actions Using a <tt
class="LITERAL">Generator</tt></a></dt>

<dt><a href="#AEN2422">Builders That Modify the Target or Source
Lists Using an <tt class="LITERAL">Emitter</tt></a></dt>
</dl>
</dd>

<dt><a href="#CHAP-BUILDERS-COMMANDS">Not Writing a Builder: the
<tt class="FUNCTION">Command</tt> Builder</a></dt>

<dt><a href="#CHAP-SCANNERS">Writing Scanners</a></dt>

<dd>
<dl>
<dt><a href="#AEN2464">A Simple Scanner Example</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-REPOSITORIES">Building From Code
Repositories</a></dt>

<dd>
<dl>
<dt><a href="#AEN2515">The <tt class="FUNCTION">Repository</tt>
Method</a></dt>

<dt><a href="#AEN2527">Finding source files in
repositories</a></dt>

<dt><a href="#AEN2559">Finding the <tt class=
"FILENAME">SConstruct</tt> file in repositories</a></dt>

<dt><a href="#AEN2577">Finding derived files in
repositories</a></dt>

<dt><a href="#AEN2604">Guaranteeing local copies of files</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-SCONF">Multi-Platform Configuration (<tt class=
"APPLICATION">Autoconf</tt> Functionality)</a></dt>

<dd>
<dl>
<dt><a href="#AEN2638"><tt class="LITERAL">Configure
Contexts</tt></a></dt>

<dt><a href="#AEN2654">Checking for the Existence of Header
Files</a></dt>

<dt><a href="#AEN2663">Checking for the Availability of a
Function</a></dt>

<dt><a href="#AEN2668">Checking for the Availability of a
Library</a></dt>

<dt><a href="#AEN2683">Checking for the Availability of a <tt
class="LITERAL">typedef</tt></a></dt>

<dt><a href="#AEN2694">Adding Your Own Custom Checks</a></dt>

<dt><a href="#AEN2723">Not Configuring When Cleaning
Targets</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-CACHING">Caching Built Files</a></dt>

<dd>
<dl>
<dt><a href="#AEN2739">Specifying the Shared Cache
Directory</a></dt>

<dt><a href="#AEN2753">Keeping Build Output Consistent</a></dt>

<dt><a href="#AEN2766">Not Retrieving Files From a Shared
Cache</a></dt>

<dt><a href="#AEN2778">Populating a Shared Cache With Already-Built
Files</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-ALIAS">Alias Targets</a></dt>

<dt><a href="#CHAP-JAVA">Java Builds</a></dt>

<dd>
<dl>
<dt><a href="#AEN2827">Building Java Class Files: the <tt class=
"FUNCTION">Java</tt> Builder</a></dt>

<dt><a href="#AEN2851">How <tt class="APPLICATION">SCons</tt>
Handles Java Dependencies</a></dt>

<dt><a href="#AEN2878">Building Java Archive (<tt class=
"FILENAME">.jar</tt>) Files: the <tt class="FUNCTION">Jar</tt>
Builder</a></dt>

<dt><a href="#AEN2909">Building C Header and Stub Files: the <tt
class="FUNCTION">JavaH</tt> Builder</a></dt>

<dt><a href="#AEN2963">Building RMI Stub and Skeleton Class Files:
the <tt class="FUNCTION">RMIC</tt> Builder</a></dt>
</dl>
</dd>

<dt><a href="#CHAP-TROUBLESHOOTING">Troubleshooting</a></dt>

<dd>
<dl>
<dt><a href="#AEN2991">Why is That Target Being Rebuilt? the <tt
class="LITERAL">--debug=explain</tt> Option</a></dt>

<dt><a href="#AEN3037">What's in That Construction Environment? the
<tt class="FUNCTION">Dump</tt> Method</a></dt>
</dl>
</dd>

<dt><a href="#APP-VARIABLES">Construction Variables</a></dt>

<dt><a href="#APP-BUILDERS">Builders</a></dt>

<dt><a href="#APP-TOOLS">Tools</a></dt>

<dt><a href="#APP-TASKS">Handling Common Tasks</a></dt>
</dl>
</div>

<div class="PREFACE">
<hr>
<h1><a name="CHAP-PREFACE"></a>Preface</h1>

<p>&#13; Thank you for taking the time to read about <tt class=
"APPLICATION">SCons</tt>. <tt class="APPLICATION">SCons</tt> is a
next-generation software construction tool, or make tool--that is,
a software utility for building software (or other files) and
keeping built software up-to-date whenever the underlying input
files change.</p>

<p>&#13; The most distinctive thing about <tt class=
"APPLICATION">SCons</tt> is that its configuration files are
actually <i class="EMPHASIS">scripts</i>, written in the <tt class=
"APPLICATION">Python</tt> programming language. This is in contrast
to most alternative build tools, which typically invent a new
language to configure the build. <tt class="APPLICATION">SCons</tt>
still has a learning curve, of course, because you have to know
what functions to call to set up your build properly, but the
underlying syntax used should be familiar to anyone who has ever
looked at a Python script.</p>

<p>&#13; Paradoxically, using Python as the configuration file
format makes <tt class="APPLICATION">SCons</tt> <i class=
"EMPHASIS">easier</i> for non-programmers to learn than the cryptic
languages of other build tools, which are usually invented by
programmers for other programmers. This is in no small part due to
the consistency and readability that are built in to Python. It
just so happens that making a real, live scripting language the
basis for the configuration files makes it a snap for more
accomplished programmers to do more complicated things with builds,
as necessary.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN29"></a><tt class=
"APPLICATION">SCons</tt> Principles</h1>

<p>&#13; There are a few overriding principles we try to live up to
in designing and implementing <tt class=
"APPLICATION">SCons</tt>:</p>

<div class="VARIABLELIST">
<dl>
<dt>Correctness</dt>

<dd>
<p>&#13; First and foremost, by default, <tt class=
"APPLICATION">SCons</tt> guarantees a correct build even if it
means sacrificing performance a little. We strive to guarantee the
build is correct regardless of how the software being built is
structured, how it may have been written, or how unusual the tools
are that build it.</p>
</dd>

<dt>Performance</dt>

<dd>
<p>&#13; Given that the build is correct, we try to make <tt class=
"APPLICATION">SCons</tt> build software as quickly as possible. In
particular, wherever we may have needed to slow down the default
<tt class="APPLICATION">SCons</tt> behavior to guarantee a correct
build, we also try to make it easy to speed up <tt class=
"APPLICATION">SCons</tt> through optimization options that let you
trade off guaranteed correctness in all end cases for a speedier
build in the usual cases.</p>
</dd>

<dt>Convenience</dt>

<dd>
<p>&#13; <tt class="APPLICATION">SCons</tt> tries to do as much for
you out of the box as reasonable, including detecting the right
tools on your system and using them correctly to build the
software.</p>
</dd>
</dl>
</div>

<p>&#13; In a nutshell, we try hard to make <tt class=
"APPLICATION">SCons</tt> just "do the right thing" and build
software correctly, with a minimum of hassles.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN54"></a>A Caveat About This Guide's
Completeness</h1>

<p>&#13; One word of warning as you read through this Guide: Like
too much Open Source software out there, the <tt class=
"APPLICATION">SCons</tt> documentation isn't always kept up-to-date
with the available features. In other words, there's a lot that <tt
class="APPLICATION">SCons</tt> can do that isn't yet covered in
this User's Guide. (Come to think of it, that also describes a lot
of proprietary software, doesn't it?)</p>

<p>&#13; Although this User's Guide isn't as complete as we'd like
it to be, our development process does emphasize making sure that
the <tt class="APPLICATION">SCons</tt> man page is kept up-to-date
with new features. So if you're trying to figure out how to do
something that <tt class="APPLICATION">SCons</tt> supports but
can't find enough (or any) information here, it would be worth your
while to look at the man page to see if the information is covered
there. And if you do, maybe you'd even consider contributing a
section to the User's Guide so the next person looking for that
information won't have to go through the same thing...?</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN62"></a>Acknowledgements</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> would not exist without
a lot of help from a lot of people, many of whom may not even be
aware that they helped or served as inspiration. So in no
particular order, and at the risk of leaving out someone:</p>

<p>&#13; First and foremost, <tt class="APPLICATION">SCons</tt>
owes a tremendous debt to Bob Sidebotham, the original author of
the classic Perl-based <tt class="APPLICATION">Cons</tt> tool which
Bob first released to the world back around 1996. Bob's work on
Cons classic provided the underlying architecture and model of
specifying a build configuration using a real scripting language.
My real-world experience working on Cons informed many of the
design decisions in SCons, including the improved parallel build
support, making Builder objects easily definable by users, and
separating the build engine from the wrapping interface.</p>

<p>&#13; Greg Wilson was instrumental in getting <tt class=
"APPLICATION">SCons</tt> started as a real project when he
initiated the Software Carpentry design competition in February
2000. Without that nudge, marrying the advantages of the Cons
classic architecture with the readability of Python might have just
stayed no more than a nice idea.</p>

<p>&#13; The entire <tt class="APPLICATION">SCons</tt> team have
been absolutely wonderful to work with, and <tt class=
"APPLICATION">SCons</tt> would be nowhere near as useful a tool
without the energy, enthusiasm and time people have contributed
over the past few years. The "core team" of Chad Austin, Anthony
Roach, Charles Crain, Steve Leblanc, Gary Oberbrunner, Greg Spencer
and Christoph Wiedemann have been great about reviewing my (and
other) changes and catching problems before they get in the code
base. Of particular technical note: Anthony's outstanding and
innovative work on the tasking engine has given <tt class=
"APPLICATION">SCons</tt> a vastly superior parallel build model;
Charles has been the master of the crucial Node infrastructure;
Christoph's work on the Configure infrastructure has added crucial
Autoconf-like functionality; and Greg has provided excellent
support for Microsoft Visual Studio.</p>

<p>&#13; Special thanks to David Snopek for contributing his
underlying "Autoscons" code that formed the basis of Christoph's
work with the Configure functionality. David was extremely generous
in making this code available to <tt class=
"APPLICATION">SCons</tt>, given that he initially released it under
the GPL and <tt class="APPLICATION">SCons</tt> is released under a
less-restrictive MIT-style license.</p>

<p>&#13; Thanks to Peter Miller for his splendid change management
system, <tt class="APPLICATION">Aegis</tt>, which has provided the
<tt class="APPLICATION">SCons</tt> project with a robust
development methodology from day one, and which showed me how you
could integrate incremental regression tests into a practical
development cycle (years before eXtreme Programming arrived on the
scene).</p>

<p>&#13; And last, thanks to Guido van Rossum for his elegant
scripting language, which is the basis not only for the <tt class=
"APPLICATION">SCons</tt> implementation, but for the interface
itself.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN83"></a>Contact</h1>

<p>&#13; The best way to contact people involved with SCons,
including the author, is through the SCons mailing lists.</p>

<p>&#13; If you want to ask general questions about how to use <tt
class="APPLICATION">SCons</tt> send email to <tt class=
"LITERAL">users@scons.tigris.org</tt>.</p>

<p>&#13; If you want to contact the <tt class=
"APPLICATION">SCons</tt> development community directly, send email
to <tt class="LITERAL">dev@scons.tigris.org</tt>.</p>

<p>&#13; If you want to receive announcements about <tt class=
"APPLICATION">SCons</tt>, join the low-volume <tt class=
"LITERAL">announce@scons.tigris.org</tt> mailing list.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-BUILD-INSTALL"></a>Building and Installing <tt
class="APPLICATION">SCons</tt></h1>

<p>&#13; This chapter will take you through the basic steps of
installing <tt class="APPLICATION">SCons</tt> on your system, and
building <tt class="APPLICATION">SCons</tt> if you don't have a
pre-built package available (or simply prefer the flexibility of
building it yourself). Before that, however, this chapter will also
describe the basic steps involved in installing Python on your
system, in case that is necessary. Fortunately, both <tt class=
"APPLICATION">SCons</tt> and Python are very easy to install on
almost any system, and Python already comes installed on many
systems.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN102"></a>Installing Python</h1>

<p>&#13; Because <tt class="APPLICATION">SCons</tt> is written in
Python, you must obviously have Python installed on your system to
use <tt class="APPLICATION">SCons</tt> Before you try to install
Python, you should check to see if Python is already available on
your system by typing <tt class="USERINPUT"><b>python</b></tt> at
your system's command-line prompt. You should see something like
the following on a UNIX or Linux system that has Python
installed:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       $ <tt class="USERINPUT"><b>python</b></tt>
       Python 2.2.2 (#1, Feb 24 2003, 19:13:11)
       [GCC 3.2.2 20030222 (Red Hat Linux 3.2.2-4)] on linux2
       Type "help", "copyright", "credits" or "license" for more information.
       &gt;&gt;&gt; <tt class="USERINPUT"><b>^D</b></tt>
   
</pre>
</td>
</tr>
</table>

<p>&#13; And on a Windows system with Python installed:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       C:\&gt;<tt class="USERINPUT"><b>python</b></tt>
       Python 2.2.2 (#34, Apr 9 2002, 19:34:33) [MSC 32 bit (Intel)] on win32
       Type "help", "copyright", "credits" or "license" for more information.
       &gt;&gt;&gt; <tt class="USERINPUT"><b>^Z</b></tt>
   
</pre>
</td>
</tr>
</table>

<p>&#13; The <tt class="PROMPT">&gt;&gt;&gt;</tt> is the input
prompt for the Python interpreter. The <tt class=
"USERINPUT"><b>^D</b></tt> and <tt class="USERINPUT"><b>^Z</b></tt>
represent the CTRL-D and CTRL-Z characters that you will need to
type to get out of the interpreter before proceeding to installing
<tt class="APPLICATION">SCons</tt>.</p>

<p>&#13; If Python is not installed on your system, you will see an
error message stating something like "command not found" (on UNIX
or Linux) or "'python' is not recognized as an internal or external
command, operable progam or batch file" (on Windows). In that case,
you need to install Python before you can install <tt class=
"APPLICATION">SCons</tt>.</p>

<p>&#13; The standard location for information about downloading
and installing Python is <a href="http://www.python.org/download/"
target="_top">http://www.python.org/download/</a>. See that page
for information about how to download and install Python on your
system.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN124"></a>Installing <tt class=
"APPLICATION">SCons</tt> From Pre-Built Packages</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> comes pre-packaged for
installation on a number of systems, including Linux and Windows
systems. You do not need to read this entire section, you should
only need to read the section appropriate to the type of system
you're running on.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN129"></a>Installing <tt class=
"APPLICATION">SCons</tt> on Red Hat (and Other RPM-based) Linux
Systems</h2>

<p>&#13; <tt class="APPLICATION">SCons</tt> comes in RPM (Red Hat
Package Manager) format, pre-built and ready to install on Red Hat
Linux, Fedora Core, or any other Linux distribution that uses RPM.
Your distribution may already have an <tt class=
"APPLICATION">SCons</tt> RPM built specifically for it; many do,
including SuSe, Mandrake and Fedora. You can check for the
availability of an <tt class="APPLICATION">SCons</tt> RPM on your
distribution's download servers, or by consulting an RPM search
site like <a href="http://www.rpmfind.net/" target=
"_top">http://www.rpmfind.net/</a> or <a href=
"http://rpm.pbone.net/" target=
"_top">http://rpm.pbone.net/</a>.</p>

<p>&#13; If your Linux distribution does not already have a
specific <tt class="APPLICATION">SCons</tt> RPM file, you can
download and install from the generic RPM provided by the <tt
class="APPLICATION">SCons</tt> project. This will install the SCons
script(s) in <tt class="FILENAME">/usr/bin</tt>, and the SCons
library modules in <tt class="FILENAME">/usr/lib/scons</tt>.</p>

<p>&#13; To install from the command line, simply download the
appropriate <tt class="FILENAME">.rpm</tt> file, and then run:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        # <tt class=
"USERINPUT"><b>rpm -Uvh scons-0.96-1.noarch.rpm</b></tt>
     
</pre>
</td>
</tr>
</table>

<p>&#13; Or, you can use a graphical RPM package manager like <tt
class="APPLICATION">gnorpm</tt>. See your package manager
application's documention for specific instructions about how to
use it to install a downloaded RPM.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN149"></a>Installing <tt class=
"APPLICATION">SCons</tt> on Debian Linux Systems</h2>

<p>&#13; Debian Linux systems use a different package management
format that also makes it very easy to install <tt class=
"APPLICATION">SCons</tt>.</p>

<p>&#13; If your system is connected to the Internet, you can
install the latest official Debian package by running:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        # <tt class="USERINPUT"><b>apt-get install scons</b></tt>
     
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN157"></a>Installing <tt class=
"APPLICATION">SCons</tt> on Windows Systems</h2>

<p>&#13; <tt class="APPLICATION">SCons</tt> provides a Windows
installer that makes installation extremely easy. Download the <tt
class="FILENAME">scons-0.95.win32.exe</tt> file from the <tt class=
"APPLICATION">SCons</tt> download page at <a href=
"http://www.scons.org/download.html" target=
"_top">http://www.scons.org/download.html</a>. Then all you need to
do is execute the file (usually by clicking on its icon in Windows
Explorer). These will take you through a small sequence of windows
that will install <tt class="APPLICATION">SCons</tt> on your
system.</p>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN166"></a>Building and Installing
<tt class="APPLICATION">SCons</tt> on Any System</h1>

<p>&#13; If a pre-built <tt class="APPLICATION">SCons</tt> package
is not available for your system, then you can still easily build
and install <tt class="APPLICATION">SCons</tt> using the native
Python <tt class="FILENAME">distutils</tt> package.</p>

<p>&#13; The first step is to download either the <tt class=
"FILENAME">scons-0.96.90.tar.gz</tt> or <tt class=
"FILENAME">scons-0.96.90.zip</tt>, which are available from the
SCons download page at <a href="http://www.scons.org/download.html"
target="_top">http://www.scons.org/download.html</a>.</p>

<p>&#13; Unpack the archive you downloaded, using a utility like
<tt class="APPLICATION">tar</tt> on Linux or UNIX, or <tt class=
"APPLICATION">WinZip</tt> on Windows. This will create a directory
called <tt class="FILENAME">scons-0.96.90</tt>, usually in your
local directory. Then change your working directory to that
directory and install <tt class="APPLICATION">SCons</tt> by
executing the following commands:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      # <tt class="USERINPUT"><b>cd scons-0.96.90</b></tt>
      # <tt class="USERINPUT"><b>python setup.py install</b></tt>
   
</pre>
</td>
</tr>
</table>

<p>&#13; This will build <tt class="APPLICATION">SCons</tt>,
install the <tt class="APPLICATION">scons</tt> script in the
default system scripts directory (<tt class=
"FILENAME">/usr/local/bin</tt> or <tt class=
"FILENAME">C:\Python2.2\Scripts</tt>), and will install the <tt
class="APPLICATION">SCons</tt> build engine in an appropriate
stand-alone library directory (<tt class=
"FILENAME">/usr/local/lib/scons</tt> or <tt class=
"FILENAME">C:\Python2.2\scons</tt>). Because these are system
directories, you may need root (on Linux or UNIX) or Administrator
(on Windows) privileges to install <tt class=
"APPLICATION">SCons</tt> like this.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN194"></a>Building and Installing
Multiple Versions of <tt class="APPLICATION">SCons</tt>
Side-by-Side</h2>

<p>&#13; The <tt class="APPLICATION">SCons</tt> <tt class=
"FILENAME">setup.py</tt> script has some extensions that support
easy installation of multiple versions of <tt class=
"APPLICATION">SCons</tt> in side-by-side locations. This makes it
easier to download and experiment with different versions of <tt
class="APPLICATION">SCons</tt> before moving your official build
process to a new version, for example.</p>

<p>&#13; To install <tt class="APPLICATION">SCons</tt> in a
version-specific location, add the <tt class=
"OPTION">--version-lib</tt> option when you call <tt class=
"FILENAME">setup.py</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        # <tt class=
"USERINPUT"><b>python setup.py install --version-lib</b></tt>
     
</pre>
</td>
</tr>
</table>

<p>&#13; This will install the <tt class="APPLICATION">SCons</tt>
build engine in the <tt class=
"FILENAME">/usr/lib/scons-0.96.90</tt> or <tt class=
"FILENAME">C:\Python2.2\scons-0.96.90</tt> directory, for
example.</p>

<p>&#13; If you use the <tt class="OPTION">--version-lib</tt>
option the first time you install <tt class=
"APPLICATION">SCons</tt>, you do not need to specify it each time
you install a new version. The <tt class="APPLICATION">SCons</tt>
<tt class="FILENAME">setup.py</tt> script will detect the
version-specific directory name(s) and assume you want to install
all versions in version-specific directories. You can override that
assumption in the future by explicitly specifying the <tt class=
"OPTION">--standalone-lib</tt> option.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN218"></a>Installing <tt class=
"APPLICATION">SCons</tt> in Other Locations</h2>

<p>&#13; You can install <tt class="APPLICATION">SCons</tt> in
locations other than the default by specifying the <tt class=
"OPTION">--prefix=</tt> option:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        # <tt class=
"USERINPUT"><b>python setup.py install --prefix=/opt/scons</b></tt>
     
</pre>
</td>
</tr>
</table>

<p>&#13; This would install the <tt class="APPLICATION">scons</tt>
script in <tt class="FILENAME">/opt/scons/bin</tt> and the build
engine in <tt class="FILENAME">/opt/scons/lib/scons</tt>,</p>

<p>&#13; Note that you can specify both the <tt class=
"OPTION">--prefix=</tt> and the <tt class=
"OPTION">--version-lib</tt> options at the same type, in which case
<tt class="FILENAME">setup.py</tt> will install the build engine in
a version-specific directory relative to the specified prefix.
Adding <tt class="OPTION">--version-lib</tt> to the above example
would install the build engine in <tt class=
"FILENAME">/opt/scons/lib/scons-0.96.90</tt>.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN236"></a>Building and Installing
<tt class="APPLICATION">SCons</tt> Without Administrative
Privileges</h2>

<p>&#13; If you don't have the right privileges to install <tt
class="APPLICATION">SCons</tt> in a system location, simply use the
<tt class="LITERAL">--prefix=</tt> option to install it in a
location of your choosing. For example, to install <tt class=
"APPLICATION">SCons</tt> in appropriate locations relative to the
user's <tt class="LITERAL">$HOME</tt> directory, the <tt class=
"APPLICATION">scons</tt> script in <tt class=
"FILENAME">$HOME/bin</tt> and the build engine in <tt class=
"FILENAME">$HOME/lib/scons</tt>, simply type:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        $ <tt class=
"USERINPUT"><b>python setup.py install --prefix=$HOME</b></tt>
     
</pre>
</td>
</tr>
</table>

<p>&#13; You may, of course, specify any other location you prefer,
and may use the <tt class="OPTION">--version-lib</tt> option if you
would like to install version-specific directories relative to the
specified prefix.</p>
</div>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-SIMPLE"></a>Simple Builds</h1>

<p>&#13; In this chapter, you will see several examples of very
simple build configurations using <tt class=
"APPLICATION">SCons</tt>, which will demonstrate how easy it is to
use <tt class="APPLICATION">SCons</tt> to build programs from
several different programming languages on different types of
systems.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN256"></a>Building Simple C / C++
Programs</h1>

<p>&#13; Here's the famous "Hello, World!" program in C:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      int
      main()
      {
          printf("Hello, world!\n");
      }
  
</pre>
</td>
</tr>
</table>

<p>&#13; And here's how to build it using <tt class=
"APPLICATION">SCons</tt>. Enter the following into a file named <tt
class="FILENAME">SConstruct</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Program('hello.c')
  
</pre>
</td>
</tr>
</table>

<p>&#13; This minimal configuration file gives <tt class=
"APPLICATION">SCons</tt> two pieces of information: what you want
to build (an executable program), and the input file from which you
want it built (the <tt class="FILENAME">hello.c</tt> file). <a
href="#B-PROGRAM"><tt class="FUNCTION">Program</tt></a> is a <i
class="FIRSTTERM">builder_method</i>, a Python call that tells <tt
class="APPLICATION">SCons</tt> that you want to build an executable
program.</p>

<p>&#13; That's it. Now run the <tt class="APPLICATION">scons</tt>
command to build the program. On a POSIX-compliant system like
Linux or UNIX, you'll see something like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      scons: done building targets.
  
</pre>
</td>
</tr>
</table>

<p>&#13; On a Windows system with the Microsoft Visual C++
compiler, you'll see something like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
      cl /nologo /c hello.c /Fohello.obj
      link /nologo /OUT:hello.exe hello.obj
      scons: done building targets.
  
</pre>
</td>
</tr>
</table>

<p>&#13; First, notice that you only need to specify the name of
the source file, and that <tt class="APPLICATION">SCons</tt>
correctly deduces the names of the object and executable files to
be built from the base of the source file name.</p>

<p>&#13; Second, notice that the same input <tt class=
"FILENAME">SConstruct</tt> file, without any changes, generates the
correct output file names on both systems: <tt class=
"FILENAME">hello.o</tt> and <tt class="FILENAME">hello</tt> on
POSIX systems, <tt class="FILENAME">hello.obj</tt> and <tt class=
"FILENAME">hello.exe</tt> on Windows systems. This is a simple
example of how <tt class="APPLICATION">SCons</tt> makes it
extremely easy to write portable software builds.</p>

<p>&#13; (Note that we won't provide duplicate side-by-side POSIX
and Windows output for all of the examples in this guide; just keep
in mind that, unless otherwise specified, any of the examples
should work equally well on both types of systems.)</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN288"></a>Building Object Files</h1>

<p>&#13; The <a href="#B-PROGRAM"><tt class=
"FUNCTION">Program</tt></a> builder method is only one of many
builder methods that <tt class="APPLICATION">SCons</tt> provides to
build different types of files. Another is the <a href=
"#B-OBJECT"><tt class="FUNCTION">Object</tt></a> builder method,
which tells <tt class="APPLICATION">SCons</tt> to build an object
file from the specified source file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Object('hello.c')
  
</pre>
</td>
</tr>
</table>

<p>&#13; Now when you run the <tt class="APPLICATION">scons</tt>
command to build the program, it will build just the <tt class=
"FILENAME">hello.o</tt> object file on a POSIX system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
      cc -c -o hello.o hello.c
      scons: done building targets.
  
</pre>
</td>
</tr>
</table>

<p>&#13; And just the <tt class="FILENAME">hello.obj</tt> object
file on a Windows system (with the Microsoft Visual C++
compiler):</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
      cl /nologo /c hello.c /Fohello.obj
      scons: done building targets.
  
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN307"></a>Simple Java Builds</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> also makes building
with Java extremely easy. Unlike the <a href="#B-PROGRAM"><tt
class="FUNCTION">Program</tt></a> and <a href="#B-OBJECT"><tt
class="FUNCTION">Object</tt></a> builder methods, however, the <a
href="#B-JAVA"><tt class="FUNCTION">Java</tt></a> builder method
requires that you specify the name of a destination directory in
which you want the class files placed, followed by the source
directory in which the <tt class="FILENAME">.java</tt> files
live:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     Java('classes', 'src')
  
</pre>
</td>
</tr>
</table>

<p>&#13; If the <tt class="FILENAME">src</tt> directory contains a
single <tt class="FILENAME">hello.java</tt> file, then the output
from running the <tt class="APPLICATION">scons</tt> command would
look something like this (on a POSIX system):</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
      javac -d classes -sourcepath src src/hello.java
      scons: done building targets.
  
</pre>
</td>
</tr>
</table>

<p>&#13; We'll cover Java builds in more detail, including building
Java archive (<tt class="FILENAME">.jar</tt>) and other types of
file, in <a href="#CHAP-JAVA">the chapter called <i>Java
Builds</i></a>.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN328"></a>Cleaning Up After a
Build</h1>

<p>&#13; When using <tt class="APPLICATION">SCons</tt>, it is
unnecessary to add special commands or target names to clean up
after a build. Instead, you simply use the <tt class=
"LITERAL">-c</tt> or <tt class="LITERAL">--clean</tt> option when
you invoke <tt class="APPLICATION">SCons</tt>, and <tt class=
"APPLICATION">SCons</tt> removes the appropriate built files. So if
we build our example above and then invoke <tt class=
"LITERAL">scons -c</tt> afterwards, the output on POSIX looks
like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      scons: done building targets.
      % <tt class="USERINPUT"><b>scons -c</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Cleaning targets ...
      Removed hello.o
      Removed hello
      scons: done cleaning targets.
  
</pre>
</td>
</tr>
</table>

<p>&#13; And the output on Windows looks like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
      cl /nologo /c hello.c /Fohello.obj
      link /nologo /OUT:hello.exe hello.obj
      scons: done building targets.
      C:\&gt;<tt class="USERINPUT"><b>scons -c</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Cleaning targets ...
      Removed hello.obj
      Removed hello.exe
      scons: done cleaning targets.
  
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that <tt class="APPLICATION">SCons</tt> changes its
output to tell you that it is <tt class="LITERAL">Cleaning targets
...</tt> and <tt class="LITERAL">done cleaning targets.</tt></p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN348"></a>The <tt class=
"FILENAME">SConstruct</tt> File</h1>

<p>&#13; If you're used to build systems like <tt class=
"APPLICATION">Make</tt> you've already figured out that the <tt
class="FILENAME">SConstruct</tt> file is the <tt class=
"APPLICATION">SCons</tt> equivalent of a <tt class=
"FILENAME">Makefile</tt>. That is, the <tt class=
"FILENAME">SConstruct</tt> file is the input file that <tt class=
"APPLICATION">SCons</tt> reads to control the build.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN358"></a><tt class=
"FILENAME">SConstruct</tt> Files Are Python Scripts</h2>

<p>&#13; There is, however, an important difference between an <tt
class="FILENAME">SConstruct</tt> file and a <tt class=
"FILENAME">Makefile</tt>: the <tt class="FILENAME">SConstruct</tt>
file is actually a Python script. If you're not already familiar
with Python, don't worry. This User's Guide will introduce you
step-by-step to the relatively small amount of Python you'll need
to know to be able to use <tt class="APPLICATION">SCons</tt>
effectively. And Python is very easy to learn.</p>

<p>&#13; One aspect of using Python as the scripting language is
that you can put comments in your <tt class=
"FILENAME">SConstruct</tt> file using Python's commenting
convention; that is, everything between a '#' and the end of the
line will be ignored:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        # Arrange to build the "hello" program.
        Program('hello.c')    # "hello.c" is the source file.
    
</pre>
</td>
</tr>
</table>

<p>&#13; You'll see throughout the remainder of this Guide that
being able to use the power of a real scripting language can
greatly simplify the solutions to complex requirements of
real-world builds.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN370"></a><tt class=
"APPLICATION">SCons</tt> Functions Are Order-Independent</h2>

<p>&#13; One important way in which the <tt class=
"FILENAME">SConstruct</tt> file is not exactly like a normal Python
script, and is more like a <tt class="FILENAME">Makefile</tt>, is
that the order in which the <tt class="APPLICATION">SCons</tt>
functions are called in the <tt class="FILENAME">SConstruct</tt>
file does <i class="EMPHASIS">not</i> affect the order in which <tt
class="APPLICATION">SCons</tt> actually builds the programs and
object files you want it to build.<a name="AEN380" href=
"#FTN.AEN380">[1]</a> In other words, when you call the <a href=
"#B-PROGRAM"><tt class="FUNCTION">Program</tt></a> builder (or any
other builder method), you're not telling <tt class=
"APPLICATION">SCons</tt> to build the program at the instant the
builder method is called. Instead, you're telling <tt class=
"APPLICATION">SCons</tt> to build the program that you want, for
example, a program built from a file named <tt class=
"FILENAME">hello.c</tt>, and it's up to <tt class=
"APPLICATION">SCons</tt> to build that program (and any other
files) whenever it's necessary. (We'll learn more about how <tt
class="APPLICATION">SCons</tt> decides when building or rebuilding
a file is necessary in <a href="#CHAP-DEPENDS">the chapter called
<i>Dependencies</i></a>, below.)</p>

<p>&#13; <tt class="APPLICATION">SCons</tt> reflects this
distinction between <i class="EMPHASIS">calling a builder method
like</i> <tt class="FUNCTION">Program</tt>&gt; and <i class=
"EMPHASIS">actually building the program</i> by printing the status
messages that indicate when it's "just reading" the <tt class=
"FILENAME">SConstruct</tt> file, and when it's actually building
the target files. This is to make it clear when <tt class=
"APPLICATION">SCons</tt> is executing the Python statements that
make up the <tt class="FILENAME">SConstruct</tt> file, and when <tt
class="APPLICATION">SCons</tt> is actually executing the commands
or other actions to build the necessary files.</p>

<p>&#13; Let's clarify this with an example. Python has a <tt
class="LITERAL">print</tt> statement that prints a string of
characters to the screen. If we put <tt class="LITERAL">print</tt>
statements around our calls to the <tt class=
"FUNCTION">Program</tt> builder method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       print "Calling Program('hello.c')"
       Program('hello.c')
       print "Calling Program('goodbye.c')"
       Program('goodbye.c')
       print "Finished calling Program()"
    
</pre>
</td>
</tr>
</table>

<p>&#13; Then when we execute <tt class="APPLICATION">SCons</tt>,
we see the output from the <tt class="LITERAL">print</tt>
statements in between the messages about reading the <tt class=
"FILENAME">SConscript</tt> files, indicating that that is when the
Python statements are being executed:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons</b></tt>
       scons: Reading SConscript files ...
       Calling Program('hello.c')
       Calling Program('goodbye.c')
       Finished calling Program()
       scons: done reading SConscript files.
       scons: Building targets ...
       cc -c -o goodbye.o goodbye.c
       cc -o goodbye goodbye.o
       cc -c -o hello.o hello.c
       cc -o hello hello.o
       scons: done building targets.
    
</pre>
</td>
</tr>
</table>

<p>&#13; Notice also that <tt class="APPLICATION">SCons</tt> built
the <tt class="APPLICATION">goodbye</tt> program first, even though
the "reading <tt class="FILENAME">SConscript</tt>" output shows
that we called <tt class="LITERAL">Program('hello.c')</tt> first in
the <tt class="FILENAME">SConstruct</tt> file.</p>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN420"></a>Making the <tt class=
"APPLICATION">SCons</tt> Output Less Verbose</h1>

<p>&#13; You've already seen how <tt class="APPLICATION">SCons</tt>
prints some messages about what it's doing, surrounding the actual
commands used to build the software:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
      cl /nologo /c hello.c /Fohello.obj
      link /nologo /OUT:hello.exe hello.obj
      scons: done building targets.
  
</pre>
</td>
</tr>
</table>

<p>&#13; These messages emphasize the order in which <tt class=
"APPLICATION">SCons</tt> does its work: all of the configuration
files (generically referred to as <tt class=
"FILENAME">SConscript</tt> files) are read and executed first, and
only then are the target files built. Among other benefits, these
messages help to distinguish between errors that occur while the
configuration files are read, and errors that occur while targets
are being built.</p>

<p>&#13; One drawback, of course, is that these messages clutter
the output. Fortunately, they're easily disabled by using the <tt
class="LITERAL">-Q</tt> option when invoking <tt class=
"APPLICATION">SCons</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
      cl /nologo /c hello.c /Fohello.obj
      link /nologo /OUT:hello.exe hello.obj
  
</pre>
</td>
</tr>
</table>

<p>&#13; Because we want this User's Guide to focus on what <tt
class="APPLICATION">SCons</tt> is actually doing, we're going use
the <tt class="LITERAL">-Q</tt> option to remove these messages
from the output of all the remaining examples in this Guide.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-LESS-SIMPLE"></a>Less Simple Things to Do With
Builds</h1>

<p>&#13; In this chapter, you will see several examples of very
simple build configurations using <tt class=
"APPLICATION">SCons</tt>, which will demonstrate how easy it is to
use <tt class="APPLICATION">SCons</tt> to build programs from
several different programming languages on different types of
systems.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN443"></a>Specifying the Name of the
Target (Output) File</h1>

<p>&#13; You've seen that when you call the <a href=
"#B-PROGRAM"><tt class="FUNCTION">Program</tt></a> builder method,
it builds the resulting program with the same base name as the
source file. That is, the following call to build an executable
program from the <tt class="FILENAME">hello.c</tt> source file will
build an executable program named <tt class=
"APPLICATION">hello</tt> on POSIX systems, and an executable
program named <tt class="FILENAME">hello.exe</tt> on Windows
systems:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; If you want to build a program with a different name than
the base of the source file name, you simply put the target file
name to the left of the source file name:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('new_hello', 'hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; (<tt class="APPLICATION">SCons</tt> requires the target
file name first, followed by the source file name, so that the
order mimics that of an assignment statement in most programming
languages, including Python: <tt class="LITERAL">"program = source
files"</tt>.)</p>

<p>&#13; Now <tt class="APPLICATION">SCons</tt> will build an
executable program named <tt class="APPLICATION">new_hello</tt>
when run on a POSIX system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o hello.o hello.c
       cc -o new_hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; And <tt class="APPLICATION">SCons</tt> will build an
executable program named <tt class="APPLICATION">new_hello.exe</tt>
when run on a Windows system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
       cl /nologo /c hello.c /Fohello.obj
       link /nologo /OUT:new_hello.exe hello.obj
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN467"></a>Compiling Multiple Source
Files</h1>

<p>&#13; You've just seen how to configure <tt class=
"APPLICATION">SCons</tt> to compile a program from a single source
file. It's more common, of course, that you'll need to build a
program from many input source files, not just one. To do this, you
need to put the source files in a Python list (enclosed in square
brackets), like so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program(['main.c', 'file1.c', 'file2.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; A build of the above example would look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o file1.o file1.c
       cc -c -o file2.o file2.c
       cc -c -o main.o main.c
       cc -o main main.o file1.o file2.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that <tt class="APPLICATION">SCons</tt> deduces the
output program name from the first source file specified in the
list--that is, because the first source file was <tt class=
"FILENAME">prog.c</tt>, <tt class="APPLICATION">SCons</tt> will
name the resulting program <tt class="FILENAME">prog</tt> (or <tt
class="FILENAME">prog.exe</tt> on a Windows system). If you want to
specify a different program name, then (as we've seen in the
previous section) you slide the list of source files over to the
right to make room for the output program file name. (<tt class=
"APPLICATION">SCons</tt> puts the output file name to the left of
the source file names so that the order mimics that of an
assignment statement: "program = source files".) This makes our
example:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('program', ['main.c', 'file1.c', 'file2.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; On Linux, a build of this example would look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o file1.o file1.c
       cc -c -o file2.o file2.c
       cc -c -o main.o main.c
       cc -o program main.o file1.o file2.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Or on Windows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
       cl /nologo /c file1.c /Fofile1.obj
       cl /nologo /c file2.c /Fofile2.obj
       cl /nologo /c main.c /Fomain.obj
       link /nologo /OUT:program.exe main.obj file1.obj file2.obj
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN489"></a>Specifying Single Files
Vs. Lists of Files</h1>

<p>&#13; We've now shown you two ways to specify the source for a
program, one with a list of files:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('hello', ['file1.c', 'file2.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; And one with a single file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('hello', 'hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; You could actually put a single file name in a list, too,
which you might prefer just for the sake of consistency:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('hello', ['hello.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> functions will accept a
single file name in either form. In fact, internally, <tt class=
"APPLICATION">SCons</tt> treats all input as lists of files, but
allows you to omit the square brackets to cut down a little on the
typing when there's only a single file name.</p>

<div class="IMPORTANT">
<table class="IMPORTANT" width="100%" border="0">
<tr>
<td width="25" align="CENTER" valign="TOP"><img src=
"./stylesheet-images/important.gif" hspace="5" alt=
"Important"></td>
<td align="LEFT" valign="TOP">
<p>&#13; Although <tt class="APPLICATION">SCons</tt> functions are
forgiving about whether or not you use a string vs. a list for a
single file name, Python itself is more strict about treating lists
and strings differently. So where <tt class=
"APPLICATION">SCons</tt> allows either a string or list:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       # The following two calls both work correctly:
       Program('program1', 'program1.c')
       Program('program2', ['program2.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Trying to do "Python things" that mix strings and lists
will cause errors or lead to incorrect results:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       common_sources = ['file1.c', 'file2.c']

       # THE FOLLOWING IS INCORRECT AND GENERATES A PYTHON ERROR
       # BECAUSE IT TRIES TO ADD A STRING TO A LIST:
       Program('program1', common_sources + 'program1.c')

       # The following works correctly, because it's adding two
       # lists together to make another list.
       Program('program2', common_sources + ['program2.c'])
   
</pre>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN507"></a>Making Lists of Files
Easier to Read</h1>

<p>&#13; One drawback to the use of a Python list for source files
is that each file name must be enclosed in quotes (either single
quotes or double quotes). This can get cumbersome and difficult to
read when the list of file names is long. Fortunately, <tt class=
"APPLICATION">SCons</tt> and Python provide a number of ways to
make sure that the <tt class="FILENAME">SConstruct</tt> file stays
easy to read.</p>

<p>&#13; To make long lists of file names easier to deal with, <tt
class="APPLICATION">SCons</tt> provides a <tt class=
"FUNCTION">Split</tt> function that takes a quoted list of file
names, with the names separated by spaces or other white-space
characters, and turns it into a list of separate file names. Using
the <tt class="FUNCTION">Split</tt> function turns the previous
example into:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('program', Split('main.c file1.c file2.c'))
   
</pre>
</td>
</tr>
</table>

<p>&#13; (If you're already familiar with Python, you'll have
realized that this is similar to the <tt class=
"FUNCTION">split()</tt> method in the Python standard <tt class=
"FUNCTION">string</tt> module. Unlike the <tt class=
"FUNCTION">string.split()</tt> method, however, the <tt class=
"FUNCTION">Split</tt> function does not require a string as input
and will wrap up a single non-string object in a list, or return
its argument untouched if it's already a list. This comes in handy
as a way to make sure arbitrary values can be passed to <tt class=
"APPLICATION">SCons</tt> functions without having to check the type
of the variable by hand.)</p>

<p>&#13; Putting the call to the <tt class="FUNCTION">Split</tt>
function inside the <tt class="FUNCTION">Program</tt> call can also
be a little unwieldy. A more readable alternative is to assign the
output from the <tt class="FUNCTION">Split</tt> call to a variable
name, and then use the variable when calling the <tt class=
"FUNCTION">Program</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       list = Split('main.c file1.c file2.c')
       Program('program', list)
   
</pre>
</td>
</tr>
</table>

<p>&#13; Lastly, the <tt class="FUNCTION">Split</tt> function
doesn't care how much white space separates the file names in the
quoted string. This allows you to create lists of file names that
span multiple lines, which often makes for easier editing:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       list = Split("""main.c
                       file1.c
                       file2.c""")
       Program('program', list)
   
</pre>
</td>
</tr>
</table>

<p>&#13; (Note in this example that we used the Python
"triple-quote" syntax, which allows a string to contain multiple
lines. The three quotes can be either single or double quotes.)</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN533"></a>Keyword Arguments</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> also allows you to
identify the output file and input source files using Python
keyword arguments. The output file is known as the <i class=
"EMPHASIS">target</i>, and the source file(s) are known (logically
enough) as the <i class="EMPHASIS">source</i>. The Python syntax
for this is:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       list = Split('main.c file1.c file2.c')
       Program(target = 'program', source = list)
   
</pre>
</td>
</tr>
</table>

<p>&#13; Because the keywords explicitly identify what each
argument is, you can actually reverse the order if you prefer:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       list = Split('main.c file1.c file2.c')
       Program(source = list, target = 'program')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Whether or not you choose to use keyword arguments to
identify the target and source files, and the order in which you
specify them when using keywords, are purely personal choices; <tt
class="APPLICATION">SCons</tt> functions the same regardless.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN544"></a>Compiling Multiple
Programs</h1>

<p>&#13; In order to compile multiple programs within the same <tt
class="FILENAME">SConstruct</tt> file, simply call the <tt class=
"FUNCTION">Program</tt> method multiple times, once for each
program you need to build:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('foo.c')
       Program('bar', ['bar1.c', 'bar2.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> would then build the
programs as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o bar1.o bar1.c
       cc -c -o bar2.o bar2.c
       cc -o bar bar1.o bar2.o
       cc -c -o foo.o foo.c
       cc -o foo foo.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that <tt class="APPLICATION">SCons</tt> does not
necessarily build the programs in the same order in which you
specify them in the <tt class="FILENAME">SConstruct</tt> file. <tt
class="APPLICATION">SCons</tt> does, however, recognize that the
individual object files must be built before the resulting program
can be built. We'll discuss this in greater detail in the
"Dependencies" section, below.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN558"></a>Sharing Source Files
Between Multiple Programs</h1>

<p>&#13; It's common to re-use code by sharing source files between
multiple programs. One way to do this is to create a library from
the common source files, which can then be linked into resulting
programs. (Creating libraries is discussed in <a href=
"#CHAP-LIBRARIES">the chapter called <i>Building and Linking with
Libraries</i></a>, below.)</p>

<p>&#13; A more straightforward, but perhaps less convenient, way
to share source files between multiple programs is simply to
include the common files in the lists of source files for each
program:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program(Split('foo.c common1.c common2.c'))
       Program('bar', Split('bar1.c bar2.c common1.c common2.c'))
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> recognizes that the
object files for the <tt class="FILENAME">common1.c</tt> and <tt
class="FILENAME">common2.c</tt> source files each only need to be
built once, even though the resulting object files are each linked
in to both of the resulting executable programs:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o bar1.o bar1.c
       cc -c -o bar2.o bar2.c
       cc -c -o common1.o common1.c
       cc -c -o common2.o common2.c
       cc -o bar bar1.o bar2.o common1.o common2.o
       cc -c -o foo.o foo.c
       cc -o foo foo.o common1.o common2.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; If two or more programs share a lot of common source
files, repeating the common files in the list for each program can
be a maintenance problem when you need to change the list of common
files. You can simplify this by creating a separate Python list to
hold the common file names, and concatenating it with other lists
using the Python <tt class="LITERAL">+</tt> operator:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       common = ['common1.c', 'common2.c']
       foo_files = ['foo.c'] + common
       bar_files = ['bar1.c', 'bar2.c'] + common
       Program('foo', foo_files)
       Program('bar', bar_files)
   
</pre>
</td>
</tr>
</table>

<p>&#13; This is functionally equivalent to the previous
example.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-LIBRARIES"></a>Building and Linking with
Libraries</h1>

<p>&#13; It's often useful to organize large software projects by
collecting parts of the software into one or more libraries. <tt
class="APPLICATION">SCons</tt> makes it easy to create libraries
and to use them in the programs.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN578"></a>Building Libraries</h1>

<p>&#13; You build your own libraries by specifying <a href=
"#B-LIBRARY"><tt class="FUNCTION">Library</tt></a> instead of <a
href="#B-PROGRAM"><tt class="FUNCTION">Program</tt></a>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Library('foo', ['f1.c', 'f2.c', 'f3.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> uses the appropriate
library prefix and suffix for your system. So on POSIX or Linux
systems, the above example would build as follows (although <tt
class="APPLICATION">ranlib</tt> may not be called on all
systems):</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o f1.o f1.c
      cc -c -o f2.o f2.c
      cc -c -o f3.o f3.c
      ar r libfoo.a f1.o f2.o f3.o
      ranlib libfoo.a
   
</pre>
</td>
</tr>
</table>

<p>&#13; On a Windows system, a build of the above example would
look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
      cl /nologo /c f1.c /Fof1.obj
      cl /nologo /c f2.c /Fof2.obj
      cl /nologo /c f3.c /Fof3.obj
      lib /nologo /OUT:foo.lib f1.obj f2.obj f3.obj
   
</pre>
</td>
</tr>
</table>

<p>&#13; The rules for the target name of the library are similar
to those for programs: if you don't explicitly specify a target
library name, <tt class="APPLICATION">SCons</tt> will deduce one
from the name of the first source file specified, and <tt class=
"APPLICATION">SCons</tt> will add an appropriate file prefix and
suffix if you leave them off.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN597"></a>Building Static Libraries
Explicitly: the <tt class="FUNCTION">StaticLibrary</tt>
Builder</h2>

<p>&#13; The <a href="#B-LIBRARY"><tt class=
"FUNCTION">Library</tt></a> function builds a traditional static
library. If you want to be explicit about the type of library being
built, you can use the synonym <a href="#B-STATICLIBRARY"><tt
class="FUNCTION">StaticLibrary</tt></a> function instead of <tt
class="FUNCTION">Library</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        StaticLibrary('foo', ['f1.c', 'f2.c', 'f3.c'])
     
</pre>
</td>
</tr>
</table>

<p>&#13; There is no functional difference between the <a href=
"#B-STATICLIBRARY"><tt class="FUNCTION">StaticLibrary</tt></a> and
<tt class="FUNCTION">Library</tt> functions.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN611"></a>Building Shared (DLL)
Libraries: the <tt class="FUNCTION">SharedLibrary</tt> Builder</h2>

<p>&#13; If you want to build a shared library (on POSIX systems)
or a DLL file (on Windows systems), you use the <a href=
"#B-SHAREDLIBRARY"><tt class="FUNCTION">SharedLibrary</tt></a>
function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        SharedLibrary('foo', ['f1.c', 'f2.c', 'f3.c'])
     
</pre>
</td>
</tr>
</table>

<p>&#13; The output on POSIX:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q</b></tt>
        cc -c -o f1.os f1.c
        cc -c -o f2.os f2.c
        cc -c -o f3.os f3.c
        cc -shared -o libfoo.so f1.os f2.os f3.os
     
</pre>
</td>
</tr>
</table>

<p>&#13; And the output on Windows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
        cl /nologo /c f1.c /Fof1.obj
        cl /nologo /c f2.c /Fof2.obj
        cl /nologo /c f3.c /Fof3.obj
        link /nologo /dll /out:foo.dll /implib:foo.lib f1.obj f2.obj f3.obj
        RegServerFunc(target, source, env)
     
</pre>
</td>
</tr>
</table>

<p>&#13; Notice again that <tt class="APPLICATION">SCons</tt> takes
care of building the output file correctly, adding the <tt class=
"LITERAL">-shared</tt> option for a POSIX compilation, and the <tt
class="LITERAL">/dll</tt> option on Windows.</p>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN628"></a>Linking with
Libraries</h1>

<p>&#13; Usually, you build a library because you want to link it
with one or more programs. You link libraries with a program by
specifying the libraries in the <a href="#CV-LIBS"><tt class=
"ENVAR">$LIBS</tt></a> construction variable, and by specifying the
directory in which the library will be found in the <a href=
"#CV-LIBPATH"><tt class="ENVAR">$LIBPATH</tt></a> construction
variable:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Library('foo', ['f1.c', 'f2.c', 'f3.c'])
      Program('prog.c', LIBS=['foo', 'bar'], LIBPATH='.')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice, of course, that you don't need to specify a
library prefix (like <tt class="LITERAL">lib</tt>) or suffix (like
<tt class="LITERAL">.a</tt> or <tt class="LITERAL">.lib</tt>). <tt
class="APPLICATION">SCons</tt> uses the correct prefix or suffix
for the current system.</p>

<p>&#13; On a POSIX or Linux system, a build of the above example
would look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o f1.o f1.c
      cc -c -o f2.o f2.c
      cc -c -o f3.o f3.c
      ar r libfoo.a f1.o f2.o f3.o
      ranlib libfoo.a
      cc -c -o prog.o prog.c
      cc -o prog prog.o -L. -lfoo -lbar
   
</pre>
</td>
</tr>
</table>

<p>&#13; On a Windows system, a build of the above example would
look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
      cl /nologo /c f1.c /Fof1.obj
      cl /nologo /c f2.c /Fof2.obj
      cl /nologo /c f3.c /Fof3.obj
      lib /nologo /OUT:foo.lib f1.obj f2.obj f3.obj
      cl /nologo /c prog.c /Foprog.obj
      link /nologo /OUT:prog.exe /LIBPATH:. foo.lib bar.lib prog.obj
   
</pre>
</td>
</tr>
</table>

<p>&#13; As usual, notice that <tt class="APPLICATION">SCons</tt>
has taken care of constructing the correct command lines to link
with the specified library on each system.</p>

<p>&#13; Note also that, if you only have a single library to link
with, you can specify the library name in single string, instead of
a Python list, so that:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Program('prog.c', LIBS='foo', LIBPATH='.')
   
</pre>
</td>
</tr>
</table>

<p>&#13; is equivalent to:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Program('prog.c', LIBS=['foo'], LIBPATH='.')
   
</pre>
</td>
</tr>
</table>

<p>&#13; This is similar to the way that <tt class=
"APPLICATION">SCons</tt> handles either a string or a list to
specify a single source file.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN655"></a>Finding Libraries: the <tt
class="ENVAR">$LIBPATH</tt> Construction Variable</h1>

<p>&#13; By default, the linker will only look in certain
system-defined directories for libraries. <tt class=
"APPLICATION">SCons</tt> knows how to look for libraries in
directories that you specify with the <a href="#CV-LIBPATH"><tt
class="ENVAR">$LIBPATH</tt></a> construction variable. <tt class=
"ENVAR">$LIBPATH</tt> consists of a list of directory names, like
so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Program('prog.c', LIBS = 'm',
                        LIBPATH = ['/usr/lib', '/usr/local/lib'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Using a Python list is preferred because it's portable
across systems. Alternatively, you could put all of the directory
names in a single string, separated by the system-specific path
separator character: a colon on POSIX systems:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      LIBPATH = '/usr/lib:/usr/local/lib'
   
</pre>
</td>
</tr>
</table>

<p>&#13; or a semi-colon on Windows systems:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      LIBPATH = 'C:\\lib;D:\\lib'
   
</pre>
</td>
</tr>
</table>

<p>&#13; (Note that Python requires that the backslash separators
in a Windows path name be escaped within strings.)</p>

<p>&#13; When the linker is executed, <tt class=
"APPLICATION">SCons</tt> will create appropriate flags so that the
linker will look for libraries in the same directories as <tt
class="APPLICATION">SCons</tt>. So on a POSIX or Linux system, a
build of the above example would look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o prog.o prog.c
      cc -o prog prog.o -L/usr/lib -L/usr/local/lib -lm
   
</pre>
</td>
</tr>
</table>

<p>&#13; On a Windows system, a build of the above example would
look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
      cl /nologo /c prog.c /Foprog.obj
      link /nologo /OUT:prog.exe /LIBPATH:\usr\lib /LIBPATH:\usr\local\lib m.lib prog.obj
   
</pre>
</td>
</tr>
</table>

<p>&#13; Note again that <tt class="APPLICATION">SCons</tt> has
taken care of the system-specific details of creating the right
command-line options.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-NODES"></a>Node Objects</h1>

<p>&#13; Internally, <tt class="APPLICATION">SCons</tt> represents
all of the files and directories it knows about as <tt class=
"LITERAL">Nodes</tt>. These internal objects (not object <i class=
"EMPHASIS">files</i>) can be used in a variety of ways to make your
<tt class="FILENAME">SConscript</tt> files portable and easy to
read.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN686"></a>Builder Methods Return
Lists of Target Nodes</h1>

<p>&#13; All builder methods return a list of <tt class=
"CLASSNAME">Node</tt> objects that identify the target file or
files that will be built. These returned <tt class=
"LITERAL">Nodes</tt> can be passed as source files to other builder
methods,</p>

<p>&#13; For example, suppose that we want to build the two object
files that make up a program with different options. This would
mean calling the <a href="#B-OBJECT"><tt class=
"FUNCTION">Object</tt></a> builder once for each object file,
specifying the desired options:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    Object('hello.c', CCFLAGS='-DHELLO')
    Object('goodbye.c', CCFLAGS='-DGOODBYE')
   
</pre>
</td>
</tr>
</table>

<p>&#13; One way to combine these object files into the resulting
program would be to call the <a href="#B-PROGRAM"><tt class=
"FUNCTION">Program</tt></a> builder with the names of the object
files listed as sources:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    Object('hello.c', CCFLAGS='-DHELLO')
    Object('goodbye.c', CCFLAGS='-DGOODBYE')
    Program(['hello.o', 'goodbye.o'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; The problem with listing the names as strings is that our
<tt class="FILENAME">SConstruct</tt> file is no longer portable
across operating systems. It won't, for example, work on Windows
because the object files there would be named <tt class=
"FILENAME">hello.obj</tt> and <tt class=
"FILENAME">goodbye.obj</tt>, not <tt class="FILENAME">hello.o</tt>
and <tt class="FILENAME">goodbye.o</tt>.</p>

<p>&#13; A better solution is to assign the lists of targets
returned by the calls to the <tt class="FUNCTION">Object</tt>
builder to variables, which we can then concatenate in our call to
the <tt class="FUNCTION">Program</tt> builder:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      hello_list = Object('hello.c', CCFLAGS='-DHELLO')
      goodbye_list = Object('goodbye.c', CCFLAGS='-DGOODBYE')
      Program(hello_list + goodbye_list)
   
</pre>
</td>
</tr>
</table>

<p>&#13; This makes our <tt class="FILENAME">SConstruct</tt> file
portable again, the build output on Linux looking like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -DGOODBYE -c -o goodbye.o goodbye.c
       cc -DHELLO -c -o hello.o hello.c
       cc -o hello hello.o goodbye.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; And on Windows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
       cl -DGOODBYE /c goodbye.c /Fogoodbye.obj
       cl -DHELLO /c hello.c /Fohello.obj
       link /nologo /OUT:hello.exe hello.obj goodbye.obj
   
</pre>
</td>
</tr>
</table>

<p>&#13; We'll see examples of using the list of nodes returned by
builder methods throughout the rest of this guide.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN717"></a>Explicitly Creating File
and Directory Nodes</h1>

<p>&#13; It's worth mentioning here that <tt class=
"APPLICATION">SCons</tt> maintains a clear distinction between
Nodes that represent files and Nodes that represent directories.
<tt class="APPLICATION">SCons</tt> supports <tt class=
"FUNCTION">File</tt> and <tt class="FUNCTION">Dir</tt> functions
that, repectively, return a file or directory Node:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      hello_c = File('hello.c')
      Program(hello_c)

      classes = Dir('classes')
      Java(classes, 'src')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Normally, you don't need to call <tt class=
"FUNCTION">File</tt> or <tt class="FUNCTION">Dir</tt> directly,
because calling a builder method automatically treats strings as
the names of files or directories, and translates them into the
Node objects for you. The <tt class="FUNCTION">File</tt> and <tt
class="FUNCTION">Dir</tt> functions can come in handy in situations
where you need to explicitly instruct <tt class=
"APPLICATION">SCons</tt> about the type of Node being passed to a
builder or other function, or unambiguously refer to a specific
file in a directory tree.</p>

<p>&#13; There are also times when you may need to refer to an
entry in a file system without knowing in advance whether it's a
file or a directory. For those situations, <tt class=
"APPLICATION">SCons</tt> also supports an <tt class=
"FUNCTION">Entry</tt> function, which returns a Node that can
represent either a file or a directory.</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    xyzzy = Entry('xyzzy')
   
</pre>
</td>
</tr>
</table>

<p>&#13; The returned <tt class="LITERAL">xyzzy</tt> Node will be
turned into a file or directory Node the first time it is used by a
builder method or other function that requires one vs. the
other.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN737"></a>Printing <tt class=
"CLASSNAME">Node</tt> File Names</h1>

<p>&#13; One of the most common things you can do with a Node is
use it to print the file name that the node represents. For
example, the following <tt class="FILENAME">SConstruct</tt>
file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      hello_c = File('hello.c')
      Program(hello_c)

      classes = Dir('classes')
      Java(classes, 'src')

      object_list = Object('hello.c')
      program_list = Program(object_list)
      print "The object file is:", object_list[0]
      print "The program file is:", program_list[0]
   
</pre>
</td>
</tr>
</table>

<p>&#13; Would print the following file names on a POSIX
system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      The object file is: hello.o
      The program file is: hello
      cc -c -o hello.o hello.c
      cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; And the following file names on a Windows system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
      The object file is: hello.obj
      The program file is: hello.exe
      cl /nologo /c hello.c /Fohello.obj
      link /nologo /OUT:hello.exe hello.obj
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN749"></a>Using a <tt class=
"CLASSNAME">Node</tt>'s File Name as a String</h1>

<p>&#13; Printing a <tt class="CLASSNAME">Node</tt>'s name as
described in the previous section works because the string
representation of a <tt class="CLASSNAME">Node</tt> is the name of
the file. If you want to do something other than print the name of
the file, you can fetch it by using the builtin Python <tt class=
"FUNCTION">str</tt> function. For example, if you want to use the
Python <tt class="FUNCTION">os.path.exists</tt> to figure out
whether a file exists while the <tt class=
"FILENAME">SConstruct</tt> file is being read and executed, you can
fetch the string as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      import os.path
      program_list = Program('hello.c')
      program_name = str(program_list[0])
      if not os.path.exists(program_name)
          print program_name, "does not exist!"
   
</pre>
</td>
</tr>
</table>

<p>&#13; Which executes as follows on a POSIX system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      The object file is: hello.o
      The program file is: hello
      cc -c -o hello.o hello.c
      cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-DEPENDS"></a>Dependencies</h1>

<p>&#13; So far we've seen how <tt class="APPLICATION">SCons</tt>
handles one-time builds. But the real point of a build tool like
<tt class="APPLICATION">SCons</tt> is to rebuild only the necessary
things when source files change--or, put another way, <tt class=
"APPLICATION">SCons</tt> should <i class="EMPHASIS">not</i> waste
time rebuilding things that have already been built. You can see
this at work simply be re-invoking <tt class=
"APPLICATION">SCons</tt> after building our simple <tt class=
"APPLICATION">hello</tt> example:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
     % <tt class="USERINPUT"><b>scons -Q</b></tt>
     cc -c -o hello.o hello.c
     cc -o hello hello.o
     % <tt class="USERINPUT"><b>scons -Q</b></tt>
     scons: `.' is up to date.
 
</pre>
</td>
</tr>
</table>

<p>&#13; The second time it is executed, <tt class=
"APPLICATION">SCons</tt> realizes that the <tt class=
"APPLICATION">hello</tt> program is up-to-date with respect to the
current <tt class="FILENAME">hello.c</tt> source file, and avoids
rebuilding it. You can see this more clearly by naming the <tt
class="APPLICATION">hello</tt> program explicitly on the command
line:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
     % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
     cc -c -o hello.o hello.c
     cc -o hello hello.o
     % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
     scons: `hello' is up to date.
 
</pre>
</td>
</tr>
</table>

<p>&#13; Note that <tt class="APPLICATION">SCons</tt> reports <tt
class="LITERAL">"...is up to date"</tt> only for target files named
explicitly on the command line, to avoid cluttering the output.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN785"></a>Deciding When a Source
File Has Changed: the <tt class="FUNCTION">SourceSignatures</tt>
Function</h1>

<p>&#13; The other side of avoiding unnecessary rebuilds is the
fundamental build tool behavior of <i class=
"EMPHASIS">rebuilding</i> things when a source file changes, so
that the built software is up to date. <tt class=
"APPLICATION">SCons</tt> keeps track of this through a <tt class=
"LITERAL">signature</tt> for each source file, and allows you to
configure whether you want to use the source file contents or the
modification time (timestamp) as the signature.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN792"></a>MD5 Source File
Signatures</h2>

<p>&#13; By default, <tt class="APPLICATION">SCons</tt> keeps track
of whether a source file has changed based on the file's contents,
not the modification time. This means that you may be surprised by
the default <tt class="APPLICATION">SCons</tt> behavior if you are
used to the <tt class="APPLICATION">Make</tt> convention of forcing
a rebuild by updating the file's modification time (using the <tt
class="APPLICATION">touch</tt> command, for example):</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
         % <tt class="USERINPUT"><b>touch hello.c</b></tt>
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         scons: `hello' is up to date.
     
</pre>
</td>
</tr>
</table>

<p>&#13; Even though the file's modification time has changed, <tt
class="APPLICATION">SCons</tt> realizes that the contents of the
<tt class="FILENAME">hello.c</tt> file have <i class=
"EMPHASIS">not</i> changed, and therefore that the <tt class=
"APPLICATION">hello</tt> program need not be rebuilt. This avoids
unnecessary rebuilds when, for example, someone rewrites the
contents of a file without making a change. But if the contents of
the file really do change, then <tt class="APPLICATION">SCons</tt>
detects the change and rebuilds the program as required:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
         % <tt class="USERINPUT"><b>edit hello.c</b></tt>
             [CHANGE THE CONTENTS OF hello.c]
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
     
</pre>
</td>
</tr>
</table>

<p>&#13; Note that you can, if you wish, specify this default
behavior (MD5 signatures) explicitly using the <tt class=
"FUNCTION">SourceSignatures</tt> function as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Program('hello.c')
        SourceSignatures('MD5')
     
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN816"></a>Source File Time
Stamps</h2>

<p>&#13; If you prefer, you can configure <tt class=
"APPLICATION">SCons</tt> to use the modification time of source
files, not the file contents, when deciding if something needs to
be rebuilt. To do this, call the <tt class=
"FUNCTION">SourceSignatures</tt> function as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Program('hello.c')
        SourceSignatures('timestamp')
     
</pre>
</td>
</tr>
</table>

<p>&#13; This makes <tt class="APPLICATION">SCons</tt> act like <tt
class="APPLICATION">Make</tt> when a file's modification time is
updated (using the <tt class="APPLICATION">touch</tt> command, for
example):</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
         % <tt class="USERINPUT"><b>touch hello.c</b></tt>
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
     
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN830"></a>Deciding When a Target
File Has Changed: the <tt class="FUNCTION">TargetSignatures</tt>
Function</h1>

<p>&#13; As you've just seen, <tt class="APPLICATION">SCons</tt>
uses signatures to decide whether a target file is up to date or
must be rebuilt. When a target file depends on another target file,
<tt class="APPLICATION">SCons</tt> allows you to configure
separately how the signatures of "intermediate" target files are
used when deciding if a dependent target file must be rebuilt.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN836"></a>Build Signatures</h2>

<p>&#13; Modifying a source file will cause not only its direct
target file to be rebuilt, but also the target file(s) that depend
on that direct target file. In our example, changing the contents
of the <tt class="FILENAME">hello.c</tt> file causes the <tt class=
"FILENAME">hello.o</tt> file to be rebuilt, which in turn causes
the <tt class="APPLICATION">hello</tt> program to be rebuilt:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
         % <tt class="USERINPUT"><b>edit hello.c</b></tt>
             [CHANGE THE CONTENTS OF hello.c]
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
     
</pre>
</td>
</tr>
</table>

<p>&#13; What's not obvious, though, is that <tt class=
"APPLICATION">SCons</tt> internally handles the signature of the
target file(s) (<tt class="FILENAME">hello.o</tt> in the above
example) differently from the signature of the source file (<tt
class="FILENAME">hello.c</tt>). By default, <tt class=
"APPLICATION">SCons</tt> tracks whether a target file must be
rebuilt by using a <tt class="LITERAL">build signature</tt> that
consists of the combined signatures of all the files that go into
making the target file. This is efficient because the accumulated
signatures actually give <tt class="APPLICATION">SCons</tt> all of
the information it needs to decide if the target file is out of
date.</p>

<p>&#13; If you wish, you can specify this default behavior (build
signatures) explicitly using the <tt class=
"FUNCTION">TargetSignatures</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Program('hello.c')
        TargetSignatures('build')
     
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN856"></a>File Contents</h2>

<p>&#13; Sometimes a source file can be changed in such a way that
the contents of the rebuilt target file(s) will be exactly the same
as the last time the file was built. If so, then any other target
files that depend on such a built-but-not-changed target file
actually need not be rebuilt. You can make <tt class=
"APPLICATION">SCons</tt> realize that it does not need to rebuild a
dependent target file in this situation using the <tt class=
"FUNCTION">TargetSignatures</tt> function as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Program('hello.c')
        TargetSignatures('content')
     
</pre>
</td>
</tr>
</table>

<p>&#13; So if, for example, a user were to only change a comment
in a C file, then the rebuilt <tt class="FILENAME">hello.o</tt>
file would be exactly the same as the one previously built
(assuming the compiler doesn't put any build-specific information
in the object file). <tt class="APPLICATION">SCons</tt> would then
realize that it would not need to rebuild the <tt class=
"APPLICATION">hello</tt> program as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
         % <tt class="USERINPUT"><b>edit hello.c</b></tt>
           [CHANGE A COMMENT IN hello.c]
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         cc -c -o hello.o hello.c
         scons: `hello' is up to date.
     
</pre>
</td>
</tr>
</table>

<p>&#13; In essence, <tt class="APPLICATION">SCons</tt> has
"short-circuited" any dependent builds when it realizes that a
target file has been rebuilt to exactly the same file as the last
build. So configured, <tt class="APPLICATION">SCons</tt> does take
some extra processing time to scan the contents of the target (<tt
class="FILENAME">hello.o</tt>) file, but this may save time if the
rebuild that was avoided would have been very time-consuming and
expensive.</p>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN874"></a>Implicit Dependencies: The
<tt class="ENVAR">$CPPPATH</tt> Construction Variable</h1>

<p>&#13; Now suppose that our "Hello, World!" program actually has
a <tt class="LITERAL">#include</tt> line to include the <tt class=
"FILENAME">hello.h</tt> file in the compilation:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       #include &lt;hello.h&gt;
       int
       main()
       {
           printf("Hello, %s!\n", string);
       }
   
</pre>
</td>
</tr>
</table>

<p>&#13; And, for completeness, the <tt class=
"FILENAME">hello.h</tt> file looks like this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       #define string    "world"
     
</pre>
</td>
</tr>
</table>

<p>&#13; In this case, we want <tt class="APPLICATION">SCons</tt>
to recognize that, if the contents of the <tt class=
"FILENAME">hello.h</tt> file change, the <tt class=
"APPLICATION">hello</tt> program must be recompiled. To do this, we
need to modify the <tt class="FILENAME">SConstruct</tt> file like
so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('hello.c', CPPPATH = '.')
     
</pre>
</td>
</tr>
</table>

<p>&#13; The <tt class="ENVAR">$CPPPATH</tt> value tells <tt class=
"APPLICATION">SCons</tt> to look in the current directory (<tt
class="LITERAL">'.'</tt>) for any files included by C source files
(<tt class="FILENAME">.c</tt> or <tt class="FILENAME">.h</tt>
files). With this assignment in the <tt class=
"FILENAME">SConstruct</tt> file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
       cc -I. -c -o hello.o hello.c
       cc -o hello hello.o
       % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
       scons: `hello' is up to date.
       % <tt class="USERINPUT"><b>edit hello.h</b></tt>
           [CHANGE THE CONTENTS OF hello.h]
       % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
       cc -I. -c -o hello.o hello.c
       cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; First, notice that <tt class="APPLICATION">SCons</tt>
added the <tt class="LITERAL">-I.</tt> argument from the <tt class=
"ENVAR">$CPPPATH</tt> variable so that the compilation would find
the <tt class="FILENAME">hello.h</tt> file in the local
directory.</p>

<p>&#13; Second, realize that <tt class="APPLICATION">SCons</tt>
knows that the <tt class="APPLICATION">hello</tt> program must be
rebuilt because it scans the contents of the <tt class=
"FILENAME">hello.c</tt> file for the <tt class=
"LITERAL">#include</tt> lines that indicate another file is being
included in the compilation. <tt class="APPLICATION">SCons</tt>
records these as <i class="EMPHASIS">implicit dependencies</i> of
the target file, Consequently, when the <tt class=
"FILENAME">hello.h</tt> file changes, <tt class=
"APPLICATION">SCons</tt> realizes that the <tt class=
"FILENAME">hello.c</tt> file includes it, and rebuilds the
resulting <tt class="APPLICATION">hello</tt> program that depends
on both the <tt class="FILENAME">hello.c</tt> and <tt class=
"FILENAME">hello.h</tt> files.</p>

<p>&#13; Like the <tt class="ENVAR">$LIBPATH</tt> variable, the <tt
class="ENVAR">$CPPPATH</tt> variable may be a list of directories,
or a string separated by the system-specific path separate
character (':' on POSIX/Linux, ';' on Windows). Either way, <tt
class="APPLICATION">SCons</tt> creates the right command-line
options so that the following example:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       Program('hello.c', CPPPATH = ['include', '/home/project/inc'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Will look like this on POSIX or Linux:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
       cc -Iinclude -I/home/project/inc -c -o hello.o hello.c
       cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; And like this on Windows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       C:\&gt;<tt class="USERINPUT"><b>scons -Q hello.exe</b></tt>
       cl /nologo /Iinclude /I\home\project\inc /c hello.c /Fohello.obj
       link /nologo /OUT:hello.exe hello.obj
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN931"></a>Caching Implicit
Dependencies</h1>

<p>&#13; Scanning each file for <tt class="LITERAL">#include</tt>
lines does take some extra processing time. When you're doing a
full build of a large system, the scanning time is usually a very
small percentage of the overall time spent on the build. You're
most likely to notice the scanning time, however, when you <i
class="EMPHASIS">rebuild</i> all or part of a large system: <tt
class="APPLICATION">SCons</tt> will likely take some extra time to
"think about" what must be built before it issues the first build
command (or decides that everything is up to date and nothing must
be rebuilt).</p>

<p>&#13; In practice, having <tt class="APPLICATION">SCons</tt>
scan files saves time relative to the amount of potential time lost
to tracking down subtle problems introduced by incorrect
dependencies. Nevertheless, the "waiting time" while <tt class=
"APPLICATION">SCons</tt> scans files can annoy individual
developers waiting for their builds to finish. Consequently, <tt
class="APPLICATION">SCons</tt> lets you cache the implicit
dependencies that its scanners find, for use by later builds. You
can do this by specifying the <tt class=
"LITERAL">--implicit-cache</tt> option on the command line:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class=
"USERINPUT"><b>scons -Q --implicit-cache hello</b></tt>
       cc -c -o hello.o hello.c
       cc -o hello hello.o
       % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
       scons: `hello' is up to date.
   
</pre>
</td>
</tr>
</table>

<p>&#13; If you don't want to specify <tt class=
"LITERAL">--implicit-cache</tt> on the command line each time, you
can make it the default behavior for your build by setting the <tt
class="LITERAL">implicit_cache</tt> option in an <tt class=
"FILENAME">SConscript</tt> file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       SetOption('implicit_cache', 1)
   
</pre>
</td>
</tr>
</table>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN950"></a>The <tt class=
"LITERAL">--implicit-deps-changed</tt> Option</h2>

<p>&#13; When using cached implicit dependencies, sometimes you
want to "start fresh" and have <tt class="APPLICATION">SCons</tt>
re-scan the files for which it previously cached the dependencies.
For example, if you have recently installed a new version of
external code that you use for compilation, the external header
files will have changed and the previously-cached implicit
dependencies will be out of date. You can update them by running
<tt class="APPLICATION">SCons</tt> with the <tt class=
"LITERAL">--implicit-deps-changed</tt> option:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class=
"USERINPUT"><b>scons -Q --implicit-deps-changed hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         scons: `hello' is up to date.
     
</pre>
</td>
</tr>
</table>

<p>&#13; In this case, <tt class="APPLICATION">SCons</tt> will
re-scan all of the implicit dependencies and cache updated copies
of the information.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN962"></a>The <tt class=
"LITERAL">--implicit-deps-unchanged</tt> Option</h2>

<p>&#13; By default when caching dependencies, <tt class=
"APPLICATION">SCons</tt> notices when a file has been modified and
re-scans the file for any updated implicit dependency information.
Sometimes, however, you may want to force <tt class=
"APPLICATION">SCons</tt> to use the cached implicit dependencies,
even if the source files changed. This can speed up a build for
example, when you have changed your source files but know that you
haven't changed any <tt class="LITERAL">#include</tt> lines. In
this case, you can use the <tt class=
"LITERAL">--implicit-deps-unchanged</tt> option:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class=
"USERINPUT"><b>scons -Q --implicit-deps-unchanged hello</b></tt>
         cc -c -o hello.o hello.c
         cc -o hello hello.o
         % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
         scons: `hello' is up to date.
     
</pre>
</td>
</tr>
</table>

<p>&#13; In this case, <tt class="APPLICATION">SCons</tt> will
assume that the cached implicit dependencies are correct and will
not bother to re-scan changed files. For typical builds after
small, incremental changes to source files, the savings may not be
very big, but sometimes every bit of improved performance
counts.</p>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN975"></a>Ignoring Dependencies: the
<tt class="FUNCTION">Ignore</tt> Method</h1>

<p>&#13; Sometimes it makes sense to not rebuild a program, even if
a dependency file changes. In this case, you would tell <tt class=
"APPLICATION">SCons</tt> specifically to ignore a dependency as
follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      hello = Program('hello.c')
      Ignore(hello, 'hello.h')
   
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
      scons: `hello' is up to date.
      % <tt class="USERINPUT"><b>edit hello.h</b></tt>
        [CHANGE THE CONTENTS OF hello.h]
      % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
      scons: `hello' is up to date.
   
</pre>
</td>
</tr>
</table>

<p>&#13; Now, the above example is a little contrived, because it's
hard to imagine a real-world situation where you wouldn't to
rebuild <tt class="APPLICATION">hello</tt> if the <tt class=
"FILENAME">hello.h</tt> file changed. A more realistic example
might be if the <tt class="APPLICATION">hello</tt> program is being
built in a directory that is shared between multiple systems that
have different copies of the <tt class="FILENAME">stdio.h</tt>
include file. In that case, <tt class="APPLICATION">SCons</tt>
would notice the differences between the different systems' copies
of <tt class="FILENAME">stdio.h</tt> and would rebuild <tt class=
"APPLICATION">hello</tt> each time you change systems. You could
avoid these rebuilds as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       hello = Program('hello.c')
       Ignore(hello, '/usr/include/stdio.h')
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN995"></a>Explicit Dependencies: the
<tt class="FUNCTION">Depends</tt> Method</h1>

<p>&#13; On the other hand, sometimes a file depends on another
file that is not detected by an <tt class="APPLICATION">SCons</tt>
scanner. For this situation, <tt class="APPLICATION">SCons</tt>
allows you to specific explicitly that one file depends on another
file, and must be rebuilt whenever that file changes. This is
specified using the <tt class="FUNCTION">Depends</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       hello = Program('hello.c')
       Depends(hello, 'other_file')
   
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
       % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
       scons: `hello' is up to date.
       % <tt class="USERINPUT"><b>edit other_file</b></tt>
           [CHANGE THE CONTENTS OF other_file]
       % <tt class="USERINPUT"><b>scons -Q hello</b></tt>
       cc -c hello.c -o hello.o
       cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-ENVIRONMENTS"></a>Construction Environments</h1>

<p>&#13; It is rare that all of the software in a large,
complicated system needs to be built the same way. For example,
different source files may need different options enabled on the
command line, or different executable programs need to be linked
with different libraries. <tt class="APPLICATION">SCons</tt>
accomodates these different build requirements by allowing you to
create and configure multiple <tt class="LITERAL">construction
environments</tt> that control how the software is built.
Technically, a <tt class="LITERAL">construction environment</tt> is
an object that has a number of associated <tt class=
"LITERAL">construction variables</tt>, each with a name and a
value. (A construction environment also has an attached set of <tt
class="CLASSNAME">Builder</tt> methods, about which we'll learn
more later.)</p>

<p>&#13; A <tt class="LITERAL">construction environment</tt> is
created by the <tt class="FUNCTION">Environment</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
 
</pre>
</td>
</tr>
</table>

<p>&#13; By default, <tt class="APPLICATION">SCons</tt> intializes
every new construction environment with a set of <tt class=
"LITERAL">construction variables</tt> based on the tools that it
finds on your system, plus the default set of builder methods
necessary for using those tools. The construction variables are
initialized with values describing the C compiler, the Fortran
compiler, the linker, etc., as well as the command lines to invoke
them.</p>

<p>&#13; When you initialize a construction environment you can set
the values of the environment's <tt class="LITERAL">construction
variables</tt> to control how a program is built. For example:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment(CC = 'gcc',
                      CCFLAGS = '-O2')

    env.Program('foo.c')
 
</pre>
</td>
</tr>
</table>

<p>The construction environment in this example is still
initialized with the same default construction variable values,
except that the user has explicitly specified use of the GNU C
compiler <tt class="APPLICATION">gcc</tt>, and further specifies
that the <tt class="LITERAL">-O2</tt> (optimization level two) flag
should be used when compiling the object file. In other words, the
explicit initializations of <a href="#CV-CC"><tt class=
"ENVAR">$CC</tt></a> and <a href="#CV-CCFLAGS"><tt class=
"ENVAR">$CCFLAGS</tt></a> override the default values in the
newly-created construction environment. So a run from this example
would look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons -Q</b></tt>
    gcc -O2 -c -o foo.o foo.c
    gcc -o foo foo.o
</pre>
</td>
</tr>
</table>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1035"></a>Multiple <tt class=
"LITERAL">Construction Environments</tt></h1>

<p>&#13; The real advantage of construction environments is that
you can create as many different construction environments as you
need, each tailored to a different way to build some piece of
software or other file. If, for example, we need to build one
program with the <tt class="LITERAL">-O2</tt> flag and another with
the <tt class="LITERAL">-g</tt> (debug) flag, we would do this like
so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      opt = Environment(CCFLAGS = '-O2')
      dbg = Environment(CCFLAGS = '-g')

      opt.Program('foo', 'foo.c')

      dbg.Program('bar', 'bar.c')
  
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -g -c -o bar.o bar.c
      cc -o bar bar.o
      cc -O2 -c -o foo.o foo.c
      cc -o foo foo.o
  
</pre>
</td>
</tr>
</table>

<p>&#13; We can even use multiple construction environments to
build multiple versions of a single program. If you do this by
simply trying to use the <a href="#B-PROGRAM"><tt class=
"FUNCTION">Program</tt></a> builder with both environments, though,
like this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      opt = Environment(CCFLAGS = '-O2')
      dbg = Environment(CCFLAGS = '-g')

      opt.Program('foo', 'foo.c')

      dbg.Program('foo', 'foo.c')
  
</pre>
</td>
</tr>
</table>

<p>&#13; Then <tt class="APPLICATION">SCons</tt> generates the
following error:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      
      scons: *** Two environments with different actions were specified for the same target: foo.o
      File "SConstruct", line 6, in ?
  
</pre>
</td>
</tr>
</table>

<p>&#13; This is because the two <tt class="FUNCTION">Program</tt>
calls have each implicitly told <tt class="APPLICATION">SCons</tt>
to generate an object file named <tt class="FILENAME">foo.o</tt>,
one with a <a href="#CV-CCFLAGS"><tt class=
"ENVAR">$CCFLAGS</tt></a> value of <tt class="LITERAL">-O2</tt> and
one with a <a href="#CV-CCFLAGS"><tt class=
"ENVAR">$CCFLAGS</tt></a> value of <tt class="LITERAL">-g</tt>. <tt
class="APPLICATION">SCons</tt> can't just decide that one of them
should take precedence over the other, so it generates the error.
To avoid this problem, we must explicitly specify that each
environment compile <tt class="FILENAME">foo.c</tt> to a
separately-named object file using the <a href="#B-OBJECT"><tt
class="FUNCTION">Object</tt></a> builder, like so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      opt = Environment(CCFLAGS = '-O2')
      dbg = Environment(CCFLAGS = '-g')

      o = opt.Object('foo-opt', 'foo.c')
      opt.Program(o)

      d = dbg.Object('foo-dbg', 'foo.c')
      dbg.Program(d)
  
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that each call to the <tt class=
"FUNCTION">Object</tt> builder returns a value, an internal <tt
class="APPLICATION">SCons</tt> object that represents the object
file that will be built. We then use that object as input to the
<tt class="FUNCTION">Program</tt> builder. This avoids having to
specify explicitly the object file name in multiple places, and
makes for a compact, readable <tt class="FILENAME">SConstruct</tt>
file. Our <tt class="APPLICATION">SCons</tt> output then looks
like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -g -c -o foo-dbg.o foo.c
      cc -o foo-dbg foo-dbg.o
      cc -O2 -c -o foo-opt.o foo.c
      cc -o foo-opt foo-opt.o
  
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1075"></a>Copying <tt class=
"LITERAL">Construction Environments</tt></h1>

<p>&#13; Sometimes you want more than one construction environment
to share the same values for one or more variables. Rather than
always having to repeat all of the common variables when you create
each construction environment, you can use the <tt class=
"FUNCTION">Copy</tt> method to create a copy of a construction
environment.</p>

<p>&#13; Like the <tt class="FUNCTION">Environment</tt> call that
creates a construction environment, the <tt class=
"FUNCTION">Copy</tt> method takes <tt class="LITERAL">construction
variable</tt> assignments, which will override the values in the
copied construction environment. For example, suppose we want to
use <tt class="APPLICATION">gcc</tt> to create three versions of a
program, one optimized, one debug, and one with neither. We could
do this by creating a "base" construction environment that sets <a
href="#CV-CC"><tt class="ENVAR">$CC</tt></a> to <tt class=
"APPLICATION">gcc</tt>, and then creating two copies, one which
sets <a href="#CV-CCFLAGS"><tt class="ENVAR">$CCFLAGS</tt></a> for
optimization and the other which sets <tt class=
"ENVAR">$CCFLAGS</tt> for debugging:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      env = Environment(CC = 'gcc')
      opt = env.Copy(CCFLAGS = '-O2')
      dbg = env.Copy(CCFLAGS = '-g')

      env.Program('foo', 'foo.c')

      o = opt.Object('foo-opt', 'foo.c')
      opt.Program(o)

      d = dbg.Object('foo-dbg', 'foo.c')
      dbg.Program(d)
  
</pre>
</td>
</tr>
</table>

<p>&#13; Then our output would look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      gcc -c -o foo.o foo.c
      gcc -o foo foo.o
      gcc -g -c -o foo-dbg.o foo.c
      gcc -o foo-dbg foo-dbg.o
      gcc -O2 -c -o foo-opt.o foo.c
      gcc -o foo-opt foo-opt.o
  
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1095"></a>Fetching Values From a
<tt class="LITERAL">Construction Environment</tt></h1>

<p>&#13; You can fetch individual construction variables using the
normal syntax for accessing individual named items in a Python
dictionary:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      env = Environment()
      print "CC is:", env['CC']
  
</pre>
</td>
</tr>
</table>

<p>&#13; This example <tt class="FILENAME">SConstruct</tt> file
doesn't build anything, but because it's actually a Python script,
it will print the value of <a href="#CV-CC"><tt class=
"ENVAR">$CC</tt></a> for us:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      CC is: cc
      scons: `.' is up to date.
  
</pre>
</td>
</tr>
</table>

<p>&#13; A construction environment, however, is actually an object
with associated methods, etc. If you want to have direct access to
only the dictionary of construction variables, you can fetch this
using the <tt class="LITERAL">Dictionary</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      env = Environment(FOO = 'foo', BAR = 'bar')
      dict = env.Dictionary()
      for key in ['OBJSUFFIX', 'LIBSUFFIX', 'PROGSUFFIX']:
          print "key = %s, value = %s" % (key, dict[key])
  
</pre>
</td>
</tr>
</table>

<p>&#13; This <tt class="FILENAME">SConstruct</tt> file will print
the specified dictionary items for us on POSIX systems as
follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      key = OBJSUFFIX, value = .o
      key = LIBSUFFIX, value = .a
      key = PROGSUFFIX, value = 
      scons: `.' is up to date.
  
</pre>
</td>
</tr>
</table>

<p>&#13; And on Win32:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons -Q</b></tt>
      key = OBJSUFFIX, value = .obj
      key = LIBSUFFIX, value = .lib
      key = PROGSUFFIX, value = .exe
      scons: `.' is up to date.
  
</pre>
</td>
</tr>
</table>

<p>&#13; If you want to loop through and print the values of all of
the construction variables in a construction environment, the
Python code to do that in sorted order might look something
like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      env = Environment()
      dict = env.Dictionary()
      keys = dict.keys()
      keys.sort()
      for key in keys:
          print "construction variable = '%s', value = '%s'" % (key, dict[key])
  
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1118"></a>Expanding Values From a
<tt class="LITERAL">Construction Environment</tt></h1>

<p>&#13; Another way to get information from a construction
environment. is to use the <tt class="FUNCTION">subst</tt> method
on a string containing $-expansions of construction variable names.
As a simple example, the example from the previous section that
used <tt class="LITERAL">env['CC']</tt> to fetch the value of <a
href="#CV-CC"><tt class="ENVAR">$CC</tt></a> could also be written
as:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment()
     print "CC is:", env.subst('$CC')
  
</pre>
</td>
</tr>
</table>

<p>&#13; The real advantage of using <tt class=
"FUNCTION">subst</tt> to expand strings is that construction
variables in the result get re-expanded until there are no
expansions left in the string. So a simple fetch of a value like <a
href="#CV-CCCOM"><tt class="ENVAR">$CCCOM</tt></a>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment(CCFLAGS = '-DFOO')
     print "CCCOM is:", env['CCCOM']
  
</pre>
</td>
</tr>
</table>

<p>&#13; Will print the unexpanded value of <tt class=
"ENVAR">$CCCOM</tt>, showing us the construction variables that
still need to be expanded:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
     % <tt class="USERINPUT"><b>scons -Q</b></tt>
     CCCOM is: $CC $CCFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS -c -o $TARGET $SOURCES
     scons: `.' is up to date.
  
</pre>
</td>
</tr>
</table>

<p>&#13; Calling the <tt class="FUNCTION">subst</tt> method on <tt
class="VARNAME">$CCOM</tt>, however:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment(CCFLAGS = '-DFOO')
     print "CCCOM is:", env.subst('$CCCOM')
  
</pre>
</td>
</tr>
</table>

<p>&#13; Will recursively expand all of the $-prefixed construction
variables, showing us the final output:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
     % <tt class="USERINPUT"><b>scons -Q</b></tt>
     CCCOM is: gcc -DFOO -c -o
     scons: `.' is up to date.
  
</pre>
</td>
</tr>
</table>

<p>&#13; (Note that because we're not expanding this in the context
of building something there are no target or source files for <a
href="#CV-TARGET"><tt class="ENVAR">$TARGET</tt></a> and <a href=
"#CV-SOURCES"><tt class="ENVAR">$SOURCES</tt></a> to expand.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1148"></a>Modifying a <tt class=
"LITERAL">Construction Environment</tt></h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> provides various
methods that support modifying existing values in a construction
environment.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1153"></a>Replacing Values in a <tt
class="LITERAL">Construction Environment</tt></h2>

<p>&#13; You can replace existing construction variable values
using the <tt class="FUNCTION">Replace</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment(CCFLAGS = '-DDEFINE1')
        env.Replace(CCFLAGS = '-DDEFINE2')
        env.Program('foo.c')
    
</pre>
</td>
</tr>
</table>

<p>&#13; The replacing value (<tt class="LITERAL">-DDEFINE2</tt> in
the above example) completely replaces the value in the
construction environment:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q</b></tt>
        cc -DDEFINE2 -c -o foo.o foo.c
        cc -o foo foo.o
    
</pre>
</td>
</tr>
</table>

<p>&#13; You can safely call <tt class="FUNCTION">Replace</tt> for
construction variables that don't exist in the construction
environment:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment()
        env.Replace(NEW_VARIABLE = 'xyzzy')
        print "NEW_VARIABLE =", env['NEW_VARIABLE']
    
</pre>
</td>
</tr>
</table>

<p>&#13; In this case, the construction variable simply gets added
to the construction environment:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q</b></tt>
        NEW_VARIABLE = xyzzy
        scons: `.' is up to date.
    
</pre>
</td>
</tr>
</table>

<p>&#13; Because the variables aren't expanded until the
construction environment is actually used to build the targets, and
because <tt class="APPLICATION">SCons</tt> function and method
calls are order-independent, the last replacement "wins" and is
used to build all targets, regardless of the order in which the
calls to Replace() are interspersed with calls to builder
methods:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment(CCFLAGS = '-DDEFINE1')
        print "CCFLAGS =", env['CCFLAGS']
        env.Program('foo.c')

        env.Replace(CCFLAGS = '-DDEFINE2')
        print "CCFLAGS =", env['CCFLAGS']
        env.Program('bar.c')
    
</pre>
</td>
</tr>
</table>

<p>&#13; The timing of when the replacement actually occurs
relative to when the targets get built becomes apparent if we run
<tt class="APPLICATION">scons</tt> without the <tt class=
"LITERAL">-Q</tt> option:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons</b></tt>
        scons: Reading SConscript files ...
        CCFLAGS = -DDEFINE1
        CCFLAGS = -DDEFINE2
        scons: done reading SConscript files.
        scons: Building targets ...
        cc -DDEFINE2 -c -o bar.o bar.c
        cc -o bar bar.o
        cc -DDEFINE2 -c -o foo.o foo.c
        cc -o foo foo.o
        scons: done building targets.
    
</pre>
</td>
</tr>
</table>

<p>&#13; Because the replacement occurs while the <tt class=
"FILENAME">SConscript</tt> files are being read, the <a href=
"#CV-CCFLAGS"><tt class="ENVAR">$CCFLAGS</tt></a> variable has
already been set to <tt class="LITERAL">-DDEFINE2</tt> by the time
the <tt class="FILENAME">foo.o</tt> target is built, even though
the call to the <tt class="FUNCTION">Replace</tt> method does not
occur until later in the <tt class="FILENAME">SConscript</tt>
file.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1185"></a>Appending to the End of
Values in a <tt class="LITERAL">Construction Environment</tt></h2>

<p>&#13; You can append a value to an existing construction
variable using the <tt class="FUNCTION">Append</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment(CCFLAGS = '-DMY_VALUE')
        env.Append(CCFLAGS = ' -DLAST')
        env.Program('foo.c')
    
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> then supplies both the
<tt class="LITERAL">-DMY_VALUE</tt> and <tt class=
"LITERAL">-DLAST</tt> flags when compiling the object file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q</b></tt>
        cc -DMY_VALUE -DLAST -c -o foo.o foo.c
        cc -o foo foo.o
    
</pre>
</td>
</tr>
</table>

<p>&#13; If the construction variable doesn't already exist, the
<tt class="FUNCTION">Append</tt> method will create it:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment()
        env.Append(NEW_VARIABLE = 'added')
        print "NEW_VARIABLE =", env['NEW_VARIABLE']
    
</pre>
</td>
</tr>
</table>

<p>&#13; Which yields:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q</b></tt>
        NEW_VARIABLE = added
        scons: `.' is up to date.
    
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1203"></a>Appending to the
Beginning of Values in a <tt class="LITERAL">Construction
Environment</tt></h2>

<p>&#13; You can append a value to the beginning an existing
construction variable using the <tt class="FUNCTION">Prepend</tt>
method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment(CCFLAGS = '-DMY_VALUE')
        env.Prepend(CCFLAGS = '-DFIRST ')
        env.Program('foo.c')
    
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> then supplies both the
<tt class="LITERAL">-DFIRST</tt> and <tt class=
"LITERAL">-DMY_VALUE</tt> flags when compiling the object file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q</b></tt>
        cc -DFIRST -DMY_VALUE -c -o foo.o foo.c
        cc -o foo foo.o
    
</pre>
</td>
</tr>
</table>

<p>&#13; If the construction variable doesn't already exist, the
<tt class="FUNCTION">Prepend</tt> method will create it:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment()
        env.Prepend(NEW_VARIABLE = 'added')
        print "NEW_VARIABLE =", env['NEW_VARIABLE']
    
</pre>
</td>
</tr>
</table>

<p>&#13; Which yields:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q</b></tt>
        NEW_VARIABLE = added
        scons: `.' is up to date.
    
</pre>
</td>
</tr>
</table>
</div>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-ENV"></a>Controlling the External Environment
Used to Execute Build Commands</h1>

<p>&#13; When <tt class="APPLICATION">SCons</tt> builds a target
file, it does not execute the commands with the same external
environment that you used to execute <tt class=
"APPLICATION">SCons</tt>. Instead, it uses the dictionary stored in
the <a href="#CV-ENV"><tt class="ENVAR">$ENV</tt></a> construction
variable as the external environment for executing commands.</p>

<p>&#13; The most important ramification of this behavior is that
the <tt class="VARNAME">PATH</tt> environment variable, which
controls where the operating system will look for commands and
utilities, is not the same as in the external environment from
which you called <tt class="APPLICATION">SCons</tt>. This means
that <tt class="APPLICATION">SCons</tt> will not, by default,
necessarily find all of the tools that you can execute from the
command line.</p>

<p>&#13; The default value of the <tt class="VARNAME">PATH</tt>
environment variable on a POSIX system is <tt class=
"LITERAL">/usr/local/bin:/bin:/usr/bin</tt>. The default value of
the <tt class="VARNAME">PATH</tt> environment variable on a Win32
system comes from the Windows registry value for the command
interpreter. If you want to execute any commands--compilers,
linkers, etc.--that are not in these default locations, you need to
set the <tt class="VARNAME">PATH</tt> value in the <tt class=
"ENVAR">$ENV</tt> dictionary in your construction environment.</p>

<p>&#13; The simplest way to do this is to initialize explicitly
the value when you create the construction environment; this is one
way to do that:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    path = ['/usr/local/bin', '/bin', '/usr/bin']
    env = Environment(ENV = {'PATH' : path})
 
</pre>
</td>
</tr>
</table>

<p>&#13; Assign a dictionary to the <tt class="ENVAR">$ENV</tt>
construction variable in this way completely resets the external
environment so that the only variable that will be set when
external commands are executed will be the <tt class=
"VARNAME">PATH</tt> value. If you want to use the rest of the
values in <tt class="ENVAR">$ENV</tt> and only set the value of <tt
class="VARNAME">PATH</tt>, the most straightforward way is
probably:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env['ENV']['PATH'] = ['/usr/local/bin', '/bin', '/usr/bin']
 
</pre>
</td>
</tr>
</table>

<p>&#13; Note that <tt class="APPLICATION">SCons</tt> does allow
you to define the directories in the <tt class="VARNAME">PATH</tt>
in a string, separated by the pathname-separator character for your
system (':' on POSIX systems, ';' on Windows):</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env['ENV']['PATH'] = '/usr/local/bin:/bin:/usr/bin'
 
</pre>
</td>
</tr>
</table>

<p>&#13; But doing so makes your <tt class=
"FILENAME">SConscript</tt> file less portable, (although in this
case that may not be a huge concern since the directories you list
are likley system-specific, anyway).</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1252"></a>Propagating <tt class=
"VARNAME">PATH</tt> From the External Environment</h1>

<p>&#13; You may want to propagate the external <tt class=
"VARNAME">PATH</tt> to the execution environment for commands. You
do this by initializing the <tt class="VARNAME">PATH</tt> variable
with the <tt class="VARNAME">PATH</tt> value from the <tt class=
"LITERAL">os.environ</tt> dictionary, which is Python's way of
letting you get at the external environment:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      import os
      env = Environment(ENV = {'PATH' : os.environ['PATH']})
   
</pre>
</td>
</tr>
</table>

<p>&#13; Alternatively, you may find it easier to just propagate
the entire external environment to the execution environment for
commands. This is simpler to code than explicity selecting the <tt
class="VARNAME">PATH</tt> value:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      import os
      env = Environment(ENV = os.environ)
   
</pre>
</td>
</tr>
</table>

<p>&#13; Either of these will guarantee that <tt class=
"APPLICATION">SCons</tt> will be able to execute any command that
you can execute from the command line. The drawback is that the
build can behave differently if it's run by people with different
<tt class="VARNAME">PATH</tt> values in their environment--for
example, both the <tt class="LITERAL">/bin</tt> and <tt class=
"LITERAL">/usr/local/bin</tt> directories have different <tt class=
"APPLICATION">cc</tt> commands, then which one will be used to
compile programs will depend on which directory is listed first in
the user's <tt class="VARNAME">PATH</tt> variable.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-COMMAND-LINE"></a>Controlling a Build From the
Command Line</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> provides a number of
ways that allow the writer of the <tt class=
"FILENAME">SConscript</tt> files to give users a great deal of
control over how to run the builds.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1276"></a>Not Having to Specify
Command-Line Options Each Time: the <tt class=
"VARNAME">SCONSFLAGS</tt> Environment Variable</h1>

<p>&#13; Users may find themselves supplying the same command-line
options every time they run <tt class="APPLICATION">SCons</tt>. For
example, a user might find that it saves time to specify a value of
<tt class="LITERAL">-j 2</tt> to run the builds in parallel. To
avoid having to type <tt class="LITERAL">-j 2</tt> by hand every
time, you can set the external environment variable <tt class=
"VARNAME">SCONSFLAGS</tt> to a string containing command-line
options that you want <tt class="APPLICATION">SCons</tt> to
use.</p>

<p>&#13; If, for example, and you're using a POSIX shell that's
compatible with the Bourne shell, and you always want <tt class=
"APPLICATION">SCons</tt> to use the <tt class="LITERAL">-Q</tt>
option, you can set the <tt class="VARNAME">SCONSFLAGS</tt>
environment as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      scons: Building targets ...
          ... [build output] ...
      scons: done building targets.
      % <tt class="USERINPUT"><b>export SCONSFLAGS="-Q"</b></tt>
      % <tt class="USERINPUT"><b>scons</b></tt>
          ... [build output] ...
   
</pre>
</td>
</tr>
</table>

<p>&#13; Users of <tt class="APPLICATION">csh</tt>-style shells on
POSIX systems can set the <tt class="VARNAME">SCONSFLAGS</tt>
environment as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      $ <tt class="USERINPUT"><b>setenv SCONSFLAGS "-Q"</b></tt>
   
</pre>
</td>
</tr>
</table>

<p>&#13; Windows users may typically want to set this <tt class=
"VARNAME">SCONSFLAGS</tt> in the appropriate tab of the <tt class=
"LITERAL">System Properties</tt> window.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1301"></a>Getting at Command-Line
Targets</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> supports a <tt class=
"VARNAME">COMMAND_LINE_TARGETS</tt> variable that lets you get at
the list of targets that the user specified on the command line.
You can use the targets to manipulate the build in any way you
wish. As a simple example, suppose that you want to print a
reminder to the user whenever a specific program is built. You can
do this by checking for the target in the <tt class=
"VARNAME">COMMAND_LINE_TARGETS</tt> list:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      if 'bar' in COMMAND_LINE_TARGETS:
          print "Don't forget to copy `bar' to the archive!"
      Default(Program('foo.c'))
      Program('bar.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Then, running <tt class="APPLICATION">SCons</tt> with the
default target works as it always does, but explicity specifying
the <tt class="APPLICATION">bar</tt> target on the command line
generates the warning message:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o foo.o foo.c
      cc -o foo foo.o
      % <tt class="USERINPUT"><b>scons -Q bar</b></tt>
      Don't forget to copy `bar' to the archive!
      cc -c -o bar.o bar.c
      cc -o bar bar.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Another practical use for the <tt class=
"VARNAME">COMMAND_LINE_TARGETS</tt> variable might be to speed up a
build by only reading certain subsidiary <tt class=
"FILENAME">SConscript</tt> files if a specific target is
requested.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1317"></a>Controlling the Default
Targets</h1>

<p>&#13; One of the most basic things you can control is which
targets <tt class="APPLICATION">SCons</tt> will build by
default--that is, when there are no targets specified on the
command line. As mentioned previously, <tt class=
"APPLICATION">SCons</tt> will normally build every target in or
below the current directory by default--that is, when you don't
explicitly specify one or more targets on the command line.
Sometimes, however, you may want to specify explicitly that only
certain programs, or programs in certain directories, should be
built by default. You do this with the <tt class=
"FUNCTION">Default</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       hello = env.Program('hello.c')
       env.Program('goodbye.c')
       Default(hello)
   
</pre>
</td>
</tr>
</table>

<p>&#13; This <tt class="FILENAME">SConstruct</tt> file knows how
to build two programs, <tt class="APPLICATION">hello</tt> and <tt
class="APPLICATION">goodbye</tt>, but only builds the <tt class=
"APPLICATION">hello</tt> program by default:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o hello.o hello.c
       cc -o hello hello.o
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       scons: `hello' is up to date.
       % <tt class="USERINPUT"><b>scons -Q goodbye</b></tt>
       cc -c -o goodbye.o goodbye.c
       cc -o goodbye goodbye.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Note that, even when you use the <tt class=
"FUNCTION">Default</tt> function in your <tt class=
"FILENAME">SConstruct</tt> file, you can still explicitly specify
the current directory (<tt class="LITERAL">.</tt>) on the command
line to tell <tt class="APPLICATION">SCons</tt> to build everything
in (or below) the current directory:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q .</b></tt>
       cc -c -o goodbye.o goodbye.c
       cc -o goodbye goodbye.o
       cc -c -o hello.o hello.c
       cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; You can also call the <tt class="FUNCTION">Default</tt>
function more than once, in which case each call adds to the list
of targets to be built by default:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       prog1 = env.Program('prog1.c')
       Default(prog1)
       prog2 = env.Program('prog2.c')
       prog3 = env.Program('prog3.c')
       Default(prog3)
   
</pre>
</td>
</tr>
</table>

<p>&#13; Or you can specify more than one target in a single call
to the <tt class="FUNCTION">Default</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       prog1 = env.Program('prog1.c')
       prog2 = env.Program('prog2.c')
       prog3 = env.Program('prog3.c')
       Default(prog1, prog3)
   
</pre>
</td>
</tr>
</table>

<p>&#13; Either of these last two examples will build only the <tt
class="APPLICATION">prog1</tt> and <tt class=
"APPLICATION">prog3</tt> programs by default:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o prog1.o prog1.c
       cc -o prog1 prog1.o
       cc -c -o prog3.o prog3.c
       cc -o prog3 prog3.o
       % <tt class="USERINPUT"><b>scons -Q .</b></tt>
       cc -c -o prog2.o prog2.c
       cc -o prog2 prog2.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; You can list a directory as an argument to <tt class=
"FUNCTION">Default</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       env.Program(['prog1/main.c', 'prog1/foo.c'])
       env.Program(['prog2/main.c', 'prog2/bar.c'])
       Default('prog1')
   
</pre>
</td>
</tr>
</table>

<p>&#13; In which case only the target(s) in that directory will be
built by default:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o prog1/foo.o prog1/foo.c
       cc -c -o prog1/main.o prog1/main.c
       cc -o prog1/main prog1/main.o prog1/foo.o
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       scons: `prog1' is up to date.
       % <tt class="USERINPUT"><b>scons -Q .</b></tt>
       cc -c -o prog2/bar.o prog2/bar.c
       cc -c -o prog2/main.o prog2/main.c
       cc -o prog2/main prog2/main.o prog2/bar.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Lastly, if for some reason you don't want any targets
built by default, you can use the Python <tt class=
"LITERAL">None</tt> variable:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       prog1 = env.Program('prog1.c')
       prog2 = env.Program('prog2.c')
       Default(None)
   
</pre>
</td>
</tr>
</table>

<p>&#13; Which would produce build output like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       scons: *** No targets specified and no Default() targets found.  Stop.
       % <tt class="USERINPUT"><b>scons -Q .</b></tt>
       cc -c -o prog1.o prog1.c
       cc -o prog1 prog1.o
       cc -c -o prog2.o prog2.c
       cc -o prog2 prog2.o
   
</pre>
</td>
</tr>
</table>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1367"></a>Getting at the List of
Default Targets</h2>

<p>&#13; <tt class="APPLICATION">SCons</tt> supports a <tt class=
"VARNAME">DEFAULT_TARGETS</tt> variable that lets you get at the
current list of default targets. The <tt class=
"VARNAME">DEFAULT_TARGETS</tt> variable has two important
differences from the <tt class="VARNAME">COMMAND_LINE_TARGETS</tt>
variable. First, the <tt class="VARNAME">DEFAULT_TARGETS</tt>
variable is a list of internal <tt class="APPLICATION">SCons</tt>
nodes, so you need to convert the list elements to strings if you
want to print them or look for a specific target name. Fortunately,
you can do this easily by using the Python <tt class=
"FUNCTION">map</tt> function to run the list through <tt class=
"FUNCTION">str</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
         prog1 = Program('prog1.c')
         Default(prog1)
         print "DEFAULT_TARGETS is", map(str, DEFAULT_TARGETS)
     
</pre>
</td>
</tr>
</table>

<p>&#13; (Keep in mind that all of the manipulation of the <tt
class="VARNAME">DEFAULT_TARGETS</tt> list takes place during the
first phase when <tt class="APPLICATION">SCons</tt> is reading up
the <tt class="FILENAME">SConscript</tt> files, which is obvious if
we leave off the <tt class="LITERAL">-Q</tt> flag when we run <tt
class="APPLICATION">SCons</tt>:)</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class="USERINPUT"><b>scons</b></tt>
         scons: Reading SConscript files ...
         DEFAULT_TARGETS is ['prog1']
         scons: done reading SConscript files.
         scons: Building targets ...
         cc -c -o prog1.o prog1.c
         cc -o prog1 prog1.o
         scons: done building targets.
     
</pre>
</td>
</tr>
</table>

<p>&#13; Second, the contents of the <tt class=
"VARNAME">DEFAULT_TARGETS</tt> list change in response to calls to
the <tt class="FUNCTION">Default</tt>: function, as you can see
from the following <tt class="FILENAME">SConstruct</tt> file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
         prog1 = Program('prog1.c')
         Default(prog1)
         print "DEFAULT_TARGETS is now", map(str, DEFAULT_TARGETS)
         prog2 = Program('prog2.c')
         Default(prog2)
         print "DEFAULT_TARGETS is now", map(str, DEFAULT_TARGETS)
     
</pre>
</td>
</tr>
</table>

<p>&#13; Which yields the output:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
         % <tt class="USERINPUT"><b>scons</b></tt>
         scons: Reading SConscript files ...
         DEFAULT_TARGETS is now ['prog1']
         DEFAULT_TARGETS is now ['prog1', 'prog2']
         scons: done reading SConscript files.
         scons: Building targets ...
         cc -c -o prog1.o prog1.c
         cc -o prog1 prog1.o
         cc -c -o prog2.o prog2.c
         cc -o prog2 prog2.o
         scons: done building targets.
     
</pre>
</td>
</tr>
</table>

<p>&#13; In practice, this simply means that you need to pay
attention to the order in which you call the <tt class=
"FUNCTION">Default</tt> function and refer to the <tt class=
"VARNAME">DEFAULT_TARGETS</tt> list, to make sure that you don't
examine the list before you've added the default targets you expect
to find in it.</p>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1398"></a>Getting at the List of
Build Targets, Regardless of Origin</h1>

<p>&#13; We've already been introduced to the <tt class=
"VARNAME">COMMAND_LINE_TARGETS</tt> variable, which contains a list
of targets specified on the command line, and the <tt class=
"VARNAME">DEFAULT_TARGETS</tt> variable, which contains a list of
targets specified via calls to the <tt class=
"FUNCTION">Default</tt> method or function. Sometimes, however, you
want a list of whatever targets <tt class="APPLICATION">SCons</tt>
will try to build, regardless of whether the targets came from the
command line or a <tt class="FUNCTION">Default</tt> call. You could
code this up by hand, as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      if COMMAND_LINE_TARGETS:
          targets = COMMAND_LINE_TARGETS
      else:
          targets = DEFAULT_TARGETS
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt>, however, provides a
convenient <tt class="VARNAME">BUILD_TARGETS</tt> variable that
eliminates the need for this by-hand manipulation. Essentially, the
<tt class="VARNAME">BUILD_TARGETS</tt> variable contains a list of
the command-line targets, if any were specified, and if no
command-line targets were specified, it contains a list of the
targets specified via the <tt class="FUNCTION">Default</tt> method
or function.</p>

<p>&#13; Because <tt class="VARNAME">BUILD_TARGETS</tt> may contain
a list of <tt class="APPLICATION">SCons</tt> nodes, you must
convert the list elements to strings if you want to print them or
look for a specific target name, just like the <tt class=
"VARNAME">DEFAULT_TARGETS</tt> list:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      prog1 = Program('prog1.c')
      Program('prog2.c')
      Default(prog1)
      print "BUILD_TARGETS is", map(str, BUILD_TARGETS)
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice how the value of <tt class=
"VARNAME">BUILD_TARGETS</tt> changes depending on whether a target
is specified on the command line:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      BUILD_TARGETS is ['prog1']
      cc -c -o prog1.o prog1.c
      cc -o prog1 prog1.o
      % <tt class="USERINPUT"><b>scons -Q prog2</b></tt>
      BUILD_TARGETS is ['prog2']
      cc -c -o prog2.o prog2.c
      cc -o prog2 prog2.o
      % <tt class="USERINPUT"><b>scons -Q -c .</b></tt>
      BUILD_TARGETS is ['.']
      Removed prog1.o
      Removed prog1
      Removed prog2.o
      Removed prog2
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1423"></a>Command-Line <tt class=
"VARNAME">variable</tt>=<tt class="VARNAME">value</tt> Build
Options</h1>

<p>&#13; You may want to control various aspects of your build by
allowing the user to specify <tt class="VARNAME">variable</tt>=<tt
class="VARNAME">value</tt> values on the command line. For example,
suppose you want users to be able to build a debug version of a
program by running <tt class="APPLICATION">SCons</tt> as
follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q debug=1</b></tt>
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> provides an <tt class=
"VARNAME">ARGUMENTS</tt> dictionary that stores all of the <tt
class="VARNAME">variable</tt>=<tt class="VARNAME">value</tt>
assignments from the command line. This allows you to modify
aspects of your build in response to specifications on the command
line. (Note that unless you want to require that users <i class=
"EMPHASIS">always</i> specify an option, you probably want to use
the Python <tt class="LITERAL">ARGUMENTS.get()</tt> function, which
allows you to specify a default value to be used if there is no
specification on the command line.)</p>

<p>&#13; The following code sets the <a href="#CV-CCFLAGS"><tt
class="ENVAR">$CCFLAGS</tt></a> construction variable in response
to the <tt class="VARNAME">debug</tt> flag being set in the <tt
class="VARNAME">ARGUMENTS</tt> dictionary:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       debug = ARGUMENTS.get('debug', 0)
       if int(debug):
           env.Append(CCFLAGS = '-g')
       env.Program('prog.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; This results in the <tt class="VARNAME">-g</tt> compiler
option being used when <tt class="LITERAL">debug=1</tt> is used on
the command line:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q debug=0</b></tt>
       cc -c -o prog.o prog.c
       cc -o prog prog.o
       % <tt class="USERINPUT"><b>scons -Q debug=0</b></tt>
       scons: `.' is up to date.
       % <tt class="USERINPUT"><b>scons -Q debug=1</b></tt>
       cc -g -c -o prog.o prog.c
       cc -o prog prog.o
       % <tt class="USERINPUT"><b>scons -Q debug=1</b></tt>
       scons: `.' is up to date.
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that <tt class="APPLICATION">SCons</tt> keeps track
of the last values used to build the object files, and as a result
correctly rebuilds the object and executable files only when the
value of the <tt class="LITERAL">debug</tt> argument has
changed.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1457"></a>Controlling Command-Line
Build Options</h1>

<p>&#13; Being able to use a command-line build option like <tt
class="LITERAL">debug=1</tt> is handy, but it can be a chore to
write specific Python code to recognize each such option and apply
the values to a construction variable. To help with this, <tt
class="APPLICATION">SCons</tt> supports a class to define such
build options easily, and a mechanism to apply the build options to
a construction environment. This allows you to control how the
build options affect construction environments.</p>

<p>&#13; For example, suppose that you want users to set a <tt
class="VARNAME">RELEASE</tt> construction variable on the command
line whenever the time comes to build a program for release, and
that the value of this variable should be added to the command line
with the appropriate <tt class="LITERAL">-D</tt> option (or other
command line option) to pass the value to the C compiler. Here's
how you might do that by setting the appropriate value in a
dictionary for the <a href="#CV-CPPDEFINES"><tt class=
"ENVAR">$CPPDEFINES</tt></a> construction variable:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
         opts = Options()
         opts.Add('RELEASE', 'Set to 1 to build for release', 0)
         env = Environment(options = opts,
                           CPPDEFINES={'RELEASE_BUILD' : '${RELEASE}'})
         env.Program(['foo.c', 'bar.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; This <tt class="FILENAME">SConstruct</tt> file first
creates an <tt class="FUNCTION">Options</tt> object (the <tt class=
"LITERAL">opts = Options()</tt> call), and then uses the object's
<tt class="FUNCTION">Add</tt> method to indicate that the <tt
class="VARNAME">RELEASE</tt> option can be set on the command line,
and that it's default value will be <tt class="LITERAL">0</tt> (the
third argument to the <tt class="FUNCTION">Add</tt> method). The
second argument is a line of help text; we'll learn how to use it
in the next section.</p>

<p>&#13; We then pass the created <tt class="FUNCTION">Options</tt>
object as an <tt class="VARNAME">options</tt> keyword argument to
the <tt class="FUNCTION">Environment</tt> call used to create the
construction environment. This then allows a user to set the <tt
class="VARNAME">RELEASE</tt> build option on the command line and
have the variable show up in the command line used to build each
object from a C source file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q RELEASE=1</b></tt>
      cc -DRELEASE_BUILD=1 -c -o bar.o bar.c
      cc -DRELEASE_BUILD=1 -c -o foo.o foo.c
      cc -o foo foo.o bar.o
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1483"></a>Providing Help for
Command-Line Build Options</h1>

<p>&#13; To make command-line build options most useful, you
ideally want to provide some help text that will describe the
available options when the user runs <tt class="LITERAL">scons
-h</tt>. You could write this text by hand, but <tt class=
"APPLICATION">SCons</tt> provides an easier way. <tt class=
"FUNCTION">Options</tt> objects support a <tt class=
"FUNCTION">GenerateHelpText</tt> method that will, as its name
indicates, generate text that describes the various options that
have been added to it. You then pass the output from this method to
the <tt class="FUNCTION">Help</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
         opts = Options('custom.py')
         opts.Add('RELEASE', 'Set to 1 to build for release', 0)
         env = Environment(options = opts)
         Help(opts.GenerateHelpText(env))
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> will now display some
useful text when the <tt class="LITERAL">-h</tt> option is
used:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q -h</b></tt>
      
      RELEASE: Set to 1 to build for release
          default: 0
          actual: 0
      
      Use scons -H for help about command-line options.
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that the help output shows the default value, and
the current actual value of the build option.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1498"></a>Reading Build Options
From a File</h1>

<p>&#13; Being able to use a command-line build option like <tt
class="LITERAL">debug=1</tt> is handy, but it can be a chore to
write specific Python code to recognize each such option and apply
the values to a construction variable. To help with this, <tt
class="APPLICATION">SCons</tt> supports a class to define such
build options easily and to read build option values from a file.
This allows you to control how the build options affect
construction environments. The way you do this is by specifying a
file name when you call <tt class="FUNCTION">Options</tt>, like <tt
class="FILENAME">custom.py</tt> in the following example:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
         opts = Options('custom.py')
         opts.Add('RELEASE', 'Set to 1 to build for release', 0)
         env = Environment(options = opts,
                           CPPDEFINES={'RELEASE_BUILD' : '${RELEASE}'})
         env.Program(['foo.c', 'bar.c'])
         Help(opts.GenerateHelpText(env))
   
</pre>
</td>
</tr>
</table>

<p>&#13; This then allows us to control the <tt class=
"VARNAME">RELEASE</tt> variable by setting it in the <tt class=
"FILENAME">custom.py</tt> file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      RELEASE = 1
     
</pre>
</td>
</tr>
</table>

<p>&#13; Note that this file is actually executed like a Python
script. Now when we run <tt class="APPLICATION">SCons</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -DRELEASE_BUILD=1 -c -o bar.o bar.c
      cc -DRELEASE_BUILD=1 -c -o foo.o foo.c
      cc -o foo foo.o bar.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; And if we change the contents of <tt class=
"FILENAME">custom.py</tt> to:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      RELEASE = 0
   
</pre>
</td>
</tr>
</table>

<p>&#13; The object files are rebuilt appropriately with the new
option:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -DRELEASE_BUILD=0 -c -o bar.o bar.c
      cc -DRELEASE_BUILD=0 -c -o foo.o foo.c
      cc -o foo foo.o bar.o
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1520"></a>Canned Build Options</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> provides a number of
functions that provide ready-made behaviors for various types of
command-line build options.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1524"></a>True/False Values: the
<tt class="FUNCTION">BoolOption</tt> Build Option</h2>

<p>&#13; It's often handy to be able to specify an option that
controls a simple Boolean variable with a <tt class=
"LITERAL">true</tt> or <tt class="LITERAL">false</tt> value. It
would be even more handy to accomodate users who have different
preferences for how to represent <tt class="LITERAL">true</tt> or
<tt class="LITERAL">false</tt> values. The <tt class=
"FUNCTION">BoolOption</tt> function makes it easy to accomodate a
variety of common values that represent <tt class=
"LITERAL">true</tt> or <tt class="LITERAL">false</tt>.</p>

<p>&#13; The <tt class="FUNCTION">BoolOption</tt> function takes
three arguments: the name of the build option, the default value of
the build option, and the help string for the option. It then
returns appropriate information for passing to the <tt class=
"FUNCTION">Add</tt> method of an <tt class="FUNCTION">Options</tt>
object, like so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(BoolOption('RELEASE', 'Set to build for release', 0))
           env = Environment(options = opts,
                             CPPDEFINES={'RELEASE_BUILD' : '${RELEASE}'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; With this build option, the <tt class=
"VARNAME">RELEASE</tt> variable can now be enabled by setting it to
the value <tt class="LITERAL">yes</tt> or <tt class=
"LITERAL">t</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q RELEASE=yes foo.o</b></tt>
        cc -DRELEASE_BUILD=1 -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q RELEASE=t foo.o</b></tt>
        cc -DRELEASE_BUILD=1 -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<p>&#13; Other values that equate to <tt class="LITERAL">true</tt>
include <tt class="LITERAL">y</tt>, <tt class="LITERAL">1</tt>, <tt
class="LITERAL">on</tt> and <tt class="LITERAL">all</tt>.</p>

<p>&#13; Conversely, <tt class="VARNAME">RELEASE</tt> may now be
given a <tt class="LITERAL">false</tt> value by setting it to <tt
class="LITERAL">no</tt> or <tt class="LITERAL">f</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q RELEASE=no foo.o</b></tt>
        cc -DRELEASE_BUILD=0 -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q RELEASE=f foo.o</b></tt>
        cc -DRELEASE_BUILD=0 -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<p>&#13; Other values that equate to <tt class="LITERAL">true</tt>
include <tt class="LITERAL">n</tt>, <tt class="LITERAL">0</tt>, <tt
class="LITERAL">off</tt> and <tt class="LITERAL">none</tt>.</p>

<p>&#13; Lastly, if a user tries to specify any other value, <tt
class="APPLICATION">SCons</tt> supplies an appropriate error
message:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q RELEASE=bad_value foo.o</b></tt>
        
        scons: *** Error converting option: RELEASE
        Invalid value for boolean option: bad_value
        File "SConstruct", line 4, in ?
     
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1573"></a>Single Value From a List:
the <tt class="FUNCTION">EnumOption</tt> Build Option</h2>

<p>&#13; Suppose that we want a user to be able to set a <tt class=
"VARNAME">COLOR</tt> option that selects a background color to be
displayed by an application, but that we want to restrict the
choices to a specific set of allowed colors. This can be set up
quite easily using the <tt class="FUNCTION">EnumOption</tt>, which
takes a list of <tt class="VARNAME">allowed_values</tt> in addition
to the variable name, default value, and help text arguments:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(EnumOption('COLOR', 'Set background color', 'red',
                               allowed_values=('red', 'green', 'blue')))
           env = Environment(options = opts,
                             CPPDEFINES={'COLOR' : '"${COLOR}"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; The user can now explicity set the <tt class=
"VARNAME">COLOR</tt> build option to any of the specified allowed
values:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=red foo.o</b></tt>
        cc -DCOLOR="red" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=blue foo.o</b></tt>
        cc -DCOLOR="blue" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=green foo.o</b></tt>
        cc -DCOLOR="green" -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<p>&#13; But, almost more importantly, an attempt to set <tt class=
"VARNAME">COLOR</tt> to a value that's not in the list generates an
error message:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=magenta foo.o</b></tt>
        
        scons: *** Invalid value for option COLOR: magenta
        File "SConstruct", line 5, in ?
     
</pre>
</td>
</tr>
</table>

<p>&#13; The <tt class="FUNCTION">EnumOption</tt> function also
supports a way to map alternate names to allowed values. Suppose,
for example, that we want to allow the user to use the word <tt
class="LITERAL">navy</tt> as a synonym for <tt class=
"LITERAL">blue</tt>. We do this by adding a <tt class=
"VARNAME">map</tt> dictionary that will map its key values to the
desired legal value:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(EnumOption('COLOR', 'Set background color', 'red',
                               allowed_values=('red', 'green', 'blue'),
                               map={'navy':'blue'}))
           env = Environment(options = opts,
                             CPPDEFINES={'COLOR' : '"${COLOR}"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; As desired, the user can then use <tt class=
"LITERAL">navy</tt> on the command line, and <tt class=
"APPLICATION">SCons</tt> will translate it into <tt class=
"LITERAL">blue</tt> when it comes time to use the <tt class=
"VARNAME">COLOR</tt> option to build a target:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=navy foo.o</b></tt>
        cc -DCOLOR="blue" -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<p>&#13; By default, when using the <tt class=
"FUNCTION">EnumOption</tt> function, arguments that differ from the
legal values only in case are treated as illegal values:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=Red foo.o</b></tt>
        
        scons: *** Invalid value for option COLOR: Red
        File "SConstruct", line 5, in ?
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=BLUE foo.o</b></tt>
        
        scons: *** Invalid value for option COLOR: BLUE
        File "SConstruct", line 5, in ?
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=nAvY foo.o</b></tt>
        
        scons: *** Invalid value for option COLOR: nAvY
        File "SConstruct", line 5, in ?
     
</pre>
</td>
</tr>
</table>

<p>&#13; The <tt class="FUNCTION">EnumOption</tt> function can take
an additional <tt class="VARNAME">ignorecase</tt> keyword argument
that, when set to <tt class="LITERAL">1</tt>, tells <tt class=
"APPLICATION">SCons</tt> to allow case differences when the values
are specified:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(EnumOption('COLOR', 'Set background color', 'red',
                               allowed_values=('red', 'green', 'blue'),
                               map={'navy':'blue'},
                               ignorecase=1))
           env = Environment(options = opts,
                             CPPDEFINES={'COLOR' : '"${COLOR}"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; Which yields the output:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=Red foo.o</b></tt>
        cc -DCOLOR="Red" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=BLUE foo.o</b></tt>
        cc -DCOLOR="BLUE" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=nAvY foo.o</b></tt>
        cc -DCOLOR="blue" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=green foo.o</b></tt>
        cc -DCOLOR="green" -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that an <tt class="VARNAME">ignorecase</tt> value
of <tt class="LITERAL">1</tt> preserves the case-spelling that the
user supplied. If you want <tt class="APPLICATION">SCons</tt> to
translate the names into lower-case, regardless of the case used by
the user, specify an <tt class="VARNAME">ignorecase</tt> value of
<tt class="LITERAL">2</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(EnumOption('COLOR', 'Set background color', 'red',
                               allowed_values=('red', 'green', 'blue'),
                               map={'navy':'blue'},
                               ignorecase=2))
           env = Environment(options = opts,
                             CPPDEFINES={'COLOR' : '"${COLOR}"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; Now <tt class="APPLICATION">SCons</tt> will use values of
<tt class="LITERAL">red</tt>, <tt class="LITERAL">green</tt> or <tt
class="LITERAL">blue</tt> regardless of how the user spells those
values on the command line:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=Red foo.o</b></tt>
        cc -DCOLOR="red" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=nAvY foo.o</b></tt>
        cc -DCOLOR="blue" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLOR=GREEN foo.o</b></tt>
        cc -DCOLOR="green" -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1638"></a>Multiple Values From a
List: the <tt class="FUNCTION">ListOption</tt> Build Option</h2>

<p>&#13; Another way in which you might want to allow users to
control build option is to specify a list of one or more legal
values. <tt class="APPLICATION">SCons</tt> supports this through
the <tt class="FUNCTION">ListOption</tt> function. If, for example,
we want a user to be able to set a <tt class="VARNAME">COLORS</tt>
option to one or more of the legal list of values:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(ListOption('COLORS', 'List of colors', 0,
                               ['red', 'green', 'blue']))
           env = Environment(options = opts,
                             CPPDEFINES={'COLORS' : '"${COLORS}"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; A user can now specify a comma-separated list of legal
values, which will get translated into a space-separated list for
passing to the any build commands:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLORS=red,blue foo.o</b></tt>
        cc -DCOLORS="red blue" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLORS=blue,green,red foo.o</b></tt>
        cc -DCOLORS="blue green red" -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<p>&#13; In addition, the <tt class="FUNCTION">ListOption</tt>
function allows the user to specify explicit keywords of <tt class=
"LITERAL">all</tt> or <tt class="LITERAL">none</tt> to select all
of the legal values, or none of them, respectively:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLORS=all foo.o</b></tt>
        cc -DCOLORS="red green blue" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q COLORS=none foo.o</b></tt>
        cc -DCOLORS="" -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>

<p>&#13; And, of course, an illegal value still generates an error
message:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q COLORS=magenta foo.o</b></tt>
        
        scons: *** Error converting option: COLORS
        Invalid value(s) for option: magenta
        File "SConstruct", line 5, in ?
     
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1660"></a>Path Names: the <tt
class="FUNCTION">PathOption</tt> Build Option</h2>

<p>&#13; <tt class="APPLICATION">SCons</tt> supports a <tt class=
"FUNCTION">PathOption</tt> function to make it easy to create a
build option to control an expected path name. If, for example, you
need to define a variable in the preprocessor that control the
location of a configuration file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(PathOption('CONFIG',
                               'Path to configuration file',
                               '/etc/my_config'))
           env = Environment(options = opts,
                             CPPDEFINES={'CONFIG_FILE' : '"$CONFIG"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; This then allows the user to override the <tt class=
"VARNAME">CONFIG</tt> build option on the command line as
necessary:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q foo.o</b></tt>
        cc -DCONFIG_FILE="/etc/my_config" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q CONFIG=/usr/local/etc/other_config foo.o</b></tt>
        scons: `foo.o' is up to date.
     
</pre>
</td>
</tr>
</table>

<p>&#13; By default, <tt class="FUNCTION">PathOption</tt> checks to
make sure that the specified path exists and generates an error if
it doesn't:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class=
"USERINPUT"><b>scons -Q CONFIG=/does/not/exist foo.o</b></tt>
        
        scons: *** Path for option CONFIG does not exist: /does/not/exist
        File "SConstruct", line 6, in ?
     
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="FUNCTION">PathOption</tt> provides a number of
methods that you can use to change this behavior. If you want to
ensure that any specified paths are, in fact, files and not
directories, use the <tt class=
"FUNCTION">PathOption.PathIsFile</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(PathOption('CONFIG',
                               'Path to configuration file',
                               '/etc/my_config',
                               PathOption.PathIsFile))
           env = Environment(options = opts,
                             CPPDEFINES={'CONFIG_FILE' : '"$CONFIG"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; Conversely, to ensure that any specified paths are
directories and not files, use the <tt class=
"FUNCTION">PathOption.PathIsDir</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(PathOption('DBDIR',
                               'Path to database directory',
                               '/var/my_dbdir',
                               PathOption.PathIsDir))
           env = Environment(options = opts,
                             CPPDEFINES={'DBDIR' : '"$DBDIR"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; If you want to make sure that any specified paths are
directories, and you would like the directory created if it doesn't
already exist, use the <tt class=
"FUNCTION">PathOption.PathIsDirCreate</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(PathOption('DBDIR',
                               'Path to database directory',
                               '/var/my_dbdir',
                               PathOption.PathIsDirCreate))
           env = Environment(options = opts,
                             CPPDEFINES={'DBDIR' : '"$DBDIR"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; Lastly, if you don't care whether the path exists, is a
file, or a directory, use the <tt class=
"FUNCTION">PathOption.PathAccept</tt> method to accept any path
that the user supplies:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(PathOption('OUTPUT',
                               'Path to output file or directory',
                               None,
                               PathOption.PathAccept))
           env = Environment(options = opts,
                             CPPDEFINES={'OUTPUT' : '"$OUTPUT"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN1689"></a>Enabled/Disabled Path
Names: the <tt class="FUNCTION">PackageOption</tt> Build
Option</h2>

<p>&#13; Sometimes you want to give users even more control over a
path name variable, allowing them to explicitly enable or disable
the path name by using <tt class="LITERAL">yes</tt> or <tt class=
"LITERAL">no</tt> keywords, in addition to allow them to supply an
explicit path name. <tt class="APPLICATION">SCons</tt> supports the
<tt class="FUNCTION">PackageOption</tt> function to support
this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
           opts = Options('custom.py')
           opts.Add(PackageOption('PACKAGE',
                                  'Location package',
                                  '/opt/location'))
           env = Environment(options = opts,
                             CPPDEFINES={'PACKAGE' : '"$PACKAGE"'})
           env.Program('foo.c')
     
</pre>
</td>
</tr>
</table>

<p>&#13; When the <tt class="FILENAME">SConscript</tt> file uses
the <tt class="FUNCTION">PackageOption</tt> funciton, user can now
still use the default or supply an overriding path name, but can
now explicitly set the specified variable to a value that indicates
the package should be enabled (in which case the default should be
used) or disabled:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q foo.o</b></tt>
        cc -DPACKAGE="/opt/location" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q PACKAGE=/usr/local/location foo.o</b></tt>
        cc -DPACKAGE="/usr/local/location" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q PACKAGE=yes foo.o</b></tt>
        cc -DPACKAGE="1" -c -o foo.o foo.c
        % <tt class=
"USERINPUT"><b>scons -Q PACKAGE=no foo.o</b></tt>
        cc -DPACKAGE="0" -c -o foo.o foo.c
     
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1706"></a>Adding Multiple
Command-Line Build Options at Once</h1>

<p>&#13; Lastly, <tt class="APPLICATION">SCons</tt> provides a way
to add multiple build options to an <tt class=
"FUNCTION">Options</tt> object at once. Instead of having to call
the <tt class="FUNCTION">Add</tt> method multiple times, you can
call the <tt class="FUNCTION">AddOptions</tt> method with a list of
build options to be added to the object. Each build option is
specified as either a tuple of arguments, just like you'd pass to
the <tt class="FUNCTION">Add</tt> method itself, or as a call to
one of the canned functions for pre-packaged command-line build
options. in any order:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        opts = Options()
        opts.AddOptions(
            ('RELEASE', 'Set to 1 to build for release', 0),
            ('CONFIG', 'Configuration file', '/etc/my_config'),
            BoolOption('warnings', 'compilation with -Wall and similiar', 1),
            EnumOption('debug', 'debug output and symbols', 'no',
                       allowed_values=('yes', 'no', 'full'),
                       map={}, ignorecase=0),  # case sensitive
            ListOption('shared',
                       'libraries to build as shared libraries',
                       'all',
                       names = list_of_libs),
            PackageOption('x11',
                          'use X11 installed here (yes = search some places)',
                          'yes'),
            PathOption('qtdir', 'where the root of Qt is installed', qtdir),
        )
   
</pre>
</td>
</tr>
</table>

<p></p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-HELP"></a>Providing Build Help: the <tt class=
"FUNCTION">Help</tt> Function</h1>

<p>&#13; It's often very useful to be able to give users some help
that describes the specific targets, build options, etc., that can
be used for your build. <tt class="APPLICATION">SCons</tt> provides
the <tt class="FUNCTION">Help</tt> function to allow you to specify
this help text:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Help("""
      Type: 'scons program' to build the production program,
            'scons debug' to build the debug version.
      """)
  
</pre>
</td>
</tr>
</table>

<p>&#13; (Note the above use of the Python triple-quote syntax,
which comes in very handy for specifying multi-line strings like
help text.)</p>

<p>&#13; When the <tt class="FILENAME">SConstruct</tt> or <tt
class="FILENAME">SConscript</tt> files contain such a call to the
<tt class="FUNCTION">Help</tt> function, the specified help text
will be displayed in response to the <tt class=
"APPLICATION">SCons</tt> <tt class="LITERAL">-h</tt> option:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -h</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      
      Type: 'scons program' to build the production program,
            'scons debug' to build the debug version.
      
      Use scons -H for help about command-line options.
  
</pre>
</td>
</tr>
</table>

<p>&#13; The <tt class="FILENAME">SConscript</tt> files may contain
multiple calls to the <tt class="FUNCTION">Help</tt> function, in
which case the specified text(s) will be concatenated when
displayed. This allows you to split up the help text across
multiple <tt class="FILENAME">SConscript</tt> files. In this
situation, the order in which the <tt class=
"FILENAME">SConscript</tt> files are called will determine the
order in which the <tt class="FUNCTION">Help</tt> functions are
called, which will determine the order in which the various bits of
text will get concatenated.</p>

<p>&#13; Another use would be to make the help text conditional on
some variable. For example, suppose you only want to display a line
about building a Windows-only version of a program when actually
run on Windows. The following <tt class="FILENAME">SConstruct</tt>
file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      env = Environment()

      Help("\nType: 'scons program' to build the production program.\n")

      if env['PLATFORM'] == 'win32':
          Help("\nType: 'scons windebug' to build the Windows debug version.\n")
  
</pre>
</td>
</tr>
</table>

<p>&#13; Will display the completely help text on Windows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons -h</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      
      Type: 'scons program' to build the production program.
      
      Type: 'scons windebug' to build the Windows debug version.
      
      Use scons -H for help about command-line options.
  
</pre>
</td>
</tr>
</table>

<p>&#13; But only show the relevant option on a Linux or UNIX
system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -h</b></tt>
      scons: Reading SConscript files ...
      scons: done reading SConscript files.
      
      Type: 'scons program' to build the production program.
      
      Use scons -H for help about command-line options.
  
</pre>
</td>
</tr>
</table>

<p>&#13; If there is no <tt class="FUNCTION">Help</tt> text in the
<tt class="FILENAME">SConstruct</tt> or <tt class=
"FILENAME">SConscript</tt> files, <tt class=
"APPLICATION">SCons</tt> will revert to displaying its standard
list that describes the <tt class="APPLICATION">SCons</tt>
command-line options. This list is also always displayed whenever
the <tt class="LITERAL">-H</tt> option is used.</p>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-INSTALL"></a>Installing Files in Other
Directories: the <tt class="FUNCTION">Install</tt> Builder</h1>

<p>&#13; Once a program is built, it is often appropriate to
install it in another directory for public use. You use the <tt
class="FUNCTION">Install</tt> method to arrange for a program, or
any other file, to be copied into a destination directory:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment()
     hello = env.Program('hello.c')
     env.Install('/usr/bin', hello)
 
</pre>
</td>
</tr>
</table>

<p>&#13; Note, however, that installing a file is still considered
a type of file "build." This is important when you remember that
the default behavior of <tt class="APPLICATION">SCons</tt> is to
build files in or below the current directory. If, as in the
example above, you are installing files in a directory outside of
the top-level <tt class="FILENAME">SConstruct</tt> file's directory
tree, you must specify that directory (or a higher directory, such
as <tt class="LITERAL">/</tt>) for it to install anything
there:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
     % <tt class="USERINPUT"><b>scons -Q</b></tt>
     cc -c -o hello.o hello.c
     cc -o hello hello.o
     % <tt class="USERINPUT"><b>scons -Q /usr/bin</b></tt>
     Install file: "hello" as "/usr/bin/hello"
 
</pre>
</td>
</tr>
</table>

<p>&#13; It can, however, be cumbersome to remember (and type) the
specific destination directory in which the program (or any other
file) should be installed. This is an area where the <tt class=
"FUNCTION">Alias</tt> function comes in handy, allowing you, for
example, to create a pseudo-target named <tt class=
"LITERAL">install</tt> that can expand to the specified destination
directory:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment()
     hello = env.Program('hello.c')
     env.Install('/usr/bin', hello)
     env.Alias('install', '/usr/bin')
 
</pre>
</td>
</tr>
</table>

<p>&#13; This then yields the more natural ability to install the
program in its destination as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
     % <tt class="USERINPUT"><b>scons -Q</b></tt>
     cc -c -o hello.o hello.c
     cc -o hello hello.o
     % <tt class="USERINPUT"><b>scons -Q install</b></tt>
     Install file: "hello" as "/usr/bin/hello"
 
</pre>
</td>
</tr>
</table>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1775"></a>Installing Multiple Files
in a Directory</h1>

<p>&#13; You can install multiple files into a directory simply by
calling the <tt class="FUNCTION">Install</tt> function multiple
times:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       hello = env.Program('hello.c')
       goodbye = env.Program('goodbye.c')
       env.Install('/usr/bin', hello)
       env.Install('/usr/bin', goodbye)
       env.Alias('install', '/usr/bin')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Or, more succinctly, listing the multiple input files in a
list (just like you can do with any other builder):</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       hello = env.Program('hello.c')
       goodbye = env.Program('goodbye.c')
       env.Install('/usr/bin', [hello, goodbye])
       env.Alias('install', '/usr/bin')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Either of these two examples yields:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q install</b></tt>
       cc -c -o goodbye.o goodbye.c
       cc -o goodbye goodbye.o
       Install file: "goodbye" as "/usr/bin/goodbye"
       cc -c -o hello.o hello.c
       cc -o hello hello.o
       Install file: "hello" as "/usr/bin/hello"
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1785"></a>Installing a File Under a
Different Name</h1>

<p>&#13; The <tt class="FUNCTION">Install</tt> method preserves the
name of the file when it is copied into the destination directory.
If you need to change the name of the file when you copy it, use
the <tt class="FUNCTION">InstallAs</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       hello = env.Program('hello.c')
       env.InstallAs('/usr/bin/hello-new', hello)
       env.Alias('install', '/usr/bin')
   
</pre>
</td>
</tr>
</table>

<p>&#13; This installs the <tt class="LITERAL">hello</tt> program
with the name <tt class="LITERAL">hello-new</tt> as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q install</b></tt>
       cc -c -o hello.o hello.c
       cc -o hello hello.o
       Install file: "hello" as "/usr/bin/hello-new"
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1796"></a>Installing Multiple Files
Under Different Names</h1>

<p>&#13; Lastly, if you have multiple files that all need to be
installed with different file names, you can either call the <tt
class="FUNCTION">InstallAs</tt> function multiple times, or as a
shorthand, you can supply same-length lists for the both the target
and source arguments:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       hello = env.Program('hello.c')
       goodbye = env.Program('goodbye.c')
       env.InstallAs(['/usr/bin/hello-new',
                      '/usr/bin/goodbye-new'],
                     [hello, goodbye])
       env.Alias('install', '/usr/bin')
   
</pre>
</td>
</tr>
</table>

<p>&#13; In this case, the <tt class="FUNCTION">InstallAs</tt>
function loops through both lists simultaneously, and copies each
source file into its corresponding target file name:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q install</b></tt>
       cc -c -o goodbye.o goodbye.c
       cc -o goodbye goodbye.o
       Install file: "goodbye" as "/usr/bin/goodbye-new"
       cc -c -o hello.o hello.c
       cc -o hello hello.o
       Install file: "hello" as "/usr/bin/hello-new"
   
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-FACTORIES"></a>Platform-Independent File System
Manipulation</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> provides a number of
platform-independent functions, called <tt class=
"LITERAL">factories</tt>, that perform common file system
manipulations like copying, moving or deleting files and
directories, or making directories. These functions are <tt class=
"LITERAL">factories</tt> because they don't perform the action at
the time they're called, they each return an <tt class=
"CLASSNAME">Action</tt> object that can be executed at the
appropriate time.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1812"></a>Copying Files or
Directories: The <tt class="FUNCTION">Copy</tt> Factory</h1>

<p>&#13; Suppose you want to arrange to make a copy of a file, and
the <tt class="FUNCTION">Install</tt> builder isn't appropriate
because it may make a hard link on POSIX systems. One way would be
to use the <tt class="FUNCTION">Copy</tt> action factory in
conjunction with the <tt class="FUNCTION">Command</tt> builder:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Command("file.out", "file.in", Copy("$TARGET", "$SOURCE"))
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that the action returned by the <tt class=
"FUNCTION">Copy</tt> factory will expand the <tt class=
"ENVAR">$TARGET</tt> and <tt class="ENVAR">$SOURCE</tt> strings at
the time <tt class="FILENAME">file.out</tt> is built, and that the
order of the arguments is the same as that of a builder
itself--that is, target first, followed by source:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       Copy("file.out", "file.in")
   
</pre>
</td>
</tr>
</table>

<p>&#13; You can, of course, name a file explicitly instead of
using <tt class="ENVAR">$TARGET</tt> or <tt class=
"ENVAR">$SOURCE</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Command("file.out", [], Copy("$TARGET", "file.in"))
   
</pre>
</td>
</tr>
</table>

<p>&#13; Which executes as:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Copy("file.out", "file.in")
   
</pre>
</td>
</tr>
</table>

<p>&#13; The usefulness of the <tt class="FUNCTION">Copy</tt>
factory becomes more apparent when you use it in a list of actions
passed to the <tt class="FUNCTION">Command</tt> builder. For
example, suppose you needed to run a file through a utility that
only modifies files in-place, and can't "pipe" input to output. One
solution is to copy the source file to a temporary file name, run
the utility, and then copy the modified temporary file to the
target, which the <tt class="FUNCTION">Copy</tt> factory makes
extremely easy:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Command("file.out", "file.in",
              [
                Copy("tempfile", "$SOURCE"),
                "modify tempfile",
                Copy("$TARGET", "tempfile"),
              ])
   
</pre>
</td>
</tr>
</table>

<p>&#13; The output then looks like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Copy("tempfile", "file.in")
      modify tempfile
      Copy("file.out", "tempfile")
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1842"></a>Deleting Files or
Directories: The <tt class="FUNCTION">Delete</tt> Factory</h1>

<p>&#13; If you need to delete a file, then the <tt class=
"FUNCTION">Delete</tt> factory can be used in much the same way as
the <tt class="FUNCTION">Copy</tt> factory. For example, if we want
to make sure that the temporary file in our last example doesn't
exist before we copy to it, we could add <tt class=
"FUNCTION">Delete</tt> to the beginning of the command list:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Command("file.out", "file.in",
              [
                Delete("tempfile"),
                Copy("tempfile", "$SOURCE"),
                "modify tempfile",
                Copy("$TARGET", "tempfile"),
              ])
   
</pre>
</td>
</tr>
</table>

<p>&#13; When then executes as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Delete("tempfile")
      Copy("tempfile", "file.in")
      modify tempfile
      Copy("file.out", "tempfile")
   
</pre>
</td>
</tr>
</table>

<p>&#13; Of course, like all of these <tt class=
"CLASSNAME">Action</tt> factories, the <tt class=
"FUNCTION">Delete</tt> factory also expands <tt class=
"ENVAR">$TARGET</tt> and <tt class="ENVAR">$SOURCE</tt> variables
appropriately. For example:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Command("file.out", "file.in",
              [
                Delete("$TARGET"),
                Copy("$TARGET", "$SOURCE")
              ])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Executes as:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Delete("file.out")
      Copy("file.out", "file.in")
   
</pre>
</td>
</tr>
</table>

<p>&#13; (Note, however, that you typically don't need to call the
<tt class="FUNCTION">Delete</tt> factory explicitly in this way; by
default, <tt class="APPLICATION">SCons</tt> deletes its target(s)
for you before executing any action.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1865"></a>Moving (Renaming) Files
or Directories: The <tt class="FUNCTION">Move</tt> Factory</h1>

<p>&#13; The <tt class="FUNCTION">Move</tt> factory allows you to
rename a file or directory. For example, if we don't want to copy
the temporary file, we could:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Command("file.out", "file.in",
              [
                Copy("tempfile", "$SOURCE"),
                "modify tempfile",
                Move("$TARGET", "tempfile"),
              ])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Which would execute as:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Copy("tempfile", "file.in")
      modify tempfile
      Move("file.out", "tempfile")
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1874"></a>Updating the Modification
Time of a File: The <tt class="FUNCTION">Touch</tt> Factory</h1>

<p>&#13; If you just need to update the recorded modification time
for a file, use the <tt class="FUNCTION">Touch</tt> factory:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Command("file.out", "file.in",
              [
                Copy("tempfile", "$SOURCE"),
                "modify tempfile",
                Move("$TARGET", "tempfile"),
              ])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Which executes as:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Copy("tempfile", "file.in")
      modify tempfile
      Move("file.out", "tempfile")
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1883"></a>Creating a Directory: The
<tt class="FUNCTION">Mkdir</tt> Factory</h1>

<p>&#13; If you need to create a directory, use the <tt class=
"FUNCTION">Mkdir</tt> factory. For example, if we need to process a
file in a temporary directory in which the processing tool will
create other files that we don't care about, you could:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Command("file.out", "file.in",
              [
                Delete("tempdir"),
                Mkdir("tempdir"),
                Copy("tempdir/${SOURCE.file}", "$SOURCE"),
                "process tempdir",
                Move("$TARGET", "tempdir/output_file"),
                Delete("tempdir"),
              ])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Which executes as:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Delete("tempdir")
      Mkdir("tempdir")
      Copy("tempdir/file.in", "file.in")
      process tempdir
      Move("file.out", "tempdir/output_file")
      scons: *** [file.out] No such file or directory
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1892"></a>Changing File or
Directory Permissions: The <tt class="FUNCTION">Chmod</tt>
Factory</h1>

<p>&#13; To change permissions on a file or directory, use the <tt
class="FUNCTION">Chmod</tt> factory. The permission argument uses
POSIX-style permission bits and should typically be expressed as an
octal, not decimal, number:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Command("file.out", "file.in",
              [
                Copy("$TARGET", "$SOURCE"),
                Chmod("$TARGET", 0755),
              ])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Which executes:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Copy("file.out", "file.in")
      Chmod("file.out", 0755)
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1901"></a>Executing an action
immediately: the <tt class="FUNCTION">Execute</tt> Function</h1>

<p>&#13; We've been showing you how to use <tt class=
"CLASSNAME">Action</tt> factories in the <tt class=
"FUNCTION">Command</tt> function. You can also execute an <tt
class="CLASSNAME">Action</tt> returned by a factory (or actually,
any <tt class="CLASSNAME">Action</tt>) at the time the <tt class=
"FILENAME">SConscript</tt> file is read by wrapping it up in the
<tt class="FUNCTION">Execute</tt> function. For example, if we need
to make sure that a directory exists before we build any
targets,</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Execute(Mkdir('/tmp/my_temp_directory'))
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that this will create the directory while the <tt
class="FILENAME">SConscript</tt> file is being read:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      Mkdir("/tmp/my_temp_directory")
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
   
</pre>
</td>
</tr>
</table>

<p>&#13; If you're familiar with Python, you may wonder why you
would want to use this instead of just calling the native Python
<tt class="FUNCTION">os.mkdir()</tt> function. The advantage here
is that the <tt class="FUNCTION">Mkdir</tt> action will behave
appropriately if the user specifies the <tt class=
"APPLICATION">SCons</tt> <tt class="OPTION">-n</tt> or <tt class=
"OPTION">-q</tt> options--that is, it will print the action but not
actually make the directory when <tt class="OPTION">-n</tt> is
specified, or make the directory but not print the action when <tt
class="OPTION">-q</tt> is specified.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-PRECIOUS"></a>Preventing Removal of Targets: the
<tt class="FUNCTION">Precious</tt> Function</h1>

<p>&#13; By default, <tt class="APPLICATION">SCons</tt> removes
targets before building them. Sometimes, however, this is not what
you want. For example, you may want to update a library
incrementally, not by having it deleted and then rebuilt from all
of the constituent object files. In such cases, you can use the <tt
class="FUNCTION">Precious</tt> method to prevent <tt class=
"APPLICATION">SCons</tt> from removing the target before it is
built:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    lib = env.Library('foo', ['f1.c', 'f2.c', 'f3.c'])
    env.Precious(lib)
</pre>
</td>
</tr>
</table>

<p>&#13; Although the output doesn't look any different, <tt class=
"APPLICATION">SCons</tt> does not, in fact, delete the target
library before rebuilding it:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons -Q</b></tt>
    cc -c -o f1.o f1.c
    cc -c -o f2.o f2.c
    cc -c -o f3.o f3.c
    ar r libfoo.a f1.o f2.o f3.o
    ranlib libfoo.a
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> will, however, still
delete files marked as <tt class="FUNCTION">Precious</tt> when the
<tt class="LITERAL">-c</tt> option is used.</p>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-HIERARCHICAL"></a>Hierarchical Builds</h1>

<p>&#13; The source code for large software projects rarely stays
in a single directory, but is nearly always divided into a
hierarchy of directories. Organizing a large software build using
<tt class="APPLICATION">SCons</tt> involves creating a hierarchy of
build scripts using the <tt class="FILENAME">SConscript</tt>
function.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1945"></a><tt class=
"FILENAME">SConscript</tt> Files</h1>

<p>&#13; As we've already seen, the build script at the top of the
tree is called <tt class="FILENAME">SConstruct</tt>. The top-level
<tt class="FILENAME">SConstruct</tt> file can use the <tt class=
"FILENAME">SConscript</tt> function to include other subsidiary
scripts in the build. These subsidiary scripts can, in turn, use
the <tt class="FILENAME">SConscript</tt> function to include still
other scripts in the build. By convention, these subsidiary scripts
are usually named <tt class="FILENAME">SConscript</tt>. For
example, a top-level <tt class="FILENAME">SConstruct</tt> file
might arrange for four subsidiary scripts to be included in the
build as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      SConscript(['drivers/display/SConscript',
                  'drivers/mouse/SConscript',
                  'parser/SConscript',
                  'utilities/SConscript'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; In this case, the <tt class="FILENAME">SConstruct</tt>
file lists all of the <tt class="FILENAME">SConscript</tt> files in
the build explicitly. (Note, however, that not every directory in
the tree necessarily has an <tt class="FILENAME">SConscript</tt>
file.) Alternatively, the <tt class="LITERAL">drivers</tt>
subdirectory might contain an intermediate <tt class=
"FILENAME">SConscript</tt> file, in which case the <tt class=
"FILENAME">SConscript</tt> call in the top-level <tt class=
"FILENAME">SConstruct</tt> file would look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      SConscript(['drivers/SConscript',
                  'parser/SConscript',
                  'utilities/SConscript'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; And the subsidiary <tt class="FILENAME">SConscript</tt>
file in the <tt class="LITERAL">drivers</tt> subdirectory would
look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      SConscript(['display/SConscript',
                  'mouse/SConscript'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Whether you list all of the <tt class=
"FILENAME">SConscript</tt> files in the top-level <tt class=
"FILENAME">SConstruct</tt> file, or place a subsidiary <tt class=
"FILENAME">SConscript</tt> file in intervening directories, or use
some mix of the two schemes, is up to you and the needs of your
software.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1973"></a>Path Names Are Relative
to the <tt class="FILENAME">SConscript</tt> Directory</h1>

<p>&#13; Subsidiary <tt class="FILENAME">SConscript</tt> files make
it easy to create a build hierarchy because all of the file and
directory names in a subsidiary <tt class=
"FILENAME">SConscript</tt> files are interpreted relative to the
directory in which the <tt class="FILENAME">SConscript</tt> file
lives. Typically, this allows the <tt class=
"FILENAME">SConscript</tt> file containing the instructions to
build a target file to live in the same directory as the source
files from which the target will be built, making it easy to update
how the software is built whenever files are added or deleted (or
other changes are made).</p>

<p>&#13; For example, suppose we want to build two programs <tt
class="FILENAME">prog1</tt> and <tt class="FILENAME">prog2</tt> in
two separate directories with the same names as the programs. One
typical way to do this would be with a top-level <tt class=
"FILENAME">SConstruct</tt> file like this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      SConscript(['prog1/SConscript',
                  'prog2/SConscript'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; And subsidiary <tt class="FILENAME">SConscript</tt> files
that look like this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      env = Environment()
      env.Program('prog1', ['main.c', 'foo1.c', 'foo2.c'])
     
</pre>
</td>
</tr>
</table>

<p>&#13; And this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      env = Environment()
      env.Program('prog2', ['main.c', 'bar1.c', 'bar2.c'])
     
</pre>
</td>
</tr>
</table>

<p>&#13; Then, when we run <tt class="APPLICATION">SCons</tt> in
the top-level directory, our build looks like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o prog1/foo1.o prog1/foo1.c
       cc -c -o prog1/foo2.o prog1/foo2.c
       cc -c -o prog1/main.o prog1/main.c
       cc -o prog1/prog1 prog1/main.o prog1/foo1.o prog1/foo2.o
       cc -c -o prog2/bar1.o prog2/bar1.c
       cc -c -o prog2/bar2.o prog2/bar2.c
       cc -c -o prog2/main.o prog2/main.c
       cc -o prog2/prog2 prog2/main.o prog2/bar1.o prog2/bar2.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice the following: First, you can have files with the
same names in multiple directories, like main.c in the above
example. Second, unlike standard recursive use of <tt class=
"APPLICATION">Make</tt>, <tt class="APPLICATION">SCons</tt> stays
in the top-level directory (where the <tt class=
"FILENAME">SConstruct</tt> file lives) and issues commands that use
the path names from the top-level directory to the target and
source files within the hierarchy.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN1999"></a>Top-Level Path Names in
Subsidiary <tt class="FILENAME">SConscript</tt> Files</h1>

<p>&#13; If you need to use a file from another directory, it's
sometimes more convenient to specify the path to a file in another
directory from the top-level <tt class="FILENAME">SConstruct</tt>
directory, even when you're using that file in a subsidiary <tt
class="FILENAME">SConscript</tt> file in a subdirectory. You can
tell <tt class="APPLICATION">SCons</tt> to interpret a path name as
relative to the top-level <tt class="FILENAME">SConstruct</tt>
directory, not the local directory of the <tt class=
"FILENAME">SConscript</tt> file, by appending a <tt class=
"LITERAL">#</tt> (hash mark) to the beginning of the path name:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       env.Program('prog', ['main.c', '#lib/foo1.c', 'foo2.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; In this example, the <tt class="LITERAL">lib</tt>
directory is directly underneath the top-level <tt class=
"FILENAME">SConstruct</tt> directory. If the above <tt class=
"FILENAME">SConscript</tt> file is in a subdirectory named <tt
class="LITERAL">src/prog</tt>, the output would look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o lib/foo1.o lib/foo1.c
       cc -c -o src/prog/foo2.o src/prog/foo2.c
       cc -c -o src/prog/main.o src/prog/main.c
       cc -o src/prog/prog src/prog/main.o lib/foo1.o src/prog/foo2.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; (Notice that the <tt class="LITERAL">lib/foo1.o</tt>
object file is built in the same directory as its source file. See
<a href="#CHAP-SEPARATE">the chapter called <i>Separating Source
and Build Directories</i></a>, below, for information about how to
build the object file in a different subdirectory.)</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2020"></a>Absolute Path Names</h1>

<p>&#13; Of course, you can always specify an absolute path name
for a file--for example:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       env.Program('prog', ['main.c', '/usr/joe/lib/foo1.c', 'foo2.c'])
   
</pre>
</td>
</tr>
</table>

<p>&#13; Which, when executed, would yield:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
       % <tt class="USERINPUT"><b>scons -Q</b></tt>
       cc -c -o src/prog/foo2.o src/prog/foo2.c
       cc -c -o src/prog/main.o src/prog/main.c
       cc -c -o /usr/joe/lib/foo1.o /usr/joe/lib/foo1.c
       cc -o src/prog/prog src/prog/main.o /usr/joe/lib/foo1.o src/prog/foo2.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; (As was the case with top-relative path names, notice that
the <tt class="LITERAL">/usr/joe/lib/foo1.o</tt> object file is
built in the same directory as its source file. See <a href=
"#CHAP-SEPARATE">the chapter called <i>Separating Source and Build
Directories</i></a>, below, for information about how to build the
object file in a different subdirectory.)</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2030"></a>Sharing Environments (and
Other Variables) Between <tt class="FILENAME">SConscript</tt>
Files</h1>

<p>&#13; In the previous example, each of the subsidiary <tt class=
"FILENAME">SConscript</tt> files created its own construction
environment by calling <tt class="FUNCTION">Environment</tt>
separately. This obviously works fine, but if each program must be
built with the same construction variables, it's cumbersome and
error-prone to initialize separate construction environments in the
same way over and over in each subsidiary <tt class=
"FILENAME">SConscript</tt> file.</p>

<p>&#13; <tt class="APPLICATION">SCons</tt> supports the ability to
<i class="EMPHASIS">export</i> variables from a parent <tt class=
"FILENAME">SConscript</tt> file to its subsidiary <tt class=
"FILENAME">SConscript</tt> files, which allows you to share common
initialized values throughout your build hierarchy.</p>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN2042"></a>Exporting Variables</h2>

<p>&#13; There are two ways to export a variable, such as a
construction environment, from an <tt class=
"FILENAME">SConscript</tt> file, so that it may be used by other
<tt class="FILENAME">SConscript</tt> files. First, you can call the
<tt class="FUNCTION">Export</tt> function with a list of variables,
or a string white-space separated variable names. Each call to <tt
class="FUNCTION">Export</tt> adds one or more variables to a global
list of variables that are available for import by other <tt class=
"FILENAME">SConscript</tt> files.</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment()
        Export('env')
     
</pre>
</td>
</tr>
</table>

<p>&#13; You may export more than one variable name at a time:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        env = Environment()
        debug = ARGUMENTS['debug']
        Export('env', 'debug')
     
</pre>
</td>
</tr>
</table>

<p>&#13; Because white space is not legal in Python variable names,
the <tt class="FUNCTION">Export</tt> function will even
automatically split a string into separate names for you:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Export('env debug')
     
</pre>
</td>
</tr>
</table>

<p>&#13; Second, you can specify a list of variables to export as a
second argument to the <tt class="FILENAME">SConscript</tt>
function call:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        SConscript('src/SConscript', 'env')
     
</pre>
</td>
</tr>
</table>

<p>&#13; Or as the <tt class="VARNAME">exports</tt> keyword
argument:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        SConscript('src/SConscript', exports='env')
     
</pre>
</td>
</tr>
</table>

<p>&#13; These calls export the specified variables to only the
listed <tt class="FILENAME">SConscript</tt> files. You may,
however, specify more than one <tt class="FILENAME">SConscript</tt>
file in a list:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        SConscript(['src1/SConscript',
                    'src2/SConscript'], exports='env')
     
</pre>
</td>
</tr>
</table>

<p>&#13; This is functionally equivalent to calling the <tt class=
"FILENAME">SConscript</tt> function multiple times with the same
<tt class="VARNAME">exports</tt> argument, one per <tt class=
"FILENAME">SConscript</tt> file.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN2070"></a>Importing Variables</h2>

<p>&#13; Once a variable has been exported from a calling <tt
class="FILENAME">SConscript</tt> file, it may be used in other <tt
class="FILENAME">SConscript</tt> files by calling the <tt class=
"FUNCTION">Import</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Import('env')
        env.Program('prog', ['prog.c'])
     
</pre>
</td>
</tr>
</table>

<p>&#13; The <tt class="FUNCTION">Import</tt> call makes the <tt
class="LITERAL">env</tt> construction environment available to the
<tt class="FILENAME">SConscript</tt> file, after which the variable
can be used to build programs, libraries, etc.</p>

<p>&#13; Like the <tt class="FUNCTION">Export</tt> function, the
<tt class="FUNCTION">Import</tt> function can be used with multiple
variable names:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Import('env', 'debug')
        env = env.Copy(DEBUG = debug)
        env.Program('prog', ['prog.c'])
     
</pre>
</td>
</tr>
</table>

<p>&#13; And the <tt class="FUNCTION">Import</tt> function will
similarly split a string along white-space into separate variable
names:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Import('env debug')
        env = env.Copy(DEBUG = debug)
        env.Program('prog', ['prog.c'])
     
</pre>
</td>
</tr>
</table>

<p>&#13; Lastly, as a special case, you may import all of the
variables that have been exported by supplying an asterisk to the
<tt class="FUNCTION">Import</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        Import('*')
        env = env.Copy(DEBUG = debug)
        env.Program('prog', ['prog.c'])
     
</pre>
</td>
</tr>
</table>

<p>&#13; If you're dealing with a lot of <tt class=
"FILENAME">SConscript</tt> files, this can be a lot simpler than
keeping arbitrary lists of imported variables in each file.</p>
</div>

<div class="SECTION">
<hr>
<h2 class="SECTION"><a name="AEN2093"></a>Returning Values From an
<tt class="FILENAME">SConscript</tt> File</h2>

<p>&#13; Sometimes, you would like to be able to use information
from a subsidiary <tt class="FILENAME">SConscript</tt> file in some
way. For example, suppose that you want to create one library from
source files scattered throughout a number of subsidiary <tt class=
"FILENAME">SConscript</tt> files. You can do this by using the <tt
class="FUNCTION">Return</tt> function to return values from the
subsidiary <tt class="FILENAME">SConscript</tt> files to the
calling file.</p>

<p>&#13; If, for example, we have two subdirectories <tt class=
"APPLICATION">foo</tt> and <tt class="APPLICATION">bar</tt> that
should each contribute a source file to a Library, what we'd like
to be able to do is collect the object files from the subsidiary
<tt class="FILENAME">SConscript</tt> calls like this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
          env = Environment()
          Export('env')
          objs = []
          for subdir in ['foo', 'bar']:
              o = SConscript('%s/SConscript' % subdir)
              objs.append(o)
          env.Library('prog', objs)
     
</pre>
</td>
</tr>
</table>

<p>&#13; We can do this by using the <tt class=
"FUNCTION">Return</tt> function in the <tt class=
"LITERAL">foo/SConscript</tt> file like this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
          Import('env')
          obj = env.Object('foo.c')
          Return('obj')
       
</pre>
</td>
</tr>
</table>

<p>&#13; (The corresponding <tt class="LITERAL">bar/SConscript</tt>
file should be pretty obvious.) Then when we run <tt class=
"APPLICATION">SCons</tt>, the object files from the subsidiary
subdirectories are all correctly archived in the desired
library:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
        % <tt class="USERINPUT"><b>scons -Q</b></tt>
        cc -c -o bar/bar.o bar/bar.c
        cc -c -o foo/foo.o foo/foo.c
        ar r libprog.a foo/foo.o bar/bar.o
        ranlib libprog.a
     
</pre>
</td>
</tr>
</table>
</div>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-SEPARATE"></a>Separating Source and Build
Directories</h1>

<p>&#13; It's often useful to keep any built files completely
separate from the source files. This is usually done by creating
one or more separate <i class="EMPHASIS">build directories</i> that
are used to hold the built objects files, libraries, and executable
programs, etc. for a specific flavor of build. <tt class=
"APPLICATION">SCons</tt> provides two ways to do this, one through
the <tt class="FILENAME">SConscript</tt> function that we've
already seen, and the second through a more flexible <tt class=
"FUNCTION">BuildDir</tt> function.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2122"></a>Specifying a Build
Directory as Part of an <tt class="FILENAME">SConscript</tt>
Call</h1>

<p>&#13; The most straightforward way to establish a build
directory uses the fact that the usual way to set up a build
hierarchy is to have an <tt class="FILENAME">SConscript</tt> file
in the source subdirectory. If you then pass a <tt class=
"VARNAME">build_dir</tt> argument to the <tt class=
"FILENAME">SConscript</tt> function call:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      SConscript('src/SConscript', build_dir='build')
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> will then build all of
the files in the <tt class="FILENAME">build</tt> subdirectory:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>ls src</b></tt>
      SConscript  hello.c
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o build/hello.o build/hello.c
      cc -o build/hello build/hello.o
      % <tt class="USERINPUT"><b>ls build</b></tt>
      SConscript  hello  hello.c  hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; But wait a minute--what's going on here? <tt class=
"APPLICATION">SCons</tt> created the object file <tt class=
"FILENAME">build/hello.o</tt> in the <tt class=
"FILENAME">build</tt> subdirectory, as expected. But even though
our <tt class="FILENAME">hello.c</tt> file lives in the <tt class=
"FILENAME">src</tt> subdirectory, <tt class=
"APPLICATION">SCons</tt> has actually compiled a <tt class=
"FILENAME">build/hello.c</tt> file to create the object file.</p>

<p>&#13; What's happened is that <tt class="APPLICATION">SCons</tt>
has <i class="EMPHASIS">duplicated</i> the <tt class=
"FILENAME">hello.c</tt> file from the <tt class="FILENAME">src</tt>
subdirectory to the <tt class="FILENAME">build</tt> subdirectory,
and built the program from there. The next section explains why <tt
class="APPLICATION">SCons</tt> does this.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2152"></a>Why <tt class=
"APPLICATION">SCons</tt> Duplicates Source Files in a Build
Directory</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> duplicates source files
in build directories because it's the most straightforward way to
guarantee a correct build <i class="EMPHASIS">regardless of
include-file directory paths, relative references between files, or
tool support for putting files in different locations</i>, and the
<tt class="APPLICATION">SCons</tt> philosophy is to, by default,
guarantee a correct build in all cases.</p>

<p>&#13; The most direct reason to duplicate source files in build
directories is simply that some tools (mostly older vesions) are
written to only build their output files in the same directory as
the source files. In this case, the choices are either to build the
output file in the source directory and move it to the build
directory, or to duplicate the source files in the build
directory.</p>

<p>&#13; Additionally, relative references between files can cause
problems if we don't just duplicate the hierarchy of source files
in the build directory. You can see this at work in use of the C
preprocessor <tt class="LITERAL">#include</tt> mechanism with
double quotes, not angle brackets:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      #include "file.h"
   
</pre>
</td>
</tr>
</table>

<p>&#13; The <i class="EMPHASIS">de facto</i> standard behavior for
most C compilers in this case is to first look in the same
directory as the source file that contains the <tt class=
"LITERAL">#include</tt> line, then to look in the directories in
the preprocessor search path. Add to this that the <tt class=
"APPLICATION">SCons</tt> implementation of support for code
repositories (described below) means not all of the files will be
found in the same directory hierarchy, and the simplest way to make
sure that the right include file is found is to duplicate the
source files into the build directory, which provides a correct
build regardless of the original location(s) of the source
files.</p>

<p>&#13; Although source-file duplication guarantees a correct
build even in these end-cases, it <i class="EMPHASIS">can</i>
usually be safely disabled. The next section describes how you can
disable the duplication of source files in the build directory.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2169"></a>Telling <tt class=
"APPLICATION">SCons</tt> to Not Duplicate Source Files in the Build
Directory</h1>

<p>&#13; In most cases and with most tool sets, <tt class=
"APPLICATION">SCons</tt> can place its target files in a build
subdirectory <i class="EMPHASIS">without</i> duplicating the source
files and everything will work just fine. You can disable the
default <tt class="APPLICATION">SCons</tt> behavior by specifying
<tt class="LITERAL">duplicate=0</tt> when you call the <tt class=
"FILENAME">SConscript</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      SConscript('src/SConscript', build_dir='build', duplicate=0)
   
</pre>
</td>
</tr>
</table>

<p>&#13; When this flag is specified, <tt class=
"APPLICATION">SCons</tt> uses the build directory like most people
expect--that is, the output files are placed in the build directory
while the source files stay in the source directory:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>ls src</b></tt>
      SConscript
      hello.c
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c src/hello.c -o build/hello.o
      cc -o build/hello build/hello.o
      % <tt class="USERINPUT"><b>ls build</b></tt>
      hello
      hello.o
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2185"></a>The <tt class=
"FUNCTION">BuildDir</tt> Function</h1>

<p>&#13; Use the <tt class="FUNCTION">BuildDir</tt> function to
establish that target files should be built in a separate directory
from the source files:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      BuildDir('build', 'src')
      env = Environment()
      env.Program('build/hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Note that when you're not using an <tt class=
"FILENAME">SConscript</tt> file in the <tt class=
"FILENAME">src</tt> subdirectory, you must actually specify that
the program must be built from the <tt class=
"FILENAME">build/hello.c</tt> file that <tt class=
"APPLICATION">SCons</tt> will duplicate in the <tt class=
"FILENAME">build</tt> subdirectory.</p>

<p>&#13; When using the <tt class="FUNCTION">BuildDir</tt> function
directly, <tt class="APPLICATION">SCons</tt> still duplicates the
source files in the build directory by default:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>ls src</b></tt>
      hello.c
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o build/hello.o build/hello.c
      cc -o build/hello build/hello.o
      % <tt class="USERINPUT"><b>ls build</b></tt>
      hello  hello.c  hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; You can specify the same <tt class=
"LITERAL">duplicate=0</tt> argument that you can specify for an <tt
class="FILENAME">SConscript</tt> call:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      BuildDir('build', 'src', duplicate=0)
      env = Environment()
      env.Program('build/hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; In which case <tt class="APPLICATION">SCons</tt> will
disable duplication of the source files:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>ls src</b></tt>
      hello.c
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o build/hello.o src/hello.c
      cc -o build/hello build/hello.o
      % <tt class="USERINPUT"><b>ls build</b></tt>
      hello  hello.o
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2214"></a>Using <tt class=
"FUNCTION">BuildDir</tt> With an <tt class=
"FILENAME">SConscript</tt> File</h1>

<p>&#13; Even when using the <tt class="FUNCTION">BuildDir</tt>
function, it's much more natural to use it with a subsidiary <tt
class="FILENAME">SConscript</tt> file. For example, if the <tt
class="FILENAME">src/SConscript</tt> looks like this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      env = Environment()
      env.Program('hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Then our <tt class="FILENAME">SConstruct</tt> file could
look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      BuildDir('build', 'src')
      SConscript('build/SConscript')
     
</pre>
</td>
</tr>
</table>

<p>&#13; Yielding the following output:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>ls src</b></tt>
      SConscript  hello.c
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o build/hello.o build/hello.c
      cc -o build/hello build/hello.o
      % <tt class="USERINPUT"><b>ls build</b></tt>
      SConscript  hello  hello.c  hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that this is completely equivalent to the use of
<tt class="FILENAME">SConscript</tt> that we learned about in the
previous section.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-VARIANTS"></a>Variant Builds</h1>

<p>&#13; The <tt class="VARNAME">build_dir</tt> keyword argument of
the <tt class="FILENAME">SConscript</tt> function provides
everything we need to show how easy it is to create variant builds
using <tt class="APPLICATION">SCons</tt>. Suppose, for example,
that we want to build a program for both Windows and Linux
platforms, but that we want to build it in a shared directory with
separate side-by-side build directories for the Windows and Linux
versions of the program.</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    platform = ARGUMENTS.get('OS', Platform())

    include = "#export/$PLATFORM/include"
    lib = "#export/$PLATFORM/lib"
    bin = "#export/$PLATFORM/bin"

    env = Environment(PLATFORM = platform,
                      BINDIR = bin,
                      INCDIR = include,
                      LIBDIR = lib,
                      CPPPATH = [include],
                      LIBPATH = [lib],
                      LIBS = 'world')

    Export('env')

    env.SConscript('src/SConscript', build_dir='build/$PLATFORM')
 
</pre>
</td>
</tr>
</table>

<p>&#13; This SConstruct file, when run on a Linux system,
yields:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons -Q OS=linux</b></tt>
    Install file: "build/linux/world/world.h" as "export/linux/include/world.h"
    cc -Iexport/linux/include -c -o build/linux/hello/hello.o build/linux/hello/hello.c
    cc -Iexport/linux/include -c -o build/linux/world/world.o build/linux/world/world.c
    ar r build/linux/world/libworld.a build/linux/world/world.o
    ranlib build/linux/world/libworld.a
    Install file: "build/linux/world/libworld.a" as "export/linux/lib/libworld.a"
    cc -o build/linux/hello/hello build/linux/hello/hello.o -Lexport/linux/lib -lworld
    Install file: "build/linux/hello/hello" as "export/linux/bin/hello"
 
</pre>
</td>
</tr>
</table>

<p>&#13; The same SConstruct file on Windows would build:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    C:\&gt;<tt class="USERINPUT"><b>scons -Q OS=windows</b></tt>
    Install file: "build/windows/world/world.h" as "export/windows/include/world.h"
    cl /nologo /Iexport\windows\include /c build\windows\hello\hello.c /Fobuild\windows\hello\hello.obj
    cl /nologo /Iexport\windows\include /c build\windows\world\world.c /Fobuild\windows\world\world.obj
    lib /nologo /OUT:build\windows\world\world.lib build\windows\world\world.obj
    Install file: "build/windows/world/world.lib" as "export/windows/lib/world.lib"
    link /nologo /OUT:build\windows\hello\hello.exe /LIBPATH:export\windows\lib world.lib build\windows\hello\hello.obj
    Install file: "build/windows/hello/hello.exe" as "export/windows/bin/hello.exe"
 
</pre>
</td>
</tr>
</table>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-BUILDERS-WRITING"></a>Writing Your Own
Builders</h1>

<p>&#13; Although <tt class="APPLICATION">SCons</tt> provides many
useful methods for building common software products: programs,
libraries, documents. you frequently want to be able to build some
other type of file not supported directly by <tt class=
"APPLICATION">SCons</tt> Fortunately, <tt class=
"APPLICATION">SCons</tt> makes it very easy to define your own <tt
class="CLASSNAME">Builder</tt> objects for any custom file types
you want to build. (In fact, the <tt class="APPLICATION">SCons</tt>
interfaces for creating <tt class="CLASSNAME">Builder</tt> objects
are flexible enough and easy enough to use that all of the the <tt
class="APPLICATION">SCons</tt> built-in <tt class=
"CLASSNAME">Builder</tt> objects are created the mechanisms
described in this section.)</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2257"></a>Writing Builders That
Execute External Commands</h1>

<p>&#13; The simplest <tt class="CLASSNAME">Builder</tt> to create
is one that executes an external command. For example, if we want
to build an output file by running the contents of the input file
through a command named <tt class="LITERAL">foobuild</tt>, creating
that <tt class="CLASSNAME">Builder</tt> might look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET')
   
</pre>
</td>
</tr>
</table>

<p>&#13; All the above line does is create a free-standing <tt
class="CLASSNAME">Builder</tt> object. The next section will show
us how to actually use it.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2266"></a>Attaching a Builder to a
<tt class="LITERAL">Construction Environment</tt></h1>

<p>&#13; A <tt class="CLASSNAME">Builder</tt> object isn't useful
until it's attached to a <tt class="LITERAL">construction
environment</tt> so that we can call it to arrange for files to be
built. This is done through the <a href="#CV-BUILDERS"><tt class=
"ENVAR">$BUILDERS</tt></a> <tt class="LITERAL">construction
variable</tt> in an environment. The <tt class=
"ENVAR">$BUILDERS</tt> variable is a Python dictionary that maps
the names by which you want to call various <tt class=
"CLASSNAME">Builder</tt> objects to the objects themselves. For
example, if we want to call the <tt class="CLASSNAME">Builder</tt>
we just defined by the name <tt class="FUNCTION">Foo</tt>, our <tt
class="FILENAME">SConstruct</tt> file might look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET')
       env = Environment(BUILDERS = {'Foo' : bld})
   
</pre>
</td>
</tr>
</table>

<p>&#13; With the <tt class="CLASSNAME">Builder</tt> so attached to
our <tt class="LITERAL">construction environment</tt> we can now
actually call it like so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env.Foo('file.foo', 'file.input')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Then when we run <tt class="APPLICATION">SCons</tt> it
looks like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      foobuild &lt; file.input &gt; file.foo
   
</pre>
</td>
</tr>
</table>

<p>&#13; Note, however, that the default <tt class=
"ENVAR">$BUILDERS</tt> variable in a <tt class=
"LITERAL">construction environment</tt> comes with a default set of
<tt class="CLASSNAME">Builder</tt> objects already defined: <a
href="#B-PROGRAM"><tt class="FUNCTION">Program</tt></a>, <a href=
"#B-LIBRARY"><tt class="FUNCTION">Library</tt></a>, etc. And when
we explicitly set the <tt class="ENVAR">$BUILDERS</tt> variable
when we create the <tt class="LITERAL">construction
environment</tt>, the default <tt class="CLASSNAME">Builder</tt>s
are no longer part of the environment:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET')
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file.foo', 'file.input')
       env.Program('hello.c')
   
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      AttributeError: 'SConsEnvironment' object has no attribute 'Program':
        File "SConstruct", line 4:
          env.Program('hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; To be able use both our own defined <tt class=
"CLASSNAME">Builder</tt> objects and the default <tt class=
"CLASSNAME">Builder</tt> objects in the same <tt class=
"LITERAL">construction environment</tt>, you can either add to the
<tt class="ENVAR">$BUILDERS</tt> variable using the <tt class=
"FUNCTION">Append</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET')
       env.Append(BUILDERS = {'Foo' : bld})
       env.Foo('file.foo', 'file.input')
       env.Program('hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Or you can explicitly set the appropriately-named key in
the <tt class="ENVAR">$BUILDERS</tt> dictionary:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET')
       env['BUILDERS']['Foo'] = bld
       env.Foo('file.foo', 'file.input')
       env.Program('hello.c')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Either way, the same <tt class="LITERAL">construction
environment</tt> can then use both the newly-defined <tt class=
"FUNCTION">Foo</tt> <tt class="CLASSNAME">Builder</tt> and the
default <a href="#B-PROGRAM"><tt class="FUNCTION">Program</tt></a>
<tt class="CLASSNAME">Builder</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      foobuild &lt; file.input &gt; file.foo
      cc -c -o hello.o hello.c
      cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2322"></a>Letting <tt class=
"APPLICATION">SCons</tt> Handle The File Suffixes</h1>

<p>&#13; By supplying additional information when you create a <tt
class="CLASSNAME">Builder</tt>, you can let <tt class=
"APPLICATION">SCons</tt> add appropriate file suffixes to the
target and/or the source file. For example, rather than having to
specify explicitly that you want the <tt class="LITERAL">Foo</tt>
<tt class="CLASSNAME">Builder</tt> to build the <tt class=
"LITERAL">file.foo</tt> target file from the <tt class=
"LITERAL">file.input</tt> source file, you can give the <tt class=
"LITERAL">.foo</tt> and <tt class="LITERAL">.input</tt> suffixes to
the <tt class="CLASSNAME">Builder</tt>, making for more compact and
readable calls to the <tt class="LITERAL">Foo</tt> <tt class=
"CLASSNAME">Builder</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       bld = Builder(action = 'foobuild &lt; $SOURCE &gt; $TARGET',
                     suffix = '.foo',
                     src_suffix = '.input')
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file1')
       env.Foo('file2')
   
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      foobuild &lt; file1.input &gt; file1.foo
      foobuild &lt; file2.input &gt; file2.foo
   
</pre>
</td>
</tr>
</table>

<p>&#13; You can also supply a <tt class="LITERAL">prefix</tt>
keyword argument if it's appropriate to have <tt class=
"APPLICATION">SCons</tt> append a prefix to the beginning of target
file names.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2343"></a>Builders That Execute
Python Functions</h1>

<p>&#13; In <tt class="APPLICATION">SCons</tt>, you don't have to
call an external command to build a file. You can, instead, define
a Python function that a <tt class="CLASSNAME">Builder</tt> object
can invoke to build your target file (or files). Such a <tt class=
"LITERAL">builder function</tt> definition looks like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       def build_function(target, source, env):
           # Code to build "target" from "source"
           return None
   
</pre>
</td>
</tr>
</table>

<p>&#13; The arguments of a <tt class="LITERAL">builder
function</tt> are:</p>

<div class="VARIABLELIST">
<dl>
<dt>target</dt>

<dd>
<p>&#13; A list of Node objects representing the target or targets
to be built by this builder function. The file names of these
target(s) may be extracted using the Python <tt class=
"FUNCTION">str</tt> function.</p>
</dd>

<dt>source</dt>

<dd>
<p>&#13; A list of Node objects representing the sources to be used
by this builder function to build the targets. The file names of
these source(s) may be extracted using the Python <tt class=
"FUNCTION">str</tt> function.</p>
</dd>

<dt>env</dt>

<dd>
<p>&#13; The <tt class="LITERAL">construction environment</tt> used
for building the target(s). The builder function may use any of the
environment's construction variables in any way to affect how it
builds the targets.</p>
</dd>
</dl>
</div>

<p>&#13; The builder function must return a <tt class=
"LITERAL">0</tt> or <tt class="LITERAL">None</tt> value if the
target(s) are built successfully. The builder function may raise an
exception or return any non-zero value to indicate that the build
is unsuccessful,</p>

<p>&#13; Once you've defined the Python function that will build
your target file, defining a <tt class="CLASSNAME">Builder</tt>
object for it is as simple as specifying the name of the function,
instead of an external command, as the <tt class=
"CLASSNAME">Builder</tt>'s <tt class="LITERAL">action</tt>
argument:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       def build_function(target, source, env):
           # Code to build "target" from "source"
           return None
       bld = Builder(action = build_function,
                     suffix = '.foo',
                     src_suffix = '.input')
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file')
   
</pre>
</td>
</tr>
</table>

<p>&#13; And notice that the output changes slightly, reflecting
the fact that a Python function, not an external command, is now
called to build the target file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      build_function(["file.foo"], ["file.input"])
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2379"></a>Builders That Create
Actions Using a <tt class="LITERAL">Generator</tt></h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> Builder objects can
create an action "on the fly" by using a function called a <tt
class="LITERAL">generator</tt>. This provides a great deal of
flexibility to construct just the right list of commands to build
your target. A <tt class="LITERAL">generator</tt> looks like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       def generate_actions(source, target, env, for_signature):
           return 'foobuild &lt; %s &gt; %s' % (target[0], source[0])
   
</pre>
</td>
</tr>
</table>

<p>&#13; The arguments of a <tt class="LITERAL">generator</tt>
are:</p>

<div class="VARIABLELIST">
<dl>
<dt>source</dt>

<dd>
<p>&#13; A list of Node objects representing the sources to be
built by the command or other action generated by this function.
The file names of these source(s) may be extracted using the Python
<tt class="FUNCTION">str</tt> function.</p>
</dd>

<dt>target</dt>

<dd>
<p>&#13; A list of Node objects representing the target or targets
to be built by the command or other action generated by this
function. The file names of these target(s) may be extracted using
the Python <tt class="FUNCTION">str</tt> function.</p>
</dd>

<dt>env</dt>

<dd>
<p>&#13; The <tt class="LITERAL">construction environment</tt> used
for building the target(s). The generator may use any of the
environment's construction variables in any way to determine what
command or other action to return.</p>
</dd>

<dt>for_signature</dt>

<dd>
<p>&#13; A flag that specifies whether the generator is being
called to contribute to a build signature, as opposed to actually
executing the command.</p>
</dd>
</dl>
</div>

<p>&#13; The <tt class="LITERAL">generator</tt> must return a
command string or other action that will be used to build the
specified target(s) from the specified source(s).</p>

<p>&#13; Once you've defined a <tt class="LITERAL">generator</tt>,
you create a <tt class="CLASSNAME">Builder</tt> to use it by
specifying the generator keyword argument instead of <tt class=
"LITERAL">action</tt>.</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       def generate_actions(source, target, env, for_signature):
           return 'foobuild &lt; %s &gt; %s' % (source[0], target[0])
       bld = Builder(generator = generate_actions,
                     suffix = '.foo',
                     src_suffix = '.input')
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file')
   
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      foobuild &lt; file.input &gt; file.foo
   
</pre>
</td>
</tr>
</table>

<p>&#13; Note that it's illegal to specify both an <tt class=
"LITERAL">action</tt> and a <tt class="LITERAL">generator</tt> for
a <tt class="CLASSNAME">Builder</tt>.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2422"></a>Builders That Modify the
Target or Source Lists Using an <tt class=
"LITERAL">Emitter</tt></h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> supports the ability
for a Builder to modify the lists of target(s) from the specified
source(s).</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       def modify_targets(target, source, env):
           target.append('new_target')
           source.append('new_source')
           return target, source
       bld = Builder(action = 'foobuild $TARGETS - $SOURCES',
                     suffix = '.foo',
                     src_suffix = '.input',
                     emitter = modify_targets)
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file')
   
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      foobuild file.foo new_target - file.input new_source
   
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       bld = Builder(action = 'XXX',
                     suffix = '.foo',
                     src_suffix = '.input',
                     emitter = 'MY_EMITTER')
       def modify1(target, source, env):
           return target, source
       def modify2(target, source, env):
           return target, source
       env1 = Environment(BUILDERS = {'Foo' : bld},
                          MY_EMITTER = modify1)
       env2 = Environment(BUILDERS = {'Foo' : bld},
                          MY_EMITTER = modify2)
       env1.Foo('file1')
       env2.Foo('file2')
   
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-BUILDERS-COMMANDS"></a>Not Writing a Builder: the
<tt class="FUNCTION">Command</tt> Builder</h1>

<p>&#13; Creating a <tt class="CLASSNAME">Builder</tt> and
attaching it to a <tt class="LITERAL">construction environment</tt>
allows for a lot of flexibility when you want to re-use actions to
build multiple files of the same type. This can, however, be
cumbersome if you only need to execute one specific command to
build a single file (or group of files). For these situations, <tt
class="APPLICATION">SCons</tt> supports a <tt class=
"FUNCTION">Command</tt> <tt class="CLASSNAME">Builder</tt> that
arranges for a specific action to be executed to build a specific
file or files. This looks a lot like the other builders (like <a
href="#B-PROGRAM"><tt class="FUNCTION">Program</tt></a>, <a href=
"#B-OBJECT"><tt class="FUNCTION">Object</tt></a>, etc.), but takes
as an additional argument the command to be executed to build the
file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment()
     env.Command('foo.out', 'foo.in', "sed 's/x/y/' &lt; $SOURCE &gt; $TARGET")
 
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons -Q</b></tt>
    sed 's/x/y/' &lt; foo.in &gt; foo.out
 
</pre>
</td>
</tr>
</table>

<p>&#13; This is often more convenient than creating a <tt class=
"CLASSNAME">Builder</tt> object and adding it to the <a href=
"#CV-BUILDERS"><tt class="ENVAR">$BUILDERS</tt></a> variable of a
<tt class="LITERAL">construction environment</tt></p>

<p>&#13; Note that the action you</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment()
     def build(target, source, env):
         # Whatever it takes to build
         return None
     env.Command('foo.out', 'foo.in', build)
 
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons -Q</b></tt>
    build(["foo.out"], ["foo.in"])
 
</pre>
</td>
</tr>
</table>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-SCANNERS"></a>Writing Scanners</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> has built-in scanners
that know how to look in C, Fortran and IDL source files for
information about other files that targets built from those files
depend on--for example, in the case of files that use the C
preprocessor, the <tt class="FILENAME">.h</tt> files that are
specified using <tt class="LITERAL">#include</tt> lines in the
source. You can use the same mechanisms that <tt class=
"APPLICATION">SCons</tt> uses to create its built-in scanners to
write scanners of your own for file types that <tt class=
"APPLICATION">SCons</tt> does not know how to scan "out of the
box."</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2464"></a>A Simple Scanner
Example</h1>

<p>&#13; Suppose, for example, that we want to create a simple
scanner for <tt class="FILENAME">.foo</tt> files. A <tt class=
"FILENAME">.foo</tt> file contains some text that will be
processed, and can include other files on lines that begin with <tt
class="LITERAL">include</tt> followed by a file name:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      include filename.foo
   
</pre>
</td>
</tr>
</table>

<p>&#13; Scanning a file will be handled by a Python function that
you must supply. Here is a function that will use the Python <tt
class="FILENAME">re</tt> module to scan for the <tt class=
"LITERAL">include</tt> lines in our example:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      import re
      
      include_re = re.compile(r'^include\\s+(\\S+)$', re.M)
      
      def kfile_scan(node, env, path, arg):
          contents = node.get_contents()
          return include_re.findall(contents)
   
</pre>
</td>
</tr>
</table>

<p>&#13; The scanner function must accept the four specified
arguments and return a list of implicit dependencies. Presumably,
these would be dependencies found from examining the contents of
the file, although the function can perform any manipulation at all
to generate the list of dependencies.</p>

<div class="VARIABLELIST">
<dl>
<dt>node</dt>

<dd>
<p>&#13; An <tt class="APPLICATION">SCons</tt> node object
representing the file being scanned. The path name to the file can
be used by converting the node to a string using the <tt class=
"LITERAL">str()</tt> function, or an internal <tt class=
"APPLICATION">SCons</tt> <tt class="LITERAL">get_contents()</tt>
object method can be used to fetch the contents.</p>
</dd>

<dt>env</dt>

<dd>
<p>&#13; The construction environment in effect for this scan. The
scanner function may choose to use construction variables from this
environment to affect its behavior.</p>
</dd>

<dt>path</dt>

<dd>
<p>&#13; A list of directories that form the search path for
included files for this scanner. This is how <tt class=
"APPLICATION">SCons</tt> handles the <a href="#CV-CPPPATH"><tt
class="ENVAR">$CPPPATH</tt></a> and <a href="#CV-LIBPATH"><tt
class="ENVAR">$LIBPATH</tt></a> variables.</p>
</dd>

<dt>arg</dt>

<dd>
<p>&#13; An optional argument that you can choose to have passed to
this scanner function by various scanner instances.</p>
</dd>
</dl>
</div>

<p>&#13; A Scanner object is created using the <tt class=
"CLASSNAME">Scanner</tt> function, which typically takes an <tt
class="LITERAL">skeys</tt> argument to associate the type of file
suffix with this scanner. The Scanner object must then be
associated with the <a href="#CV-SCANNERS"><tt class=
"ENVAR">$SCANNERS</tt></a> construction variable of a construction
environment, typically by using the <tt class=
"FUNCTION">Append</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       kscan = Scanner(function = kfile_scan,
                       skeys = ['.k'])
       env.Append(SCANNERS = kscan)
   
</pre>
</td>
</tr>
</table>

<p>&#13; When we put it all together, it looks like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
        import re

        include_re = re.compile(r'^include\\s+(\\S+)$', re.M)

        def kfile_scan(node, env, path):
            contents = node.get_contents()
            includes = include_re.findall(contents)
            return includes

        kscan = Scanner(function = kfile_scan,
                        skeys = ['.k'])

        env = Environment(ENV = {'PATH' : '/usr/local/bin'})
        env.Append(SCANNERS = kscan)

        env.Command('foo', 'foo.k', 'kprocess &lt; $SOURCES &gt; $TARGET')
   
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-REPOSITORIES"></a>Building From Code
Repositories</h1>

<p>&#13; Often, a software project will have one or more central
repositories, directory trees that contain source code, or derived
files, or both. You can eliminate additional unnecessary rebuilds
of files by having <tt class="APPLICATION">SCons</tt> use files
from one or more code repositories to build files in your local
build tree.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2515"></a>The <tt class=
"FUNCTION">Repository</tt> Method</h1>

<p>&#13; It's often useful to allow multiple programmers working on
a project to build software from source files and/or derived files
that are stored in a centrally-accessible repository, a directory
copy of the source code tree. (Note that this is not the sort of
repository maintained by a source code management system like
BitKeeper, CVS, or Subversion. For information about using <tt
class="APPLICATION">SCons</tt> with these systems, see the section,
"Fetching Files From Source Code Management Systems," below.) You
use the <tt class="FUNCTION">Repository</tt> method to tell <tt
class="APPLICATION">SCons</tt> to search one or more central code
repositories (in order) for any source files and derived files that
are not present in the local build tree:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       env.Program('hello.c')
       Repository('/usr/repository1', '/usr/repository2')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Multiple calls to the <tt class="FUNCTION">Repository</tt>
method will simply add repositories to the global list that <tt
class="APPLICATION">SCons</tt> maintains, with the exception that
<tt class="APPLICATION">SCons</tt> will automatically eliminate the
current directory and any non-existent directories from the
list.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2527"></a>Finding source files in
repositories</h1>

<p>&#13; The above example specifies that <tt class=
"APPLICATION">SCons</tt> will first search for files under the <tt
class="FILENAME">/usr/repository1</tt> tree and next under the <tt
class="FILENAME">/usr/repository2</tt> tree. <tt class=
"APPLICATION">SCons</tt> expects that any files it searches for
will be found in the same position relative to the top-level
directory. In the above example, if the <tt class=
"FILENAME">hello.c</tt> file is not found in the local build tree,
<tt class="APPLICATION">SCons</tt> will search first for a <tt
class="FILENAME">/usr/repository1/hello.c</tt> file and then for a
<tt class="FILENAME">/usr/repository1/hello.c</tt> file to use in
its place.</p>

<p>&#13; So given the <tt class="FILENAME">SConstruct</tt> file
above, if the <tt class="FILENAME">hello.c</tt> file exists in the
local build directory, <tt class="APPLICATION">SCons</tt> will
rebuild the <tt class="APPLICATION">hello</tt> program as
normal:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; If, however, there is no local <tt class=
"FILENAME">hello.c</tt> file, but one exists in <tt class=
"FILENAME">/usr/repository1</tt>, <tt class=
"APPLICATION">SCons</tt> will recompile the <tt class=
"APPLICATION">hello</tt> program from the source file it finds in
the repository:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      gcc -c /usr/repository1/hello.c -o hello.o
      gcc -o hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; And similarly, if there is no local <tt class=
"FILENAME">hello.c</tt> file and no <tt class=
"FILENAME">/usr/repository1/hello.c</tt>, but one exists in <tt
class="FILENAME">/usr/repository2</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13;</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2559"></a>Finding the <tt class=
"FILENAME">SConstruct</tt> file in repositories</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> will also search in
repositories for the <tt class="FILENAME">SConstruct</tt> file and
any specified <tt class="FILENAME">SConscript</tt> files. This
poses a problem, though: how can <tt class="APPLICATION">SCons</tt>
search a repository tree for an <tt class=
"FILENAME">SConstruct</tt> file if the <tt class=
"FILENAME">SConstruct</tt> file itself contains the information
about the pathname of the repository? To solve this problem, <tt
class="APPLICATION">SCons</tt> allows you to specify repository
directories on the command line using the <tt class=
"LITERAL">-Y</tt> option:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class=
"USERINPUT"><b>scons -Q -Y /usr/repository1 -Y /usr/repository2</b></tt>
   
</pre>
</td>
</tr>
</table>

<p>&#13; When looking for source or derived files, <tt class=
"APPLICATION">SCons</tt> will first search the repositories
specified on the command line, and then search the repositories
specified in the <tt class="FILENAME">SConstruct</tt> or <tt class=
"FILENAME">SConscript</tt> files.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2577"></a>Finding derived files in
repositories</h1>

<p>&#13; If a repository contains not only source files, but also
derived files (such as object files, libraries, or executables),
<tt class="APPLICATION">SCons</tt> will perform its normal MD5
signature calculation to decide if a derived file in a repository
is up-to-date, or the derived file must be rebuilt in the local
build directory. For the <tt class="APPLICATION">SCons</tt>
signature calculation to work correctly, a repository tree must
contain the <tt class="FILENAME">.sconsign</tt> files that <tt
class="APPLICATION">SCons</tt> uses to keep track of signature
information.</p>

<p>&#13; Usually, this would be done by a build integrator who
would run <tt class="APPLICATION">SCons</tt> in the repository to
create all of its derived files and <tt class=
"FILENAME">.sconsign</tt> files, or who would <tt class=
"APPLICATION">SCons</tt> in a separate build directory and copying
the resulting tree to the desired repository:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>cd /usr/repository1</b></tt>
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o file1.o file1.c
      cc -c -o file2.o file2.c
      cc -c -o hello.o hello.c
      cc -o hello hello.o file1.o file2.o
   
</pre>
</td>
</tr>
</table>

<p>(Note that this is safe even if the <tt class=
"FILENAME">SConstruct</tt> file lists <tt class=
"FILENAME">/usr/repository1</tt> as a repository, because <tt
class="APPLICATION">SCons</tt> will remove the current build
directory from its repository list for that invocation.)</p>

<p>&#13; Now, with the repository populated, we only need to create
the one local source file we're interested in working with at the
moment, and use the <tt class="LITERAL">-Y</tt> option to tell <tt
class="APPLICATION">SCons</tt> to fetch any other files it needs
from the repository:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>cd $HOME/build</b></tt>
      % <tt class="USERINPUT"><b>edit hello.c</b></tt>
      % <tt class=
"USERINPUT"><b>scons -Q -Y /usr/repository1</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o /usr/repository1/file1.o /usr/repository1/file2.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice that <tt class="APPLICATION">SCons</tt> realizes
that it does not need to rebuild local copies file1.o and file2.o
files, but instead uses the already-compiled files from the
repository.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2604"></a>Guaranteeing local copies
of files</h1>

<p>&#13; If the repository tree contains the complete results of a
build, and we try to build from the repository without any files in
our local tree, something moderately surprising happens:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>mkdir $HOME/build2</b></tt>
      % <tt class="USERINPUT"><b>cd $HOME/build2</b></tt>
      % <tt class=
"USERINPUT"><b>scons -Q -Y /usr/all/repository hello</b></tt>
      scons: `hello' is up-to-date.
   
</pre>
</td>
</tr>
</table>

<p>&#13; Why does <tt class="APPLICATION">SCons</tt> say that the
<tt class="APPLICATION">hello</tt> program is up-to-date when there
is no <tt class="APPLICATION">hello</tt> program in the local build
directory? Because the repository (not the local directory)
contains the up-to-date <tt class="APPLICATION">hello</tt> program,
and <tt class="APPLICATION">SCons</tt> correctly determines that
nothing needs to be done to rebuild that up-to-date copy of the
file.</p>

<p>&#13; There are, however, many times when you want to ensure
that a local copy of a file always exists. A packaging or testing
script, for example, may assume that certain generated files exist
locally. To tell <tt class="APPLICATION">SCons</tt> to make a copy
of any up-to-date repository file in the local build directory, use
the <tt class="FUNCTION">Local</tt> function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       env = Environment()
       hello = env.Program('hello.c')
       Local(hello)
   
</pre>
</td>
</tr>
</table>

<p>&#13; If we then run the same command, <tt class=
"APPLICATION">SCons</tt> will make a local copy of the program from
the repository copy, and tell you that it is doing so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class=
"USERINPUT"><b>scons -Y /usr/all/repository hello</b></tt>
      Local copy of hello from /usr/all/repository/hello
      scons: `hello' is up-to-date.
   
</pre>
</td>
</tr>
</table>

<p>&#13; (Notice that, because the act of making the local copy is
not considered a "build" of the <tt class="APPLICATION">hello</tt>
file, <tt class="APPLICATION">SCons</tt> still reports that it is
up-to-date.)</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-SCONF"></a>Multi-Platform Configuration (<tt
class="APPLICATION">Autoconf</tt> Functionality)</h1>

<p>&#13; <tt class="APPLICATION">SCons</tt> has integrated support
for multi-platform build configuration similar to that offered by
GNU <tt class="APPLICATION">Autoconf</tt>, such as figuring out
what libraries or header files are available on the local system.
This section describes how to use this <tt class=
"APPLICATION">SCons</tt> feature.</p>

<div class="NOTE">
<table class="NOTE" width="100%" border="0">
<tr>
<td width="25" align="CENTER" valign="TOP"><img src=
"./stylesheet-images/note.gif" hspace="5" alt="Note"></td>
<td align="LEFT" valign="TOP">
<p>This chapter is still under development, so not everything is
explained as well as it should be. See the <tt class=
"APPLICATION">SCons</tt> man page for additional information.</p>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2638"></a><tt class=
"LITERAL">Configure Contexts</tt></h1>

<p>&#13; The basic framework for multi-platform build configuration
in <tt class="APPLICATION">SCons</tt> is to attach a <tt class=
"LITERAL">configure context</tt> to a construction environment by
calling the <tt class="FUNCTION">Configure</tt> function, perform a
number of checks for libraries, functions, header files, etc., and
to then call the configure context's <tt class=
"FUNCTION">Finish</tt> method to finish off the configuration:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env)
    # Checks for libraries, header files, etc. go here!
    env = conf.Finish()
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> provides a number of
basic checks, as well as a mechanism for adding your own custom
checks.</p>

<p>&#13; Note that <tt class="APPLICATION">SCons</tt> uses its own
dependency mechanism to determine when a check needs to be
run--that is, <tt class="APPLICATION">SCons</tt> does not run the
checks every time it is invoked, but caches the values returned by
previous checks and uses the cached values unless something has
changed. This saves a tremendous amount of developer time while
working on cross-platform build issues.</p>

<p>&#13; The next sections describe the basic checks that <tt
class="APPLICATION">SCons</tt> supports, as well as how to add your
own custom checks.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2654"></a>Checking for the
Existence of Header Files</h1>

<p>&#13; Testing the existence of a header file requires knowing
what language the header file is. A configure context has a <tt
class="FUNCTION">CheckCHeader</tt> method that checks for the
existence of a C header file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env)
    if not conf.CheckCHeader('math.h'):
        print 'Math.h must be installed!'
        Exit(1)
    if conf.CheckCHeader('foo.h'):
        conf.env.Append('-DHAS_FOO_H')
    env = conf.Finish()
   
</pre>
</td>
</tr>
</table>

<p>&#13; Note that you can choose to terminate the build if a given
header file doesn't exist, or you can modify the contstruction
environment based on the existence of a header file.</p>

<p>&#13; If you need to check for the existence a C++ header file,
use the <tt class="FUNCTION">CheckCXXHeader</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env)
    if not conf.CheckCXXHeader('vector.h'):
        print 'vector.h must be installed!'
        Exit(1)
    env = conf.Finish()
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2663"></a>Checking for the
Availability of a Function</h1>

<p>&#13; Check for the availability of a specific function using
the <tt class="FUNCTION">CheckFunc</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env)
    if not conf.CheckFunc('strcpy'):
        print 'Did not find strcpy(), using local version'
        conf.env.Append('-Dstrcpy=my_local_strcpy')
    env = conf.Finish()
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2668"></a>Checking for the
Availability of a Library</h1>

<p>&#13; Check for the availability of a library using the <tt
class="FUNCTION">CheckLib</tt> method. You only specify the
basename of the library, you don't need to add a <tt class=
"LITERAL">lib</tt> prefix or a <tt class="LITERAL">.a</tt> or <tt
class="LITERAL">.lib</tt> suffix:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env)
    if not conf.CheckLib('m'):
        print 'Did not find libm.a or m.lib, exiting!'
        Exit(1)
    env = conf.Finish()
   
</pre>
</td>
</tr>
</table>

<p>&#13; Because the ability to use a library successfully often
depends on having access to a header file that describes the
library's interface, you can check for a library <i class=
"EMPHASIS">and</i> a header file at the same time by using the <tt
class="FUNCTION">CheckLibWithHeader</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env)
    if not conf.CheckLibWithHeader('m', 'math.h'):
        print 'Did not find libm.a or m.lib, exiting!'
        Exit(1)
    env = conf.Finish()
   
</pre>
</td>
</tr>
</table>

<p>&#13; This is essentially shorthand for separate calls to the
<tt class="FUNCTION">CheckHeader</tt> and <tt class=
"FUNCTION">CheckLib</tt> functions.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2683"></a>Checking for the
Availability of a <tt class="LITERAL">typedef</tt></h1>

<p>&#13; Check for the availability of a <tt class=
"LITERAL">typedef</tt> by using the <tt class=
"FUNCTION">CheckType</tt> method:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env)
    if not conf.CheckType('off_t'):
        print 'Did not find off_t typedef, assuming int'
        conf.env.Append(CCFLAGS = '-Doff_t=int')
    env = conf.Finish()
   
</pre>
</td>
</tr>
</table>

<p>&#13; You can also add a string that will be placed at the
beginning of the test file that will be used to check for the <tt
class="LITERAL">typedef</tt>. This provide a way to specify files
that must be included to find the <tt class=
"LITERAL">typedef</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env)
    if not conf.CheckType('off_t', '#include &lt;sys/types.h&gt;\n'):
        print 'Did not find off_t typedef, assuming int'
        conf.env.Append(CCFLAGS = '-Doff_t=int')
    env = conf.Finish()
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2694"></a>Adding Your Own Custom
Checks</h1>

<p>&#13; A custom check is a Python function that checks for a
certain condition to exist on the running system, usually using
methods that <tt class="APPLICATION">SCons</tt> supplies to take
care of the details of checking whether a compilation succeeds, a
link succeeds, a program is runnable, etc. A simple custom check
for the existence of a specific library might look as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    mylib_test_source_file = """
    #include &lt;mylib.h&gt;
    int main(int argc, char **argv)
    {
        MyLibrary mylib(argc, argv);
        return 0;
    }
    """

    def CheckMyLibrary(context):
        context.Message('Checking for MyLibrary...')
        result = context.TryLink(mylib_test_source_file, '.c')
        context.Result(result)
        return result
   
</pre>
</td>
</tr>
</table>

<p>&#13; The <tt class="FUNCTION">Message</tt> and <tt class=
"FUNCTION">Result</tt> methods should typically begin and end a
custom check to let the user know what's going on: the <tt class=
"FUNCTION">Message</tt> call prints the specified message (with no
trailing newline) and the <tt class="FUNCTION">Result</tt> call
prints <tt class="LITERAL">ok</tt> if the check succeeds and <tt
class="LITERAL">failed</tt> if it doesn't. The <tt class=
"FUNCTION">TryLink</tt> method actually tests for whether the
specified program text will successfully link.</p>

<p>&#13; (Note that a custom check can modify its check based on
any arguments you choose to pass it, or by using or modifying the
configure context environment in the <tt class=
"LITERAL">context.env</tt> attribute.)</p>

<p>&#13; This custom check function is then attached to the <tt
class="LITERAL">configure context</tt> by passing a dictionary to
the <tt class="FUNCTION">Configure</tt> call that maps a name of
the check to the underlying function:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    conf = Configure(env, custom_tests = {'CheckMyLibrary' : CheckMyLibrary})
   
</pre>
</td>
</tr>
</table>

<p>&#13; You'll typically want to make the check and the function
name the same, as we've done here, to avoid potential
confusion.</p>

<p>&#13; We can then put these pieces together and actually call
the <tt class="LITERAL">CheckMyLibrary</tt> check as follows:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    mylib_test_source_file = """
    #include &lt;mylib.h&gt;
    int main(int argc, char **argv)
    {
        MyLibrary mylib(argc, argv);
        return 0;
    }
    """

    def CheckMyLibrary(context):
        context.Message('Checking for MyLibrary... ')
        result = context.TryLink(mylib_test_source_file, '.c')
        context.Result(result)
        return result

    env = Environment()
    conf = Configure(env, custom_tests = {'CheckMyLibrary' : CheckMyLibrary})
    if not conf.CheckMyLibrary():
        print 'MyLibrary is not installed!'
        Exit(1)
    env = conf.Finish()

    # We would then add actual calls like Program() to build
    # something using the "env" construction environment.
   
</pre>
</td>
</tr>
</table>

<p>&#13; If MyLibrary is not installed on the system, the output
will look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons</b></tt>
    scons: Reading SConscript file ...
    Checking for MyLibrary... failed
    MyLibrary is not installed!
   
</pre>
</td>
</tr>
</table>

<p>&#13; If MyLibrary is installed, the output will look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons</b></tt>
    scons: Reading SConscript file ...
    Checking for MyLibrary... failed
    scons: done reading SConscript
    scons: Building targets ...
        .
        .
        .
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2723"></a>Not Configuring When
Cleaning Targets</h1>

<p>&#13; Using multi-platform configuration as described in the
previous sections will run the configuration commands even when
invoking <tt class="USERINPUT"><b>scons -c</b></tt> to clean
targets:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons -Q -c</b></tt>
    Checking for MyLibrary... ok
    Removed foo.o
    Removed foo
   
</pre>
</td>
</tr>
</table>

<p>&#13; Although running the platform checks when removing targets
doesn't hurt anything, it's usually unnecessary. You can avoid this
by using the <tt class="FUNCTION">GetOption</tt>(); method to check
whether the <tt class="OPTION">-c</tt> (clean) option has been
invoked on the command line:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
    env = Environment()
    if not env.GetOption('clean'):
        conf = Configure(env, custom_tests = {'CheckMyLibrary' : CheckMyLibrary})
        if not conf.CheckMyLibrary():
            print 'MyLibrary is not installed!'
            Exit(1)
        env = conf.Finish()
   
</pre>
</td>
</tr>
</table>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
    % <tt class="USERINPUT"><b>scons -Q -c</b></tt>
    Removed foo.o
    Removed foo
   
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-CACHING"></a>Caching Built Files</h1>

<p>&#13; On multi-developer software projects, you can sometimes
speed up every developer's builds a lot by allowing them to share
the derived files that they build. <tt class=
"APPLICATION">SCons</tt> makes this easy, as well as reliable.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2739"></a>Specifying the Shared
Cache Directory</h1>

<p>&#13; To enable sharing of derived files, use the <tt class=
"FUNCTION">CacheDir</tt> function in any <tt class=
"FILENAME">SConscript</tt> file:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
       CacheDir('/usr/local/build_cache')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Note that the directory you specify must already exist and
be readable and writable by all developers who will be sharing
derived files. It should also be in some central location that all
builds will be able to access. In environments where developers are
using separate systems (like individual workstations) for builds,
this directory would typically be on a shared or NFS-mounted file
system.</p>

<p>&#13; Here's what happens: When a build has a <tt class=
"FUNCTION">CacheDir</tt> specified, every time a file is built, it
is stored in the shared cache directory along with its MD5 build
signature. On subsequent builds, before an action is invoked to
build a file, <tt class="APPLICATION">SCons</tt> will check the
shared cache directory to see if a file with the exact same build
signature already exists. If so, the derived file will not be built
locally, but will be copied into the local build directory from the
shared cache directory, like so:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      % <tt class="USERINPUT"><b>scons -Q -c</b></tt>
      Removed hello.o
      Removed hello
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Retrieved `hello.o' from cache
      Retrieved `hello' from cache
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2753"></a>Keeping Build Output
Consistent</h1>

<p>&#13; One potential drawback to using a shared cache is that
your build output can be inconsistent from invocation to
invocation, because any given file may be rebuilt one time and
retrieved from the shared cache the next time. This can make
analyzing build output more difficult, especially for automated
scripts that expect consistent output each time.</p>

<p>&#13; If, however, you use the <tt class=
"LITERAL">--cache-show</tt> option, <tt class=
"APPLICATION">SCons</tt> will print the command line that it <i
class="EMPHASIS">would</i> have executed to build the file, even
when it is retrieving the file from the shared cache. This makes
the build output consistent every time the build is run:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      % <tt class="USERINPUT"><b>scons -Q -c</b></tt>
      Removed hello.o
      Removed hello
      % <tt class="USERINPUT"><b>scons -Q --cache-show</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; The trade-off, of course, is that you no longer know
whether or not <tt class="APPLICATION">SCons</tt> has retrieved a
derived file from cache or has rebuilt it locally.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2766"></a>Not Retrieving Files From
a Shared Cache</h1>

<p>&#13; Retrieving an already-built file from the shared cache is
usually a significant time-savings over rebuilding the file, but
how much of a savings (or even whether it saves time at all) can
depend a great deal on your system or network configuration. For
example, retrieving cached files from a busy server over a busy
network might end up being slower than rebuilding the files
locally.</p>

<p>&#13; In these cases, you can specify the <tt class=
"LITERAL">--cache-disable</tt> command-line option to tell <tt
class="APPLICATION">SCons</tt> to not retrieve already-built files
from the shared cache directory:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      % <tt class="USERINPUT"><b>scons -Q -c</b></tt>
      Removed hello.o
      Removed hello
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Retrieved `hello.o' from cache
      Retrieved `hello' from cache
      % <tt class="USERINPUT"><b>scons -Q -c</b></tt>
      Removed hello.o
      Removed hello
      % <tt class="USERINPUT"><b>scons -Q --cache-disable</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2778"></a>Populating a Shared Cache
With Already-Built Files</h1>

<p>&#13; Sometimes, you may have one or more derived files already
built in your local build tree that you wish to make available to
other people doing builds. For example, you may find it more
effective to perform integration builds with the cache disabled
(per the previous section) and only populate the shared cache
directory with the built files after the integration build has
completed successfully. This way, the cache will only get filled up
with derived files that are part of a complete, successful build
not with files that might be later overwritten while you debug
integration problems.</p>

<p>&#13; In this case, you can use the the <tt class=
"LITERAL">--cache-force</tt> option to tell <tt class=
"APPLICATION">SCons</tt> to put all derived files in the cache,
even if the files had already been built by a previous
invocation:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q --cache-disable</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      % <tt class="USERINPUT"><b>scons -Q -c</b></tt>
      Removed hello.o
      Removed hello
      % <tt class="USERINPUT"><b>scons -Q --cache-disable</b></tt>
      cc -c -o hello.o hello.c
      cc -o hello hello.o
      % <tt class="USERINPUT"><b>scons -Q --cache-force</b></tt>
      scons: `.' is up to date.
      % <tt class="USERINPUT"><b>scons -Q -c</b></tt>
      Removed hello.o
      Removed hello
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      Retrieved `hello.o' from cache
      Retrieved `hello' from cache
   
</pre>
</td>
</tr>
</table>

<p>&#13; Notice how the above sample run demonstrates that the <tt
class="LITERAL">--cache-disable</tt> option avoids putting the
built <tt class="FILENAME">hello.o</tt> and <tt class=
"FILENAME">hello</tt> files in the cache, but after using the <tt
class="LITERAL">--cache-force</tt> option, the files have been put
in the cache for the next invocation to retrieve.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-ALIAS"></a>Alias Targets</h1>

<p>&#13; We've already seen how you can use the <tt class=
"FUNCTION">Alias</tt> function to create a target named <tt class=
"LITERAL">install</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment()
     hello = env.Program('hello.c')
     env.Install('/usr/bin', hello)
     env.Alias('install', '/usr/bin')
 
</pre>
</td>
</tr>
</table>

<p>&#13; You can then use this alias on the command line to tell
<tt class="APPLICATION">SCons</tt> more naturally that you want to
install files:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
     % <tt class="USERINPUT"><b>scons -Q install</b></tt>
     cc -c -o hello.o hello.c
     cc -o hello hello.o
     Install file: "hello" as "/usr/bin/hello"
 
</pre>
</td>
</tr>
</table>

<p>&#13; Like other <tt class="CLASSNAME">Builder</tt> methods,
though, the <tt class="FUNCTION">Alias</tt> method returns an
object representing the alias being built. You can then use this
object as input to anothother <tt class="CLASSNAME">Builder</tt>.
This is especially useful if you use such an object as input to
another call to the <tt class="FUNCTION">Alias</tt> <tt class=
"CLASSNAME">Builder</tt>, allowing you to create a hierarchy of
nested aliases:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
     env = Environment()
     p = env.Program('foo.c')
     l = env.Library('bar.c')
     env.Install('/usr/bin', p)
     env.Install('/usr/lib', l)
     ib = env.Alias('install-bin', '/usr/bin')
     il = env.Alias('install-lib', '/usr/lib')
     env.Alias('install', [ib, il])
 
</pre>
</td>
</tr>
</table>

<p>&#13; This example defines separate <tt class=
"LITERAL">install</tt>, <tt class="LITERAL">install-bin</tt>, and
<tt class="LITERAL">install-lib</tt> aliases, allowing you finer
control over what gets installed:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
     % <tt class="USERINPUT"><b>scons -Q install-bin</b></tt>
     cc -c -o foo.o foo.c
     cc -o foo foo.o
     Install file: "foo" as "/usr/bin/foo"
     % <tt class="USERINPUT"><b>scons -Q install-lib</b></tt>
     cc -c -o bar.o bar.c
     ar r libbar.a bar.o
     ranlib libbar.a
     Install file: "libbar.a" as "/usr/lib/libbar.a"
     % <tt class="USERINPUT"><b>scons -Q -c /</b></tt>
     Removed foo.o
     Removed foo
     Removed /usr/bin/foo
     Removed bar.o
     Removed libbar.a
     Removed /usr/lib/libbar.a
     % <tt class="USERINPUT"><b>scons -Q install</b></tt>
     cc -c -o foo.o foo.c
     cc -o foo foo.o
     Install file: "foo" as "/usr/bin/foo"
     cc -c -o bar.o bar.c
     ar r libbar.a bar.o
     ranlib libbar.a
     Install file: "libbar.a" as "/usr/lib/libbar.a"
 
</pre>
</td>
</tr>
</table>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-JAVA"></a>Java Builds</h1>

<p>&#13; So far, we've been using examples of building C and C++
programs to demonstrate the features of <tt class=
"APPLICATION">SCons</tt>. <tt class="APPLICATION">SCons</tt> also
supports building Java programs, but Java builds are handled
slightly differently, which reflects the ways in which the Java
compiler and tools build programs differently than other languages'
tool chains.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2827"></a>Building Java Class
Files: the <tt class="FUNCTION">Java</tt> Builder</h1>

<p>&#13; The basic activity when programming in Java, of course, is
to take one or more <tt class="FILENAME">.java</tt> files
containing Java source code and to call the Java compiler to turn
them into one or more <tt class="FILENAME">.class</tt> files. In
<tt class="APPLICATION">SCons</tt>, you do this by giving the <a
href="#B-JAVA"><tt class="FUNCTION">Java</tt></a> Builder a target
directory in which to put the <tt class="FILENAME">.class</tt>
files, and a source directory that contains the <tt class=
"FILENAME">.java</tt> files:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Java('classes', 'src')
   
</pre>
</td>
</tr>
</table>

<p>&#13; If the <tt class="FILENAME">src</tt> directory contains
three <tt class="FILENAME">.java</tt> source files, then running
<tt class="APPLICATION">SCons</tt> might look like this:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath src src/Example1.java src/Example2.java src/Example3.java
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> will actually search
the <tt class="FILENAME">src</tt> directory tree for all of the <tt
class="FILENAME">.java</tt> files. The Java compiler will then
create the necessary class files in the <tt class=
"FILENAME">classes</tt> subdirectory, based on the class names
found in the <tt class="FILENAME">.java</tt> files.</p>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2851"></a>How <tt class=
"APPLICATION">SCons</tt> Handles Java Dependencies</h1>

<p>&#13; In addition to searching the source directory for <tt
class="FILENAME">.java</tt> files, <tt class=
"APPLICATION">SCons</tt> actually runs the <tt class=
"FILENAME">.java</tt> files through a stripped-down Java parser
that figures out what classes are defined. In other words, <tt
class="APPLICATION">SCons</tt> knows, without you having to tell
it, what <tt class="FILENAME">.class</tt> files will be produced by
the <tt class="APPLICATION">javac</tt> call. So our one-liner
example from the preceding section:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Java('classes', 'src')
   
</pre>
</td>
</tr>
</table>

<p>&#13; Will not only tell you reliably that the <tt class=
"FILENAME">.class</tt> files in the <tt class=
"FILENAME">classes</tt> subdirectory are up-to-date:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath src src/Example1.java src/Example2.java src/Example3.java
      % <tt class="USERINPUT"><b>scons -Q classes</b></tt>
      scons: `classes' is up to date.
   
</pre>
</td>
</tr>
</table>

<p>&#13; But it will also remove all of the generated <tt class=
"FILENAME">.class</tt> files, even for inner classes, without you
having to specify them manually. For example, if our <tt class=
"FILENAME">Example1.java</tt> and <tt class=
"FILENAME">Example3.java</tt> files both define additional classes,
and the class defined in <tt class="FILENAME">Example2.java</tt>
has an inner class, running <tt class="USERINPUT"><b>scons
-c</b></tt> will clean up all of those <tt class=
"FILENAME">.class</tt> files as well:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath src src/Example1.java src/Example2.java src/Example3.java
      % <tt class="USERINPUT"><b>scons -Q -c classes</b></tt>
      Removed classes/Example1.class
      Removed classes/AdditionalClass1.class
      Removed classes/Example2$Inner2.class
      Removed classes/Example2.class
      Removed classes/Example3.class
      Removed classes/AdditionalClass3.class
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2878"></a>Building Java Archive
(<tt class="FILENAME">.jar</tt>) Files: the <tt class=
"FUNCTION">Jar</tt> Builder</h1>

<p>&#13; After building the class files, it's common to collect
them into a Java archive (<tt class="FILENAME">.jar</tt>) file,
which you do by calling the <a href="#B-JAR"><tt class=
"FUNCTION">Jar</tt></a> Builder method. If you want to just collect
all of the class files within a subdirectory, you can just specify
that subdirectory as the <tt class="FUNCTION">Jar</tt> source:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Java(target = 'classes', source = 'src')
      Jar(target = 'test.jar', source = 'classes')
   
</pre>
</td>
</tr>
</table>

<p>&#13; <tt class="APPLICATION">SCons</tt> will then pass that
directory to the <tt class="APPLICATION">jar</tt> command, which
will collect all of the underlying <tt class="FILENAME">.class</tt>
files:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath src src/Example1.java src/Example2.java src/Example3.java
      jar cf test.jar classes
   
</pre>
</td>
</tr>
</table>

<p>&#13; If you want to keep all of the <tt class=
"FILENAME">.class</tt> files for multiple programs in one location,
and only archive some of them in each <tt class=
"FILENAME">.jar</tt> file, you can pass the <tt class=
"FUNCTION">Jar</tt> builder a list of files as its source. It's
extremely simple to create multiple <tt class="FILENAME">.jar</tt>
files this way, using the lists of target class files created by
calls to the <a href="#B-JAVA"><tt class="FUNCTION">Java</tt></a>
builder as sources to the various <tt class="FUNCTION">Jar</tt>
calls:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      prog1_class_files = Java(target = 'classes', source = 'prog1')
      prog2_class_files = Java(target = 'classes', source = 'prog2')
      Jar(target = 'prog1.jar', source = prog1_class_files)
      Jar(target = 'prog2.jar', source = prog2_class_files)
   
</pre>
</td>
</tr>
</table>

<p>&#13; This will then create <tt class="FILENAME">prog1.jar</tt>
and <tt class="FILENAME">prog2.jar</tt> next to the subdirectories
that contain their <tt class="FILENAME">.java</tt> files:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath prog1 prog1/Example1.java prog1/Example2.java
      javac -d classes -sourcepath prog2 prog2/Example3.java prog2/Example4.java
      jar cf prog1.jar classes/Example1.class classes/Example2.class
      jar cf prog2.jar classes/Example3.class classes/Example4.class
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2909"></a>Building C Header and
Stub Files: the <tt class="FUNCTION">JavaH</tt> Builder</h1>

<p>&#13; You can generate C header and source files for
implementing native methods, by using the <a href="#B-JAVAH"><tt
class="FUNCTION">JavaH</tt></a> Builder. There are several ways of
using the <tt class="FUNCTION">JavaH</tt> Builder. One typical
invocation might look like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      classes = Java(target = 'classes', source = 'src/pkg/sub')
      JavaH(target = 'native', source = classes)
   
</pre>
</td>
</tr>
</table>

<p>&#13; The source is a list of class files generated by the call
to the <a href="#B-JAVA"><tt class="FUNCTION">Java</tt></a>
Builder, and the target is the output directory in which we want
the C header files placed. The target gets converted into the <tt
class="OPTION">-d</tt> when <tt class="APPLICATION">SCons</tt> runs
<tt class="APPLICATION">javah</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath src/pkg/sub src/pkg/sub/Example1.java src/pkg/sub/Example2.java src/pkg/sub/Example3.java
      javah -d native -classpath classes pkg.sub.Example1 pkg.sub.Example2 pkg.sub.Example3
   
</pre>
</td>
</tr>
</table>

<p>&#13; In this case, the call to <tt class=
"APPLICATION">javah</tt> will generate the header files <tt class=
"FILENAME">native/pkg_sub_Example1.h</tt>, <tt class=
"FILENAME">native/pkg_sub_Example2.h</tt> and <tt class=
"FILENAME">native/pkg_sub_Example3.h</tt>. Notice that <tt class=
"APPLICATION">SCons</tt> remembered that the class files were
generated with a target directory of <tt class=
"FILENAME">classes</tt>, and that it then specified that target
directory as the <tt class="OPTION">-classpath</tt> option to the
call to <tt class="APPLICATION">javah</tt>.</p>

<p>&#13; Although it's more convenient to use the list of class
files returned by the <tt class="FUNCTION">Java</tt> Builder as the
source of a call to the <tt class="FUNCTION">JavaH</tt> Builder,
you <i class="EMPHASIS">can</i> specify the list of class files by
hand, if you prefer. If you do, you need to set the <a href=
"#CV-JAVACLASSDIR"><tt class="ENVAR">$JAVACLASSDIR</tt></a>
construction variable when calling <tt class=
"FUNCTION">JavaH</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      Java(target = 'classes', source = 'src/pkg/sub')
      class_file_list = ['classes/pkg/sub/Example1.class',
                         'classes/pkg/sub/Example2.class',
                         'classes/pkg/sub/Example3.class']
      JavaH(target = 'native', source = class_file_list, JAVACLASSDIR = 'classes')
   
</pre>
</td>
</tr>
</table>

<p>&#13; The <tt class="ENVAR">$JAVACLASSDIR</tt> value then gets
converted into the <tt class="OPTION">-classpath</tt> when <tt
class="APPLICATION">SCons</tt> runs <tt class=
"APPLICATION">javah</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath src/pkg/sub src/pkg/sub/Example1.java src/pkg/sub/Example2.java src/pkg/sub/Example3.java
      javah -d native -classpath classes pkg.sub.Example1 pkg.sub.Example2 pkg.sub.Example3
   
</pre>
</td>
</tr>
</table>

<p>&#13; Lastly, if you don't want a separate header file generated
for each source file, you can specify an explicit File Node as the
target of the <tt class="FUNCTION">JavaH</tt> Builder:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      classes = Java(target = 'classes', source = 'src/pkg/sub')
      JavaH(target = File('native.h'), source = classes)
   
</pre>
</td>
</tr>
</table>

<p>&#13; Because <tt class="APPLICATION">SCons</tt> assumes by
default that the target of the <tt class="FUNCTION">JavaH</tt>
builder is a directory, you need to use the <tt class=
"FUNCTION">File</tt> function to make sure that <tt class=
"APPLICATION">SCons</tt> doesn't create a directory named <tt
class="FILENAME">native.h</tt>. When a file is used, though, <tt
class="APPLICATION">SCons</tt> correctly converts the file name
into the <tt class="APPLICATION">javah</tt> <tt class=
"OPTION">-o</tt> option:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath src/pkg/sub src/pkg/sub/Example1.java src/pkg/sub/Example2.java src/pkg/sub/Example3.java
      javah -o native.h -classpath classes pkg.sub.Example1 pkg.sub.Example2 pkg.sub.Example3
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2963"></a>Building RMI Stub and
Skeleton Class Files: the <tt class="FUNCTION">RMIC</tt>
Builder</h1>

<p>&#13; You can generate Remote Method Invocation stubs by using
the <a href="#B-RMIC"><tt class="FUNCTION">RMIC</tt></a> Builder.
The source is a list of directories, typically returned by a call
to the <a href="#B-JAVA"><tt class="FUNCTION">Java</tt></a>
Builder, and the target is an output directory where the <tt class=
"FILENAME">_Stub.class</tt> and <tt class=
"FILENAME">_Skel.class</tt> files will be placed:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      classes = Java(target = 'classes', source = 'src/pkg/sub')
      RMIC(target = 'outdir', source = classes)
   
</pre>
</td>
</tr>
</table>

<p>&#13; As it did with the <a href="#B-JAVAH"><tt class=
"FUNCTION">JavaH</tt></a> Builder, <tt class=
"APPLICATION">SCons</tt> remembers the class directory and passes
it as the <tt class="OPTION">-classpath</tt> option to <tt class=
"APPLICATION">rmic</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      javac -d classes -sourcepath src/pkg/sub src/pkg/sub/Example1.java src/pkg/sub/Example2.java
      rmic -d outdir -classpath classes pkg.sub.Example1 pkg.sub.Example2
   
</pre>
</td>
</tr>
</table>

<p>&#13; This example would generate the files <tt class=
"FILENAME">outdir/pkg/sub/Example1_Skel.class</tt>, <tt class=
"FILENAME">outdir/pkg/sub/Example1_Stub.class</tt>, <tt class=
"FILENAME">outdir/pkg/sub/Example2_Skel.class</tt> and <tt class=
"FILENAME">outdir/pkg/sub/Example2_Stub.class</tt>.</p>
</div>
</div>

<div class="CHAPTER">
<hr>
<h1><a name="CHAP-TROUBLESHOOTING"></a>Troubleshooting</h1>

<p>&#13; The experience of configuring any software build tool to
build a large code base usually, at some point, involves trying to
figure out why the tool is behaving a certain way, and how to get
it to behave the way you want. <tt class="APPLICATION">SCons</tt>
is no different.</p>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN2991"></a>Why is That Target Being
Rebuilt? the <tt class="LITERAL">--debug=explain</tt> Option</h1>

<p>&#13; Let's take a simple example of a misconfigured build that
causes a target to be rebuilt every time <tt class=
"APPLICATION">SCons</tt> is run:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
      # Intentionally misspell the output file name in the
      # command used to create the file:
      Command('file.out', 'file.in', 'cp $SOURCE file.oout')
   
</pre>
</td>
</tr>
</table>

<p>&#13; (Note to Windows users: The POSIX <tt class=
"APPLICATION">cp</tt> command copies the first file named on the
command line to the second file. In our example, it copies the <tt
class="FILENAME">file.in</tt> file to the <tt class=
"FILENAME">file.out</tt> file.)</p>

<p>&#13; Now if we run <tt class="APPLICATION">SCons</tt> multiple
on this example, we see that it re-runs the <tt class=
"APPLICATION">cp</tt> command every time:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cp file.in file.oout
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cp file.in file.oout
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cp file.in file.oout
   
</pre>
</td>
</tr>
</table>

<p>&#13; In this example, the underlying cause is obvious: we've
intentionally misspelled the output file name in the <tt class=
"APPLICATION">cp</tt> command, so the command doesn't actually
build the <tt class="FILENAME">file.out</tt> file that we've told
<tt class="APPLICATION">SCons</tt> to expect. But if the problem
weren't obvious, it would be helpful to specify the <tt class=
"LITERAL">--debug=explain</tt> option on the command line to have
<tt class="APPLICATION">SCons</tt> tell us very specifically why
it's decided to rebuild the target:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q --debug=explain</b></tt>
      scons: building `file.out' because it doesn't exist
      cp file.in file.oout
   
</pre>
</td>
</tr>
</table>

<p>&#13; If this had been a more complicated example involving a
lot of build output, having <tt class="APPLICATION">SCons</tt> tell
us that it's trying to rebuild the target file because it doesn't
exist would be an important clue that something was wrong with the
command that we invoked to build it.</p>

<p>&#13; The <tt class="LITERAL">--debug=explain</tt> option also
comes in handy to help figure out what input file changed. Given a
simple configuration that builds a program from three source files,
changing one of the source files and rebuilding with the <tt class=
"LITERAL">--debug=explain</tt> option shows very specifically why
<tt class="APPLICATION">SCons</tt> rebuilds the files that it
does:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -c -o file1.o file1.c
      cc -c -o file2.o file2.c
      cc -c -o file3.o file3.c
      cc -o prog file1.o file2.o file3.o
      % <tt class="USERINPUT"><b>edit file2.c</b></tt>
          [CHANGE THE CONTENTS OF file2.c]
      % <tt class="USERINPUT"><b>scons -Q --debug=explain</b></tt>
      scons: rebuilding `file2.o' because `file2.c' changed
      cc -c -o file2.o file2.c
      scons: rebuilding `prog' because `file2.o' changed
      cc -o prog file1.o file2.o file3.o
   
</pre>
</td>
</tr>
</table>

<p>&#13; This becomes even more helpful in identifying when a file
is rebuilt due to a change in an implicit dependency, such as an
incuded <tt class="FILENAME">.h</tt> file. If the <tt class=
"FILENAME">file1.c</tt> and <tt class="FILENAME">file3.c</tt> files
in our example both included a <tt class="FILENAME">hello.h</tt>
file, then changing that included file and re-running <tt class=
"APPLICATION">SCons</tt> with the <tt class=
"LITERAL">--debug=explain</tt> option will pinpoint that it's the
change to the included file that starts the chain of rebuilds:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons -Q</b></tt>
      cc -I. -c -o file1.o file1.c
      cc -I. -c -o file2.o file2.c
      cc -I. -c -o file3.o file3.c
      cc -o prog file1.o file2.o file3.o
      % <tt class="USERINPUT"><b>edit hello.h</b></tt>
          [CHANGE THE CONTENTS OF hello.h]
      % <tt class="USERINPUT"><b>scons -Q --debug=explain</b></tt>
      scons: rebuilding `file1.o' because `hello.h' changed
      cc -I. -c -o file1.o file1.c
      scons: rebuilding `file3.o' because `hello.h' changed
      cc -I. -c -o file3.o file3.c
      scons: rebuilding `prog' because:
                 `file1.o' changed
                 `file3.o' changed
      cc -o prog file1.o file2.o file3.o
   
</pre>
</td>
</tr>
</table>
</div>

<div class="SECTION">
<hr>
<h1 class="SECTION"><a name="AEN3037"></a>What's in That
Construction Environment? the <tt class="FUNCTION">Dump</tt>
Method</h1>

<p>&#13; When you create a construction environment, <tt class=
"APPLICATION">SCons</tt> populates it with construction variables
that are set up for various compilers, linkers and utilities that
it finds on your system. Although this is usually helpful and what
you want, it might be frustrating if <tt class=
"APPLICATION">SCons</tt> doesn't set certain variables that you
expect to be sit. In situations like this, it's sometimes helpful
to use the construction environment <tt class="FUNCTION">Dump</tt>
method to print all or some of the construction variables. Note
that the <tt class="FUNCTION">Dump</tt> method <i class=
"EMPHASIS">returns</i> the representation of the variables in the
environment for you to print (or otherwise manipulate):</p>

<p>&#13; On a POSIX system with gcc installed, this might
generate:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      { 'BUILDERS': {},
        'CPPSUFFIXES': [ '.c',
                         '.C',
                         '.cxx',
                         '.cpp',
                         '.c++',
                         '.cc',
                         '.h',
                         '.H',
                         '.hxx',
                         '.hpp',
                         '.hh',
                         '.F',
                         '.fpp',
                         '.FPP',
                         '.S',
                         '.spp',
                         '.SPP'],
        'DSUFFIXES': ['.d'],
        'Dir': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829dcb4&gt;,
        'ENV': {'PATH': '/usr/local/bin:/bin:/usr/bin'},
        'ESCAPE': &lt;function escape at 0x837d2a4&gt;,
        'File': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829e0fc&gt;,
        'IDLSUFFIXES': ['.idl', '.IDL'],
        'INSTALL': &lt;function copyFunc at 0x829db9c&gt;,
        'LIBPREFIX': 'lib',
        'LIBPREFIXES': '$LIBPREFIX',
        'LIBSUFFIX': '.a',
        'LIBSUFFIXES': ['$LIBSUFFIX', '$SHLIBSUFFIX'],
        'OBJPREFIX': '',
        'OBJSUFFIX': '.o',
        'PDFPREFIX': '',
        'PDFSUFFIX': '.pdf',
        'PLATFORM': 'posix',
        'PROGPREFIX': '',
        'PROGSUFFIX': '',
        'PSPAWN': &lt;function piped_env_spawn at 0x837d384&gt;,
        'PSPREFIX': '',
        'PSSUFFIX': '.ps',
        'RDirs': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829e46c&gt;,
        'SCANNERS': [],
        'SHELL': 'sh',
        'SHLIBPREFIX': '$LIBPREFIX',
        'SHLIBSUFFIX': '.so',
        'SHOBJPREFIX': '$OBJPREFIX',
        'SHOBJSUFFIX': '$OBJSUFFIX',
        'SPAWN': &lt;function spawnvpe_spawn at 0x8377fdc&gt;,
        'TEMPFILE': &lt;class SCons.Defaults.NullCmdGenerator at 0x829ddec&gt;,
        'TOOLS': [],
        '_CPPDEFFLAGS': '${_defines(CPPDEFPREFIX, CPPDEFINES, CPPDEFSUFFIX, __env__)}',
        '_CPPINCFLAGS': '$( ${_concat(INCPREFIX, CPPPATH, INCSUFFIX, __env__, RDirs, TARGET)} $)',
        '_LIBDIRFLAGS': '$( ${_concat(LIBDIRPREFIX, LIBPATH, LIBDIRSUFFIX, __env__, RDirs, TARGET)} $)',
        '_LIBFLAGS': '${_concat(LIBLINKPREFIX, LIBS, LIBLINKSUFFIX, __env__)}',
        '__RPATH': '$_RPATH',
        '_concat': &lt;function _concat at 0x829dc0c&gt;,
        '_defines': &lt;function _defines at 0x829dc7c&gt;,
        '_stripixes': &lt;function _stripixes at 0x829dc44&gt;}
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
   
</pre>
</td>
</tr>
</table>

<p>&#13; On a Windows system with Visual C++ the output might look
like:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      { 'BUILDERS': {'Object': &lt;SCons.Memoize.MultiStepBuilder object at 0x83493e4&gt;, 'SharedObject': &lt;SCons.Memoize.MultiStepBuilder object at 0x8349fec&gt;, 'StaticObject': &lt;SCons.Memoize.MultiStepBuilder object at 0x83493e4&gt;, 'PCH': &lt;SCons.Memoize.BuilderBase object at 0x83418cc&gt;, 'RES': &lt;SCons.Memoize.BuilderBase object at 0x8367cec&gt;},
        'CC': 'cl',
        'CCCOM': &lt;SCons.Memoize.FunctionAction object at 0x8340454&gt;,
        'CCCOMFLAGS': '$CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS /c $SOURCES /Fo$TARGET $CCPCHFLAGS $CCPDBFLAGS',
        'CCFLAGS': ['/nologo'],
        'CCPCHFLAGS': ['${(PCH and "/Yu%s /Fp%s"%(PCHSTOP or "",File(PCH))) or ""}'],
        'CCPDBFLAGS': ['${(PDB and "/Z7") or ""}'],
        'CFILESUFFIX': '.c',
        'CPPDEFPREFIX': '/D',
        'CPPDEFSUFFIX': '',
        'CPPSUFFIXES': [ '.c',
                         '.C',
                         '.cxx',
                         '.cpp',
                         '.c++',
                         '.cc',
                         '.h',
                         '.H',
                         '.hxx',
                         '.hpp',
                         '.hh',
                         '.F',
                         '.fpp',
                         '.FPP',
                         '.S',
                         '.spp',
                         '.SPP'],
        'CXX': '$CC',
        'CXXCOM': '$CXX $CXXFLAGS $CCCOMFLAGS',
        'CXXFILESUFFIX': '.cc',
        'CXXFLAGS': ['$CCFLAGS', '$(', '/TP', '$)'],
        'DSUFFIXES': ['.d'],
        'Dir': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829dcb4&gt;,
        'ENV': { 'INCLUDE': 'C:\\Program Files\\Microsoft Visual Studio/VC98\\include',
                 'LIB': 'C:\\Program Files\\Microsoft Visual Studio/VC98\\lib',
                 'PATH': 'C:\\Program Files\\Microsoft Visual Studio\\Common\\tools\\WIN95;C:\\Program Files\\Microsoft Visual Studio\\Common\\MSDev98\\bin;C:\\Program Files\\Microsoft Visual Studio\\Common\\tools;C:\\Program Files\\Microsoft Visual Studio/VC98\\bin',
                 'PATHEXT': '.COM;.EXE;.BAT;.CMD'},
        'ESCAPE': &lt;function &lt;lambda&gt; at 0x82339ec&gt;,
        'File': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829e0fc&gt;,
        'IDLSUFFIXES': ['.idl', '.IDL'],
        'INCPREFIX': '/I',
        'INCSUFFIX': '',
        'INSTALL': &lt;function copyFunc at 0x829db9c&gt;,
        'LIBPREFIX': '',
        'LIBPREFIXES': ['$LIBPREFIX'],
        'LIBSUFFIX': '.lib',
        'LIBSUFFIXES': ['$LIBSUFFIX'],
        'MAXLINELENGTH': 2048,
        'MSVS': {'VERSION': '6.0', 'VERSIONS': ['6.0']},
        'MSVS_VERSION': '6.0',
        'OBJPREFIX': '',
        'OBJSUFFIX': '.obj',
        'PCHCOM': '$CXX $CXXFLAGS $CPPFLAGS $_CPPDEFFLAGS $_CPPINCFLAGS /c $SOURCES /Fo${TARGETS[1]} /Yc$PCHSTOP /Fp${TARGETS[0]} $CCPDBFLAGS $PCHPDBFLAGS',
        'PCHPDBFLAGS': ['${(PDB and "/Yd") or ""}'],
        'PDFPREFIX': '',
        'PDFSUFFIX': '.pdf',
        'PLATFORM': 'win32',
        'PROGPREFIX': '',
        'PROGSUFFIX': '.exe',
        'PSPAWN': &lt;function piped_spawn at 0x8372bc4&gt;,
        'PSPREFIX': '',
        'PSSUFFIX': '.ps',
        'RC': 'rc',
        'RCCOM': '$RC $_CPPDEFFLAGS $_CPPINCFLAGS $RCFLAGS /fo$TARGET $SOURCES',
        'RCFLAGS': [],
        'RDirs': &lt;SCons.Defaults.Variable_Method_Caller instance at 0x829e46c&gt;,
        'SCANNERS': [],
        'SHCC': '$CC',
        'SHCCCOM': &lt;SCons.Memoize.FunctionAction object at 0x83494bc&gt;,
        'SHCCFLAGS': ['$CCFLAGS'],
        'SHCXX': '$CXX',
        'SHCXXCOM': '$SHCXX $SHCXXFLAGS $CCCOMFLAGS',
        'SHCXXFLAGS': ['$CXXFLAGS'],
        'SHELL': None,
        'SHLIBPREFIX': '',
        'SHLIBSUFFIX': '.dll',
        'SHOBJPREFIX': '$OBJPREFIX',
        'SHOBJSUFFIX': '$OBJSUFFIX',
        'SPAWN': &lt;function spawn at 0x8374c34&gt;,
        'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME': 1,
        'TEMPFILE': &lt;class SCons.Platform.win32.TempFileMunge at 0x835edc4&gt;,
        'TOOLS': ['msvc'],
        '_CPPDEFFLAGS': '${_defines(CPPDEFPREFIX, CPPDEFINES, CPPDEFSUFFIX, __env__)}',
        '_CPPINCFLAGS': '$( ${_concat(INCPREFIX, CPPPATH, INCSUFFIX, __env__, RDirs, TARGET)} $)',
        '_LIBDIRFLAGS': '$( ${_concat(LIBDIRPREFIX, LIBPATH, LIBDIRSUFFIX, __env__, RDirs, TARGET)} $)',
        '_LIBFLAGS': '${_concat(LIBLINKPREFIX, LIBS, LIBLINKSUFFIX, __env__)}',
        '_concat': &lt;function _concat at 0x829dc0c&gt;,
        '_defines': &lt;function _defines at 0x829dc7c&gt;,
        '_stripixes': &lt;function _stripixes at 0x829dc44&gt;}
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
   
</pre>
</td>
</tr>
</table>

<p>&#13; The construction environments in these examples have
actually been restricted to just gcc and Visual C++, respectively.
In a real-life situation, the construction environments will likely
contain a great many more variables.</p>

<p>&#13; To make it easier to see just what you're interested in,
the <tt class="FUNCTION">Dump</tt> method allows you to specify a
specific constrcution variable that you want to disply. For
example, it's not unusual to want to verify the external
environment used to execute build commands, to make sure that the
PATH and other environment variables are set up the way they should
be. You can do this as follows:</p>

<p>&#13; Which might display the following when executed on a POSIX
system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      % <tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      {'PATH': '/usr/local/bin:/bin:/usr/bin'}
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
   
</pre>
</td>
</tr>
</table>

<p>&#13; And the following when executed on a Windows system:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="SCREEN">
      C:\&gt;<tt class="USERINPUT"><b>scons</b></tt>
      scons: Reading SConscript files ...
      { 'INCLUDE': 'C:\\Program Files\\Microsoft Visual Studio/VC98\\include',
        'LIB': 'C:\\Program Files\\Microsoft Visual Studio/VC98\\lib',
        'PATH': 'C:\\Program Files\\Microsoft Visual Studio\\Common\\tools\\WIN95;C:\\Program Files\\Microsoft Visual Studio\\Common\\MSDev98\\bin;C:\\Program Files\\Microsoft Visual Studio\\Common\\tools;C:\\Program Files\\Microsoft Visual Studio/VC98\\bin',
        'PATHEXT': '.COM;.EXE;.BAT;.CMD'}
      scons: done reading SConscript files.
      scons: Building targets ...
      scons: `.' is up to date.
      scons: done building targets.
   
</pre>
</td>
</tr>
</table>
</div>
</div>

<div class="APPENDIX">
<hr>
<h1><a name="APP-VARIABLES"></a>Construction Variables</h1>

<p>&#13;This appendix contains descriptions of all of the
construction variables that are <i class="EMPHASIS">potentially</i>
available "out of the box" in this version of SCons. Whether or not
setting a construction variable in a construction environment will
actually have an effect depends on whether any of the Tools and/or
Builders that use the variable have been included in the
construction environment.&#13;</p>

<p>&#13;In this appendix, we have appended the initial <tt class=
"ENVAR">$</tt> (dollar sign) to the beginning of each variable name
when it appears in the text, but left off the dollar sign in the
left-hand column where the name appears for each entry.&#13;</p>

<div class="VARIABLELIST">
<dl>
<dt><a name="CV-AR"></a><tt class="ENVAR">AR</tt></dt>

<dd>
<p>The static library archiver.</p>
</dd>

<dt><a name="CV-ARCOM"></a><tt class="ENVAR">ARCOM</tt></dt>

<dd>
<p>The command line used to generate a static library from object
files.</p>
</dd>

<dt><a name="CV-ARCOMSTR"></a><tt class="ENVAR">ARCOMSTR</tt></dt>

<dd>
<p>The string displayed when an object file is generated from an
assembly-language source file. If this is not set, then <tt class=
"ENVAR">$ARCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(ARCOMSTR = "Archiving $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-ARFLAGS"></a><tt class="ENVAR">ARFLAGS</tt></dt>

<dd>
<p>General options passed to the static library archiver.</p>
</dd>

<dt><a name="CV-AS"></a><tt class="ENVAR">AS</tt></dt>

<dd>
<p>The assembler.</p>
</dd>

<dt><a name="CV-ASCOM"></a><tt class="ENVAR">ASCOM</tt></dt>

<dd>
<p>The command line used to generate an object file from an
assembly-language source file.</p>
</dd>

<dt><a name="CV-ASCOMSTR"></a><tt class="ENVAR">ASCOMSTR</tt></dt>

<dd>
<p>The string displayed when an object file is generated from an
assembly-language source file. If this is not set, then <tt class=
"ENVAR">$ASCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(ASCOMSTR = "Assembling $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-ASFLAGS"></a><tt class="ENVAR">ASFLAGS</tt></dt>

<dd>
<p>General options passed to the assembler.</p>
</dd>

<dt><a name="CV-ASPPCOM"></a><tt class="ENVAR">ASPPCOM</tt></dt>

<dd>
<p>The command line used to assemble an assembly-language source
file into an object file after first running the file through the C
preprocessor. Any options specified in the <tt class=
"ENVAR">$ASFLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line.</p>
</dd>

<dt><a name="CV-ASPPCOMSTR"></a><tt class=
"ENVAR">ASPPCOMSTR</tt></dt>

<dd>
<p>The string displayed when an object file is generated from an
assembly-language source file after first running the file through
the C preprocessor. If this is not set, then <tt class=
"ENVAR">$ASPPCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(ASPPCOMSTR = "Assembling $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-ASPPFLAGS"></a><tt class=
"ENVAR">ASPPFLAGS</tt></dt>

<dd>
<p>General options when an assembling an assembly-language source
file into an object file after first running the file through the C
preprocessor. The default is to use the value of <tt class=
"ENVAR">$ASFLAGS</tt>.</p>
</dd>

<dt><a name="CV-BIBTEX"></a><tt class="ENVAR">BIBTEX</tt></dt>

<dd>
<p>The bibliography generator for the TeX formatter and typesetter
and the LaTeX structured formatter and typesetter.</p>
</dd>

<dt><a name="CV-BIBTEXCOM"></a><tt class=
"ENVAR">BIBTEXCOM</tt></dt>

<dd>
<p>The command line used to call the bibliography generator for the
TeX formatter and typesetter and the LaTeX structured formatter and
typesetter.</p>
</dd>

<dt><a name="CV-BIBTEXCOMSTR"></a><tt class=
"ENVAR">BIBTEXCOMSTR</tt></dt>

<dd>
<p>The string displayed when generating a bibliography for TeX or
LaTeX. If this is not set, then <tt class="ENVAR">$BIBTEXCOM</tt>
(the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(BIBTEXCOMSTR = "Generating bibliography $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-BIBTEXFLAGS"></a><tt class=
"ENVAR">BIBTEXFLAGS</tt></dt>

<dd>
<p>General options passed to the bibliography generator for the TeX
formatter and typesetter and the LaTeX structured formatter and
typesetter.</p>
</dd>

<dt><a name="CV-BITKEEPER"></a><tt class=
"ENVAR">BITKEEPER</tt></dt>

<dd>
<p>The BitKeeper executable.</p>
</dd>

<dt><a name="CV-BITKEEPERCOM"></a><tt class=
"ENVAR">BITKEEPERCOM</tt></dt>

<dd>
<p>The command line for fetching source files using BitKEeper.</p>
</dd>

<dt><a name="CV-BITKEEPERCOMSTR"></a><tt class=
"ENVAR">BITKEEPERCOMSTR</tt></dt>

<dd>
<p>The string displayed when fetching a source file using
BitKeeper. If this is not set, then <tt class=
"ENVAR">$BITKEEPERCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-BITKEEPERGET"></a><tt class=
"ENVAR">BITKEEPERGET</tt></dt>

<dd>
<p>The command (<tt class="ENVAR">$BITKEEPER</tt>) and subcommand
for fetching source files using BitKeeper.</p>
</dd>

<dt><a name="CV-BITKEEPERGETFLAGS"></a><tt class=
"ENVAR">BITKEEPERGETFLAGS</tt></dt>

<dd>
<p>Options that are passed to the BitKeeper <b class=
"COMMAND">get</b> subcommand.</p>
</dd>

<dt><a name="CV-BUILDERS"></a><tt class="ENVAR">BUILDERS</tt></dt>

<dd>
<p>A dictionary mapping the names of the builders available through
this environment to underlying Builder objects. Builders named
Alias, CFile, CXXFile, DVI, Library, Object, PDF, PostScript, and
Program are available by default. If you initialize this variable
when an Environment is created:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(BUILDERS = {'NewBuilder' : foo})
</pre>
</td>
</tr>
</table>

<p>the default Builders will no longer be available. To use a new
Builder object in addition to the default Builders, add your new
Builder object like this:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment()
env.Append(BUILDERS = {'NewBuilder' : foo})
</pre>
</td>
</tr>
</table>

<p>or this:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment()
env['BUILDERS]['NewBuilder'] = foo
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-CC"></a><tt class="ENVAR">CC</tt></dt>

<dd>
<p>The C compiler.</p>
</dd>

<dt><a name="CV-CCCOM"></a><tt class="ENVAR">CCCOM</tt></dt>

<dd>
<p>The command line used to compile a C source file to a (static)
object file. Any options specified in the <tt class=
"ENVAR">$CCFLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line.</p>
</dd>

<dt><a name="CV-CCCOMSTR"></a><tt class="ENVAR">CCCOMSTR</tt></dt>

<dd>
<p>The string displayed when a C source file is compiled to a
(static) object file. If this is not set, then <tt class=
"ENVAR">$CCCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(CCCOMSTR = "Compiling static object $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-CCFLAGS"></a><tt class="ENVAR">CCFLAGS</tt></dt>

<dd>
<p>General options that are passed to the C compiler.</p>
</dd>

<dt><a name="CV-CCVERSION"></a><tt class=
"ENVAR">CCVERSION</tt></dt>

<dd>
<p>The version number of the C compiler. This may or may not be
set, depending on the specific C compiler being used.</p>
</dd>

<dt><a name="CV-CFILESUFFIX"></a><tt class=
"ENVAR">CFILESUFFIX</tt></dt>

<dd>
<p>The suffix for C source files. This is used by the internal
CFile builder when generating C files from Lex (.l) or YACC (.y)
input files. The default suffix, of course, is <tt class=
"FILENAME">.c</tt> (lower case). On case-insensitive systems (like
Win32), SCons also treats <tt class="FILENAME">.C</tt> (upper case)
files as C files.</p>
</dd>

<dt><a name="CV-_CONCAT"></a><tt class="ENVAR">_concat</tt></dt>

<dd>
<p>A function used to produce variables like <tt class=
"ENVAR">$_CPPINCFLAGS</tt>. It takes four or five arguments: a
prefix to concatenate onto each element, a list of elements, a
suffix to concatenate onto each element, an environment for
variable interpolation, and an optional function that will be
called to transform the list before concatenation.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env['_CPPINCFLAGS'] = '$( ${_concat(INCPREFIX, CPPPATH, INCSUFFIX, __env__, RDirs)} $)',
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-_CPPDEFFLAGS"></a><tt class=
"ENVAR">_CPPDEFFLAGS</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
C preprocessor command-line options to define values. The value of
<tt class="ENVAR">$_CPPDEFFLAGS</tt> is created by appending <tt
class="ENVAR">$CPPDEFPREFIX</tt> and <tt class=
"ENVAR">$CPPDEFSUFFIX</tt> to the beginning and end of each
directory in <tt class="ENVAR">$CPPDEFINES</tt>.</p>
</dd>

<dt><a name="CV-CPPDEFINES"></a><tt class=
"ENVAR">CPPDEFINES</tt></dt>

<dd>
<p>A platform independent specification of C preprocessor
definitions. The definitions will be added to command lines through
the automatically-generated <tt class="ENVAR">$_CPPDEFFLAGS</tt>
construction variable (see below), which is constructed according
to the type of value of <tt class="ENVAR">$CPPDEFINES</tt>:</p>

<p>If <tt class="ENVAR">$CPPDEFINES</tt> is a string, the values of
the <tt class="ENVAR">$CPPDEFPREFIX</tt> and <tt class=
"ENVAR">$CPPDEFSUFFIX</tt> construction variables will be added to
the beginning and end.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# Will add -Dxyz to POSIX compiler command lines,
# and /Dxyz to Microsoft Visual C++ command lines.
env = Environment(CPPDEFINES='xyz')
</pre>
</td>
</tr>
</table>

<p>If <tt class="ENVAR">$CPPDEFINES</tt> is a list, the values of
the <tt class="ENVAR">$CPPDEFPREFIX</tt> and <tt class=
"ENVAR">$CPPDEFSUFFIX</tt> construction variables will be appended
to the beginning and end of each element in the list. If any
element is a list or tuple, then the first item is the name being
defined and the second item is its value:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# Will add -DB=2 -DA to POSIX compiler command lines,
# and /DB=2 /DA to Microsoft Visual C++ command lines.
env = Environment(CPPDEFINES=[('B', 2), 'A'])
</pre>
</td>
</tr>
</table>

<p>If <tt class="ENVAR">$CPPDEFINES</tt> is a dictionary, the
values of the <tt class="ENVAR">$CPPDEFPREFIX</tt> and <tt class=
"ENVAR">$CPPDEFSUFFIX</tt> construction variables will be appended
to the beginning and end of each item from the dictionary. The key
of each dictionary item is a name being defined to the dictionary
item's corresponding value; if the value is <tt class=
"LITERAL">None</tt>, then the name is defined without an explicit
value. Note that the resulting flags are sorted by keyword to
ensure that the order of the options on the command line is
consistent each time <tt class="APPLICATION">scons</tt> is run.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# Will add -DA -DB=2 to POSIX compiler command lines,
# and /DA /DB=2 to Microsoft Visual C++ command lines.
env = Environment(CPPDEFINES={'B':2, 'A':None})
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-CPPDEFPREFIX"></a><tt class=
"ENVAR">CPPDEFPREFIX</tt></dt>

<dd>
<p>The prefix used to specify preprocessor definitions on the C
compiler command line. This will be appended to the beginning of
each definition in the <tt class="ENVAR">$CPPDEFINES</tt>
construction variable when the <tt class="ENVAR">$_CPPDEFFLAGS</tt>
variable is automatically generated.</p>
</dd>

<dt><a name="CV-CPPDEFSUFFIX"></a><tt class=
"ENVAR">CPPDEFSUFFIX</tt></dt>

<dd>
<p>The suffix used to specify preprocessor definitions on the C
compiler command line. This will be appended to the end of each
definition in the <tt class="ENVAR">$CPPDEFINES</tt> construction
variable when the <tt class="ENVAR">$_CPPDEFFLAGS</tt> variable is
automatically generated.</p>
</dd>

<dt><a name="CV-CPPFLAGS"></a><tt class="ENVAR">CPPFLAGS</tt></dt>

<dd>
<p>User-specified C preprocessor options. These will be included in
any command that uses the C preprocessor, including not just
compilation of C and C++ source files via the <tt class=
"ENVAR">$CCCOM</tt>, <tt class="ENVAR">$SHCCCOM</tt>, <tt class=
"ENVAR">$CXXCOM</tt> and <tt class="ENVAR">$SHCXXCOM</tt> command
lines, but also the <tt class="ENVAR">$FORTRANPPCOM</tt>, <tt
class="ENVAR">$SHFORTRANPPCOM</tt>, <tt class=
"ENVAR">$F77PPCOM</tt> and <tt class="ENVAR">$SHF77PPCOM</tt>
command lines used to compile a Fortran source file, and the <tt
class="ENVAR">$ASPPCOM</tt> command line used to assemble an
assembly language source file, after first running each file
through the C preprocessor. Note that this variable does <i class=
"EMPHASIS">not</i> contain <tt class="OPTION">-I</tt> (or similar)
include search path options that scons generates automatically from
<tt class="ENVAR">$CPPPATH</tt>. See <a href="#CV-_CPPINCFLAGS"><tt
class="ENVAR">$_CPPINCFLAGS</tt></a>, below, for the variable that
expands to those options.</p>
</dd>

<dt><a name="CV-_CPPINCFLAGS"></a><tt class=
"ENVAR">_CPPINCFLAGS</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
C preprocessor command-line options for specifying directories to
be searched for include files. The value of <tt class=
"ENVAR">$_CPPINCFLAGS</tt> is created by appending <tt class=
"ENVAR">$INCPREFIX</tt> and <tt class="ENVAR">$INCSUFFIX</tt> to
the beginning and end of each directory in <tt class=
"ENVAR">$CPPPATH</tt>.</p>
</dd>

<dt><a name="CV-CPPPATH"></a><tt class="ENVAR">CPPPATH</tt></dt>

<dd>
<p>The list of directories that the C preprocessor will search for
include directories. The C/C++ implicit dependency scanner will
search these directories for include files. Don't explicitly put
include directory arguments in CCFLAGS or CXXFLAGS because the
result will be non-portable and the directories will not be
searched by the dependency scanner. Note: directory names in
CPPPATH will be looked-up relative to the SConscript directory when
they are used in a command. To force <tt class=
"APPLICATION">scons</tt> to look-up a directory relative to the
root of the source tree use #:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(CPPPATH='#/include')
</pre>
</td>
</tr>
</table>

<p>The directory look-up can also be forced using the <tt class=
"FUNCTION">Dir</tt>() function:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
include = Dir('include')
env = Environment(CPPPATH=include)
</pre>
</td>
</tr>
</table>

<p>The directory list will be added to command lines through the
automatically-generated <tt class="ENVAR">$_CPPINCFLAGS</tt>
construction variable, which is constructed by appending the values
of the <tt class="ENVAR">$INCPREFIX</tt> and <tt class=
"ENVAR">$INCSUFFIX</tt> construction variables to the beginning and
end of each directory in <tt class="ENVAR">$CPPPATH</tt>. Any
command lines you define that need the CPPPATH directory list
should include <tt class="ENVAR">$_CPPINCFLAGS</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(CCCOM="my_compiler $_CPPINCFLAGS -c -o $TARGET $SOURCE")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-CPPSUFFIXES"></a><tt class=
"ENVAR">CPPSUFFIXES</tt></dt>

<dd>
<p>The list of suffixes of files that will be scanned for C
preprocessor implicit dependencies (#include lines). The default
list is:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
[".c", ".C", ".cxx", ".cpp", ".c++", ".cc",
 ".h", ".H", ".hxx", ".hpp", ".hh",
 ".F", ".fpp", ".FPP",
 ".S", ".spp", ".SPP"]
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-CVS"></a><tt class="ENVAR">CVS</tt></dt>

<dd>
<p>The CVS executable.</p>
</dd>

<dt><a name="CV-CVSCOFLAGS"></a><tt class=
"ENVAR">CVSCOFLAGS</tt></dt>

<dd>
<p>Options that are passed to the CVS checkout subcommand.</p>
</dd>

<dt><a name="CV-CVSCOM"></a><tt class="ENVAR">CVSCOM</tt></dt>

<dd>
<p>The command line used to fetch source files from a CVS
repository.</p>
</dd>

<dt><a name="CV-CVSCOMSTR"></a><tt class=
"ENVAR">CVSCOMSTR</tt></dt>

<dd>
<p>The string displayed when fetching a source file from a CVS
repository. If this is not set, then <tt class="ENVAR">$CVSCOM</tt>
(the command line) is displayed.</p>
</dd>

<dt><a name="CV-CVSFLAGS"></a><tt class="ENVAR">CVSFLAGS</tt></dt>

<dd>
<p>General options that are passed to CVS. By default, this is set
to <tt class="LITERAL">-d $CVSREPOSITORY</tt> to specify from where
the files must be fetched.</p>
</dd>

<dt><a name="CV-CVSREPOSITORY"></a><tt class=
"ENVAR">CVSREPOSITORY</tt></dt>

<dd>
<p>The path to the CVS repository. This is referenced in the
default <tt class="ENVAR">$CVSFLAGS</tt> value.</p>
</dd>

<dt><a name="CV-CXX"></a><tt class="ENVAR">CXX</tt></dt>

<dd>
<p>The C++ compiler.</p>
</dd>

<dt><a name="CV-CXXCOM"></a><tt class="ENVAR">CXXCOM</tt></dt>

<dd>
<p>The command line used to compile a C++ source file to an object
file. Any options specified in the <tt class="ENVAR">$CXXFLAGS</tt>
and <tt class="ENVAR">$CPPFLAGS</tt> construction variables are
included on this command line.</p>
</dd>

<dt><a name="CV-CXXCOMSTR"></a><tt class=
"ENVAR">CXXCOMSTR</tt></dt>

<dd>
<p>The string displayed when a C++ source file is compiled to a
(static) object file. If this is not set, then <tt class=
"ENVAR">$CXXCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(CXXCOMSTR = "Compiling static object $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-CXXFILESUFFIX"></a><tt class=
"ENVAR">CXXFILESUFFIX</tt></dt>

<dd>
<p>The suffix for C++ source files. This is used by the internal
CXXFile builder when generating C++ files from Lex (.ll) or YACC
(.yy) input files. The default suffix is <tt class=
"FILENAME">.cc</tt>. SCons also treats files with the suffixes <tt
class="FILENAME">.cpp</tt>, <tt class="FILENAME">.cxx</tt>, <tt
class="FILENAME">.c++</tt>, and <tt class="FILENAME">.C++</tt> as
C++ files. On case-sensitive systems (Linux, UNIX, and other
POSIX-alikes), SCons also treats <tt class="FILENAME">.C</tt>
(upper case) files as C++ files.</p>
</dd>

<dt><a name="CV-CXXFLAGS"></a><tt class="ENVAR">CXXFLAGS</tt></dt>

<dd>
<p>General options that are passed to the C++ compiler. By default,
this includes the value of <tt class="ENVAR">$CCFLAGS</tt>, so that
setting <tt class="ENVAR">$CCFLAGS</tt> affects both C and C++
compilation. If you want to add C++-specific flags, you must set or
override the value of <tt class="ENVAR">$CXXFLAGS</tt>.</p>
</dd>

<dt><a name="CV-CXXVERSION"></a><tt class=
"ENVAR">CXXVERSION</tt></dt>

<dd>
<p>The version number of the C++ compiler. This may or may not be
set, depending on the specific C++ compiler being used.</p>
</dd>

<dt><a name="CV-DIR"></a><tt class="ENVAR">Dir</tt></dt>

<dd>
<p>A function that converts a file name into a Dir instance
relative to the target being built.</p>
</dd>

<dt><a name="CV-DSUFFIXES"></a><tt class=
"ENVAR">DSUFFIXES</tt></dt>

<dd>
<p>The list of suffixes of files that will be scanned for imported
D package files. The default list is:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
['.d']
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-DVIPDF"></a><tt class="ENVAR">DVIPDF</tt></dt>

<dd>
<p>The TeX DVI file to PDF file converter.</p>
</dd>

<dt><a name="CV-DVIPDFCOM"></a><tt class=
"ENVAR">DVIPDFCOM</tt></dt>

<dd>
<p>The command line used to convert TeX DVI files into a PDF
file.</p>
</dd>

<dt><a name="CV-DVIPDFCOMSTR"></a><tt class=
"ENVAR">DVIPDFCOMSTR</tt></dt>

<dd>
<p>The string displayed when a TeX DVI file is converted into a PDF
file. If this is not set, then <tt class="ENVAR">$DVIPDFCOM</tt>
(the command line) is displayed.</p>
</dd>

<dt><a name="CV-DVIPDFFLAGS"></a><tt class=
"ENVAR">DVIPDFFLAGS</tt></dt>

<dd>
<p>General options passed to the TeX DVI file to PDF file
converter.</p>
</dd>

<dt><a name="CV-DVIPS"></a><tt class="ENVAR">DVIPS</tt></dt>

<dd>
<p>The TeX DVI file to PostScript converter.</p>
</dd>

<dt><a name="CV-DVIPSFLAGS"></a><tt class=
"ENVAR">DVIPSFLAGS</tt></dt>

<dd>
<p>General options passed to the TeX DVI file to PostScript
converter.</p>
</dd>

<dt><a name="CV-ENV"></a><tt class="ENVAR">ENV</tt></dt>

<dd>
<p>A dictionary of environment variables to use when invoking
commands. When <tt class="ENVAR">$ENV</tt> is used in a command all
list values will be joined using the path separator and any other
non-string values will simply be coerced to a string. Note that, by
default, <tt class="APPLICATION">scons</tt> does <i class=
"EMPHASIS">not</i> propagate the environment in force when you
execute <tt class="APPLICATION">scons</tt> to the commands used to
build target files. This is so that builds will be guaranteed
repeatable regardless of the environment variables set at the time
<tt class="APPLICATION">scons</tt> is invoked.</p>

<p>If you want to propagate your environment variables to the
commands executed to build target files, you must do so
explicitly:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import os
env = Environment(ENV = os.environ)
</pre>
</td>
</tr>
</table>

<p>Note that you can choose only to propagate certain environment
variables. A common example is the system <tt class=
"ENVAR">PATH</tt> environment variable, so that <tt class=
"APPLICATION">scons</tt> uses the same utilities as the invoking
shell (or other process):</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import os
env = Environment(ENV = {'PATH' : os.environ['PATH']})
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-ESCAPE"></a><tt class="ENVAR">ESCAPE</tt></dt>

<dd>
<p>A function that will be called to escape shell special
characters in command lines. The function should take one argument:
the command line string to escape; and should return the escaped
command line.</p>
</dd>

<dt><a name="CV-F77"></a><tt class="ENVAR">F77</tt></dt>

<dd>
<p>The Fortran 77 compiler. You should normally set the <tt class=
"ENVAR">$FORTRAN</tt> variable, which specifies the default Fortran
compiler for all Fortran versions. You only need to set <tt class=
"ENVAR">$F77</tt> if you need to use a specific compiler or
compiler version for Fortran 77 files.</p>
</dd>

<dt><a name="CV-F77COM"></a><tt class="ENVAR">F77COM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 77 source file to an
object file. You only need to set <tt class="ENVAR">$F77COM</tt> if
you need to use a specific command line for Fortran 77 files. You
should normally set the <tt class="ENVAR">$FORTRANCOM</tt>
variable, which specifies the default command line for all Fortran
versions.</p>
</dd>

<dt><a name="CV-F77COMSTR"></a><tt class=
"ENVAR">F77COMSTR</tt></dt>

<dd>
<p>The string displayed when a Fortran 77 source file is compiled
to an object file. If this is not set, then <tt class=
"ENVAR">$F77COM</tt> or <tt class="ENVAR">$FORTRANCOM</tt> (the
command line) is displayed.</p>
</dd>

<dt><a name="CV-F77FLAGS"></a><tt class="ENVAR">F77FLAGS</tt></dt>

<dd>
<p>General user-specified options that are passed to the Fortran 77
compiler. Note that this variable does <i class="EMPHASIS">not</i>
contain <tt class="OPTION">-I</tt> (or similar) include search path
options that scons generates automatically from <tt class=
"ENVAR">$F77PATH</tt>. See <tt class="ENVAR">$_F77INCFLAGS</tt>
below, for the variable that expands to those options. You only
need to set <tt class="ENVAR">$F77FLAGS</tt> if you need to define
specific user options for Fortran 77 files. You should normally set
the <tt class="ENVAR">$FORTRANFLAGS</tt> variable, which specifies
the user-specified options passed to the default Fortran compiler
for all Fortran versions.</p>
</dd>

<dt><a name="CV-_F77INCFLAGS"></a><tt class=
"ENVAR">_F77INCFLAGS</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
Fortran 77 compiler command-line options for specifying directories
to be searched for include files. The value of <tt class=
"ENVAR">$_F77INCFLAGS</tt> is created by appending <tt class=
"ENVAR">$INCPREFIX</tt> and <tt class="ENVAR">$INCSUFFIX</tt> to
the beginning and end of each directory in <tt class=
"ENVAR">$F77PATH</tt>.</p>
</dd>

<dt><a name="CV-F77PATH"></a><tt class="ENVAR">F77PATH</tt></dt>

<dd>
<p>The list of directories that the Fortran 77 compiler will search
for include directories. The implicit dependency scanner will
search these directories for include files. Don't explicitly put
include directory arguments in <tt class="ENVAR">$F77FLAGS</tt>
because the result will be non-portable and the directories will
not be searched by the dependency scanner. Note: directory names in
<tt class="ENVAR">$F77PATH</tt> will be looked-up relative to the
SConscript directory when they are used in a command. To force <tt
class="APPLICATION">scons</tt> to look-up a directory relative to
the root of the source tree use #: You only need to set <tt class=
"ENVAR">$F77PATH</tt> if you need to define a specific include path
for Fortran 77 files. You should normally set the <tt class=
"ENVAR">$FORTRANPATH</tt> variable, which specifies the include
path for the default Fortran compiler for all Fortran versions.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(F77PATH='#/include')
</pre>
</td>
</tr>
</table>

<p>The directory look-up can also be forced using the <tt class=
"FUNCTION">Dir</tt>() function:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
include = Dir('include')
env = Environment(F77PATH=include)
</pre>
</td>
</tr>
</table>

<p>The directory list will be added to command lines through the
automatically-generated <tt class="ENVAR">$_F77INCFLAGS</tt>
construction variable, which is constructed by appending the values
of the <tt class="ENVAR">$INCPREFIX</tt> and <tt class=
"ENVAR">$INCSUFFIX</tt> construction variables to the beginning and
end of each directory in <tt class="ENVAR">$F77PATH</tt>. Any
command lines you define that need the F77PATH directory list
should include <tt class="ENVAR">$_F77INCFLAGS</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(F77COM="my_compiler $_F77INCFLAGS -c -o $TARGET $SOURCE")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-F77PPCOM"></a><tt class="ENVAR">F77PPCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 77 source file to an
object file after first running the file through the C
preprocessor. Any options specified in the <tt class=
"ENVAR">$F77FLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line. You only
need to set <tt class="ENVAR">$F77PPCOM</tt> if you need to use a
specific C-preprocessor command line for Fortran 77 files. You
should normally set the <tt class="ENVAR">$FORTRANPPCOM</tt>
variable, which specifies the default C-preprocessor command line
for all Fortran versions.</p>
</dd>

<dt><a name="CV-F90"></a><tt class="ENVAR">F90</tt></dt>

<dd>
<p>The Fortran 90 compiler. You should normally set the <tt class=
"ENVAR">$FORTRAN</tt> variable, which specifies the default Fortran
compiler for all Fortran versions. You only need to set <tt class=
"ENVAR">$F90</tt> if you need to use a specific compiler or
compiler version for Fortran 90 files.</p>
</dd>

<dt><a name="CV-F90COM"></a><tt class="ENVAR">F90COM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 90 source file to an
object file. You only need to set <tt class="ENVAR">$F90COM</tt> if
you need to use a specific command line for Fortran 90 files. You
should normally set the <tt class="ENVAR">$FORTRANCOM</tt>
variable, which specifies the default command line for all Fortran
versions.</p>
</dd>

<dt><a name="CV-F90COMSTR"></a><tt class=
"ENVAR">F90COMSTR</tt></dt>

<dd>
<p>The string displayed when a Fortran 90 source file is compiled
to an object file. If this is not set, then <tt class=
"ENVAR">$F90COM</tt> or <tt class="ENVAR">$FORTRANCOM</tt> (the
command line) is displayed.</p>
</dd>

<dt><a name="CV-F90FLAGS"></a><tt class="ENVAR">F90FLAGS</tt></dt>

<dd>
<p>General user-specified options that are passed to the Fortran 90
compiler. Note that this variable does <i class="EMPHASIS">not</i>
contain <tt class="OPTION">-I</tt> (or similar) include search path
options that scons generates automatically from <tt class=
"ENVAR">$F90PATH</tt>. See <tt class="ENVAR">$_F90INCFLAGS</tt>
below, for the variable that expands to those options. You only
need to set <tt class="ENVAR">$F90FLAGS</tt> if you need to define
specific user options for Fortran 90 files. You should normally set
the <tt class="ENVAR">$FORTRANFLAGS</tt> variable, which specifies
the user-specified options passed to the default Fortran compiler
for all Fortran versions.</p>
</dd>

<dt><a name="CV-_F90INCFLAGS"></a><tt class=
"ENVAR">_F90INCFLAGS</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
Fortran 90 compiler command-line options for specifying directories
to be searched for include files. The value of <tt class=
"ENVAR">$_F90INCFLAGS</tt> is created by appending <tt class=
"ENVAR">$INCPREFIX</tt> and <tt class="ENVAR">$INCSUFFIX</tt> to
the beginning and end of each directory in <tt class=
"ENVAR">$F90PATH</tt>.</p>
</dd>

<dt><a name="CV-F90PATH"></a><tt class="ENVAR">F90PATH</tt></dt>

<dd>
<p>The list of directories that the Fortran 90 compiler will search
for include directories. The implicit dependency scanner will
search these directories for include files. Don't explicitly put
include directory arguments in <tt class="ENVAR">$F90FLAGS</tt>
because the result will be non-portable and the directories will
not be searched by the dependency scanner. Note: directory names in
<tt class="ENVAR">$F90PATH</tt> will be looked-up relative to the
SConscript directory when they are used in a command. To force <tt
class="APPLICATION">scons</tt> to look-up a directory relative to
the root of the source tree use #: You only need to set <tt class=
"ENVAR">$F90PATH</tt> if you need to define a specific include path
for Fortran 90 files. You should normally set the <tt class=
"ENVAR">$FORTRANPATH</tt> variable, which specifies the include
path for the default Fortran compiler for all Fortran versions.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(F90PATH='#/include')
</pre>
</td>
</tr>
</table>

<p>The directory look-up can also be forced using the <tt class=
"FUNCTION">Dir</tt>() function:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
include = Dir('include')
env = Environment(F90PATH=include)
</pre>
</td>
</tr>
</table>

<p>The directory list will be added to command lines through the
automatically-generated <tt class="ENVAR">$_F90INCFLAGS</tt>
construction variable, which is constructed by appending the values
of the <tt class="ENVAR">$INCPREFIX</tt> and <tt class=
"ENVAR">$INCSUFFIX</tt> construction variables to the beginning and
end of each directory in <tt class="ENVAR">$F90PATH</tt>. Any
command lines you define that need the F90PATH directory list
should include <tt class="ENVAR">$_F90INCFLAGS</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(F90COM="my_compiler $_F90INCFLAGS -c -o $TARGET $SOURCE")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-F90PPCOM"></a><tt class="ENVAR">F90PPCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 90 source file to an
object file after first running the file through the C
preprocessor. Any options specified in the <tt class=
"ENVAR">$F90FLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line. You only
need to set <tt class="ENVAR">$F90PPCOM</tt> if you need to use a
specific C-preprocessor command line for Fortran 90 files. You
should normally set the <tt class="ENVAR">$FORTRANPPCOM</tt>
variable, which specifies the default C-preprocessor command line
for all Fortran versions.</p>
</dd>

<dt><a name="CV-F95"></a><tt class="ENVAR">F95</tt></dt>

<dd>
<p>The Fortran 95 compiler. You should normally set the <tt class=
"ENVAR">$FORTRAN</tt> variable, which specifies the default Fortran
compiler for all Fortran versions. You only need to set <tt class=
"ENVAR">$F95</tt> if you need to use a specific compiler or
compiler version for Fortran 95 files.</p>
</dd>

<dt><a name="CV-F95COM"></a><tt class="ENVAR">F95COM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 95 source file to an
object file. You only need to set <tt class="ENVAR">$F95COM</tt> if
you need to use a specific command line for Fortran 95 files. You
should normally set the <tt class="ENVAR">$FORTRANCOM</tt>
variable, which specifies the default command line for all Fortran
versions.</p>
</dd>

<dt><a name="CV-F95COMSTR"></a><tt class=
"ENVAR">F95COMSTR</tt></dt>

<dd>
<p>The string displayed when a Fortran 95 source file is compiled
to an object file. If this is not set, then <tt class=
"ENVAR">$F95COM</tt> or <tt class="ENVAR">$FORTRANCOM</tt> (the
command line) is displayed.</p>
</dd>

<dt><a name="CV-F95FLAGS"></a><tt class="ENVAR">F95FLAGS</tt></dt>

<dd>
<p>General user-specified options that are passed to the Fortran 95
compiler. Note that this variable does <i class="EMPHASIS">not</i>
contain <tt class="OPTION">-I</tt> (or similar) include search path
options that scons generates automatically from <tt class=
"ENVAR">$F95PATH</tt>. See <tt class="ENVAR">$_F95INCFLAGS</tt>
below, for the variable that expands to those options. You only
need to set <tt class="ENVAR">$F95FLAGS</tt> if you need to define
specific user options for Fortran 95 files. You should normally set
the <tt class="ENVAR">$FORTRANFLAGS</tt> variable, which specifies
the user-specified options passed to the default Fortran compiler
for all Fortran versions.</p>
</dd>

<dt><a name="CV-_F95INCFLAGS"></a><tt class=
"ENVAR">_F95INCFLAGS</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
Fortran 95 compiler command-line options for specifying directories
to be searched for include files. The value of <tt class=
"ENVAR">$_F95INCFLAGS</tt> is created by appending <tt class=
"ENVAR">$INCPREFIX</tt> and <tt class="ENVAR">$INCSUFFIX</tt> to
the beginning and end of each directory in <tt class=
"ENVAR">$F95PATH</tt>.</p>
</dd>

<dt><a name="CV-F95PATH"></a><tt class="ENVAR">F95PATH</tt></dt>

<dd>
<p>The list of directories that the Fortran 95 compiler will search
for include directories. The implicit dependency scanner will
search these directories for include files. Don't explicitly put
include directory arguments in <tt class="ENVAR">$F95FLAGS</tt>
because the result will be non-portable and the directories will
not be searched by the dependency scanner. Note: directory names in
<tt class="ENVAR">$F95PATH</tt> will be looked-up relative to the
SConscript directory when they are used in a command. To force <tt
class="APPLICATION">scons</tt> to look-up a directory relative to
the root of the source tree use #: You only need to set <tt class=
"ENVAR">$F95PATH</tt> if you need to define a specific include path
for Fortran 95 files. You should normally set the <tt class=
"ENVAR">$FORTRANPATH</tt> variable, which specifies the include
path for the default Fortran compiler for all Fortran versions.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(F95PATH='#/include')
</pre>
</td>
</tr>
</table>

<p>The directory look-up can also be forced using the <tt class=
"FUNCTION">Dir</tt>() function:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
include = Dir('include')
env = Environment(F95PATH=include)
</pre>
</td>
</tr>
</table>

<p>The directory list will be added to command lines through the
automatically-generated <tt class="ENVAR">$_F95INCFLAGS</tt>
construction variable, which is constructed by appending the values
of the <tt class="ENVAR">$INCPREFIX</tt> and <tt class=
"ENVAR">$INCSUFFIX</tt> construction variables to the beginning and
end of each directory in <tt class="ENVAR">$F95PATH</tt>. Any
command lines you define that need the F95PATH directory list
should include <tt class="ENVAR">$_F95INCFLAGS</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(F95COM="my_compiler $_F95INCFLAGS -c -o $TARGET $SOURCE")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-F95PPCOM"></a><tt class="ENVAR">F95PPCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 95 source file to an
object file after first running the file through the C
preprocessor. Any options specified in the <tt class=
"ENVAR">$F95FLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line. You only
need to set <tt class="ENVAR">$F95PPCOM</tt> if you need to use a
specific C-preprocessor command line for Fortran 95 files. You
should normally set the <tt class="ENVAR">$FORTRANPPCOM</tt>
variable, which specifies the default C-preprocessor command line
for all Fortran versions.</p>
</dd>

<dt><a name="CV-FILE"></a><tt class="ENVAR">File</tt></dt>

<dd>
<p>A function that converts a file name into a File instance
relative to the target being built.</p>
</dd>

<dt><a name="CV-FORTRAN"></a><tt class="ENVAR">FORTRAN</tt></dt>

<dd>
<p>The default Fortran compiler for all versions of Fortran.</p>
</dd>

<dt><a name="CV-FORTRANCOM"></a><tt class=
"ENVAR">FORTRANCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran source file to an
object file. By default, any options specified in the <tt class=
"ENVAR">$FORTRANFLAGS</tt>, <tt class="ENVAR">$CPPFLAGS</tt>, <tt
class="ENVAR">$_CPPDEFFLAGS</tt>, <tt class=
"ENVAR">$_FORTRANMODFLAG</tt>, and <tt class=
"ENVAR">$_FORTRANINCFLAGS</tt> construction variables are included
on this command line.</p>
</dd>

<dt><a name="CV-FORTRANCOMSTR"></a><tt class=
"ENVAR">FORTRANCOMSTR</tt></dt>

<dd>
<p>The string displayed when a Fortran source file is compiled to
an object file. If this is not set, then <tt class=
"ENVAR">$FORTRANCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-FORTRANFLAGS"></a><tt class=
"ENVAR">FORTRANFLAGS</tt></dt>

<dd>
<p>General user-specified options that are passed to the Fortran
compiler. Note that this variable does <i class="EMPHASIS">not</i>
contain <tt class="OPTION">-I</tt> (or similar) include or module
search path options that scons generates automatically from <tt
class="ENVAR">$FORTRANPATH</tt>. See <tt class=
"ENVAR">$_FORTRANINCFLAGS</tt> and <tt class=
"ENVAR">$_FORTRANMODFLAG</tt>, below, for the variables that expand
those options.</p>
</dd>

<dt><a name="CV-_FORTRANINCFLAGS"></a><tt class=
"ENVAR">_FORTRANINCFLAGS</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
Fortran compiler command-line options for specifying directories to
be searched for include files and module files. The value of <tt
class="ENVAR">$_FORTRANINCFLAGS</tt> is created by
prepending/appending <tt class="ENVAR">$INCPREFIX</tt> and <tt
class="ENVAR">$INCSUFFIX</tt> to the beginning and end of each
directory in <tt class="ENVAR">$FORTRANPATH</tt>.</p>
</dd>

<dt><a name="CV-FORTRANMODDIR"></a><tt class=
"ENVAR">FORTRANMODDIR</tt></dt>

<dd>
<p>Directory location where the Fortran compiler should place any
module files it generates. This variable is empty, by default. Some
Fortran compilers will internally append this directory in the
search path for module files, as well</p>
</dd>

<dt><a name="CV-FORTRANMODDIRPREFIX"></a><tt class=
"ENVAR">FORTRANMODDIRPREFIX</tt></dt>

<dd>
<p>The prefix used to specify a module directory on the Fortran
compiler command line. This will be appended to the beginning of
the directory in the <tt class="ENVAR">$FORTRANMODDIR</tt>
construction variables when the <tt class=
"ENVAR">$_FORTRANMODFLAG</tt> variables is automatically
generated.</p>
</dd>

<dt><a name="CV-FORTRANMODDIRSUFFIX"></a><tt class=
"ENVAR">FORTRANMODDIRSUFFIX</tt></dt>

<dd>
<p>The suffix used to specify a module directory on the Fortran
compiler command line. This will be appended to the beginning of
the directory in the <tt class="ENVAR">$FORTRANMODDIR</tt>
construction variables when the <tt class=
"ENVAR">$_FORTRANMODFLAG</tt> variables is automatically
generated.</p>
</dd>

<dt><a name="CV-_FORTRANMODFLAG"></a><tt class=
"ENVAR">_FORTRANMODFLAG</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
Fortran compiler command-line option for specifying the directory
location where the Fortran compiler should place any module files
that happen to get generated during compilation. The value of <tt
class="ENVAR">$_FORTRANMODFLAG</tt> is created by
prepending/appending <tt class="ENVAR">$FORTRANMODDIRPREFIX</tt>
and <tt class="ENVAR">$FORTRANMODDIRSUFFIX</tt> to the beginning
and end of the directory in <tt class=
"ENVAR">$FORTRANMODDIR</tt>.</p>
</dd>

<dt><a name="CV-FORTRANMODPREFIX"></a><tt class=
"ENVAR">FORTRANMODPREFIX</tt></dt>

<dd>
<p>The module file prefix used by the Fortran compiler. SCons
assumes that the Fortran compiler follows the quasi-standard naming
convention for module files of <tt class=
"FILENAME">module_name.mod</tt>. As a result, this variable is left
empty, by default. For situations in which the compiler does not
necessarily follow the normal convention, the user may use this
variable. Its value will be appended to every module file name as
scons attempts to resolve dependencies.</p>
</dd>

<dt><a name="CV-FORTRANMODSUFFIX"></a><tt class=
"ENVAR">FORTRANMODSUFFIX</tt></dt>

<dd>
<p>The module file suffix used by the Fortran compiler. SCons
assumes that the Fortran compiler follows the quasi-standard naming
convention for module files of <tt class=
"FILENAME">module_name.mod</tt>. As a result, this variable is set
to ".mod", by default. For situations in which the compiler does
not necessarily follow the normal convention, the user may use this
variable. Its value will be appended to every module file name as
scons attempts to resolve dependencies.</p>
</dd>

<dt><a name="CV-FORTRANPATH"></a><tt class=
"ENVAR">FORTRANPATH</tt></dt>

<dd>
<p>The list of directories that the Fortran compiler will search
for include files and (for some compilers) module files. The
Fortran implicit dependency scanner will search these directories
for include files (but not module files since they are
autogenerated and, as such, may not actually exist at the time the
scan takes place). Don't explicitly put include directory arguments
in FORTRANFLAGS because the result will be non-portable and the
directories will not be searched by the dependency scanner. Note:
directory names in FORTRANPATH will be looked-up relative to the
SConscript directory when they are used in a command. To force <tt
class="APPLICATION">scons</tt> to look-up a directory relative to
the root of the source tree use #:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(FORTRANPATH='#/include')
</pre>
</td>
</tr>
</table>

<p>The directory look-up can also be forced using the <tt class=
"FUNCTION">Dir</tt>() function:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
include = Dir('include')
env = Environment(FORTRANPATH=include)
</pre>
</td>
</tr>
</table>

<p>The directory list will be added to command lines through the
automatically-generated <tt class="ENVAR">$_FORTRANINCFLAGS</tt>
construction variable, which is constructed by appending the values
of the <tt class="ENVAR">$INCPREFIX</tt> and <tt class=
"ENVAR">$INCSUFFIX</tt> construction variables to the beginning and
end of each directory in <tt class="ENVAR">$FORTRANPATH</tt>. Any
command lines you define that need the FORTRANPATH directory list
should include <tt class="ENVAR">$_FORTRANINCFLAGS</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(FORTRANCOM="my_compiler $_FORTRANINCFLAGS -c -o $TARGET $SOURCE")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-FORTRANPPCOM"></a><tt class=
"ENVAR">FORTRANPPCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran source file to an
object file after first running the file through the C
preprocessor. By default, any options specified in the <tt class=
"ENVAR">$FORTRANFLAGS</tt>, <tt class="ENVAR">$CPPFLAGS</tt>,
_CPPDEFFLAGS, <tt class="ENVAR">$_FORTRANMODFLAG</tt>, and <tt
class="ENVAR">$_FORTRANINCFLAGS</tt> construction variables are
included on this command line.</p>
</dd>

<dt><a name="CV-FORTRANSUFFIXES"></a><tt class=
"ENVAR">FORTRANSUFFIXES</tt></dt>

<dd>
<p>The list of suffixes of files that will be scanned for Fortran
implicit dependencies (INCLUDE lines and USE statements). The
default list is:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
[".f", ".F", ".for", ".FOR", ".ftn", ".FTN", ".fpp", ".FPP",
".f77", ".F77", ".f90", ".F90", ".f95", ".F95"]
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-FRAMEWORKSFLAGS"></a><tt class=
"ENVAR">FRAMEWORKSFLAGS</tt></dt>

<dd>
<p>On Mac OS X, frameworks options to be added at the end of a
command line building a loadable module.</p>
</dd>

<dt><a name="CV-GS"></a><tt class="ENVAR">GS</tt></dt>

<dd>
<p>The Ghostscript program used to convert PostScript to PDF
files.</p>
</dd>

<dt><a name="CV-GSCOM"></a><tt class="ENVAR">GSCOM</tt></dt>

<dd>
<p>The Ghostscript command line used to convert PostScript to PDF
files.</p>
</dd>

<dt><a name="CV-GSCOMSTR"></a><tt class="ENVAR">GSCOMSTR</tt></dt>

<dd>
<p>The string displayed when Ghostscript is used to convert a
PostScript file to a PDF file. If this is not set, then <tt class=
"ENVAR">$GSCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-GSFLAGS"></a><tt class="ENVAR">GSFLAGS</tt></dt>

<dd>
<p>General options passed to the Ghostscript program when
converting PostScript to PDF files.</p>
</dd>

<dt><a name="CV-IDLSUFFIXES"></a><tt class=
"ENVAR">IDLSUFFIXES</tt></dt>

<dd>
<p>The list of suffixes of files that will be scanned for IDL
implicit dependencies (#include or import lines). The default list
is:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
[".idl", ".IDL"]
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-INCPREFIX"></a><tt class=
"ENVAR">INCPREFIX</tt></dt>

<dd>
<p>The prefix used to specify an include directory on the C
compiler command line. This will be appended to the beginning of
each directory in the <tt class="ENVAR">$CPPPATH</tt> and <tt
class="ENVAR">$FORTRANPATH</tt> construction variables when the <tt
class="ENVAR">$_CPPINCFLAGS</tt> and <tt class=
"ENVAR">$_FORTRANINCFLAGS</tt> variables are automatically
generated.</p>
</dd>

<dt><a name="CV-INCSUFFIX"></a><tt class=
"ENVAR">INCSUFFIX</tt></dt>

<dd>
<p>The suffix used to specify an include directory on the C
compiler command line. This will be appended to the end of each
directory in the <tt class="ENVAR">$CPPPATH</tt> and <tt class=
"ENVAR">$FORTRANPATH</tt> construction variables when the <tt
class="ENVAR">$_CPPINCFLAGS</tt> and <tt class=
"ENVAR">$_FORTRANINCFLAGS</tt> variables are automatically
generated.</p>
</dd>

<dt><a name="CV-INSTALL"></a><tt class="ENVAR">INSTALL</tt></dt>

<dd>
<p>A function to be called to install a file into a destination
file name. The default function copies the file into the
destination (and sets the destination file's mode and permission
bits to match the source file's). The function takes the following
arguments:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
def install(dest, source, env):
</pre>
</td>
</tr>
</table>

<p><tt class="VARNAME">dest</tt> is the path name of the
destination file. <tt class="VARNAME">source</tt> is the path name
of the source file. <tt class="VARNAME">env</tt> is the
construction environment (a dictionary of construction values) in
force for this file installation.</p>
</dd>

<dt><a name="CV-INTEL_C_COMPILER_VERSION"></a><tt class=
"ENVAR">INTEL_C_COMPILER_VERSION</tt></dt>

<dd>
<p>Set by the "intelc" Tool to the major version number of the
Intel C compiler selected for use.</p>
</dd>

<dt><a name="CV-JAR"></a><tt class="ENVAR">JAR</tt></dt>

<dd>
<p>The Java archive tool.</p>
</dd>

<dt><a name="CV-JARCHDIR"></a><tt class="ENVAR">JARCHDIR</tt></dt>

<dd>
<p>The directory to which the Java archive tool should change
(using the <tt class="OPTION">-C</tt> option).</p>
</dd>

<dt><a name="CV-JARCOM"></a><tt class="ENVAR">JARCOM</tt></dt>

<dd>
<p>The command line used to call the Java archive tool.</p>
</dd>

<dt><a name="CV-JARCOMSTR"></a><tt class=
"ENVAR">JARCOMSTR</tt></dt>

<dd>
<p>The string displayed when the Java archive tool is called If
this is not set, then <tt class="ENVAR">$JARCOM</tt> (the command
line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(JARCOMSTR = "JARchiving $SOURCES into $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-JARFLAGS"></a><tt class="ENVAR">JARFLAGS</tt></dt>

<dd>
<p>General options passed to the Java archive tool. By default this
is set to <tt class="OPTION">cf</tt> to create the necessary <b
class="COMMAND">jar</b> file.</p>
</dd>

<dt><a name="CV-JARSUFFIX"></a><tt class=
"ENVAR">JARSUFFIX</tt></dt>

<dd>
<p>The suffix for Java archives: <tt class="FILENAME">.jar</tt> by
default.</p>
</dd>

<dt><a name="CV-JAVAC"></a><tt class="ENVAR">JAVAC</tt></dt>

<dd>
<p>The Java compiler.</p>
</dd>

<dt><a name="CV-JAVACCOM"></a><tt class="ENVAR">JAVACCOM</tt></dt>

<dd>
<p>The command line used to compile a directory tree containing
Java source files to corresponding Java class files. Any options
specified in the <tt class="ENVAR">$JAVACFLAGS</tt> construction
variable are included on this command line.</p>
</dd>

<dt><a name="CV-JAVACCOMSTR"></a><tt class=
"ENVAR">JAVACCOMSTR</tt></dt>

<dd>
<p>The string displayed when compiling a directory tree of Java
source files to corresponding Java class files. If this is not set,
then <tt class="ENVAR">$JAVACCOM</tt> (the command line) is
displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(JAVACCOMSTR = "Compiling class files $TARGETS from $SOURCES")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-JAVACFLAGS"></a><tt class=
"ENVAR">JAVACFLAGS</tt></dt>

<dd>
<p>General options that are passed to the Java compiler.</p>
</dd>

<dt><a name="CV-JAVACLASSDIR"></a><tt class=
"ENVAR">JAVACLASSDIR</tt></dt>

<dd>
<p>The directory in which Java class files may be found. This is
stripped from the beginning of any Java .class file names supplied
to the <tt class="LITERAL">JavaH</tt> builder.</p>
</dd>

<dt><a name="CV-JAVACLASSSUFFIX"></a><tt class=
"ENVAR">JAVACLASSSUFFIX</tt></dt>

<dd>
<p>The suffix for Java class files; <tt class=
"FILENAME">.class</tt> by default.</p>
</dd>

<dt><a name="CV-JAVAH"></a><tt class="ENVAR">JAVAH</tt></dt>

<dd>
<p>The Java generator for C header and stub files.</p>
</dd>

<dt><a name="CV-JAVAHCOM"></a><tt class="ENVAR">JAVAHCOM</tt></dt>

<dd>
<p>The command line used to generate C header and stub files from
Java classes. Any options specified in the <tt class=
"ENVAR">$JAVAHFLAGS</tt> construction variable are included on this
command line.</p>
</dd>

<dt><a name="CV-JAVAHCOMSTR"></a><tt class=
"ENVAR">JAVAHCOMSTR</tt></dt>

<dd>
<p>The string displayed when C header and stub files are generated
from Java classes. If this is not set, then <tt class=
"ENVAR">$JAVAHCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(JAVAHCOMSTR = "Generating header/stub file(s) $TARGETS from $SOURCES")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-JAVAHFLAGS"></a><tt class=
"ENVAR">JAVAHFLAGS</tt></dt>

<dd>
<p>General options passed to the C header and stub file generator
for Java classes.</p>
</dd>

<dt><a name="CV-JAVASUFFIX"></a><tt class=
"ENVAR">JAVASUFFIX</tt></dt>

<dd>
<p>The suffix for Java files; <tt class="FILENAME">.java</tt> by
default.</p>
</dd>

<dt><a name="CV-LATEX"></a><tt class="ENVAR">LATEX</tt></dt>

<dd>
<p>The LaTeX structured formatter and typesetter.</p>
</dd>

<dt><a name="CV-LATEXCOM"></a><tt class="ENVAR">LATEXCOM</tt></dt>

<dd>
<p>The command line used to call the LaTeX structured formatter and
typesetter.</p>
</dd>

<dt><a name="CV-LATEXCOMSTR"></a><tt class=
"ENVAR">LATEXCOMSTR</tt></dt>

<dd>
<p>The string displayed when calling the LaTeX structured formatter
and typesetter. If this is not set, then <tt class=
"ENVAR">$LATEXCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(LATEXCOMSTR = "Building $TARGET from LaTeX input $SOURCES")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-LATEXFLAGS"></a><tt class=
"ENVAR">LATEXFLAGS</tt></dt>

<dd>
<p>General options passed to the LaTeX structured formatter and
typesetter.</p>
</dd>

<dt><a name="CV-LDMODULE"></a><tt class="ENVAR">LDMODULE</tt></dt>

<dd>
<p>The linker for building loadable modules. By default, this is
the same as <tt class="ENVAR">$SHLINK</tt>.</p>
</dd>

<dt><a name="CV-LDMODULECOM"></a><tt class=
"ENVAR">LDMODULECOM</tt></dt>

<dd>
<p>The command line for building loadable modules. On Mac OS X,
this uses the <tt class="ENVAR">$LDMODULE</tt>, <tt class=
"ENVAR">$LDMODULEFLAGS</tt> and <tt class=
"ENVAR">$FRAMEWORKSFLAGS</tt> variables. On other systems, this is
the same as <tt class="ENVAR">$SHLINK</tt>.</p>
</dd>

<dt><a name="CV-LDMODULECOMSTR"></a><tt class=
"ENVAR">LDMODULECOMSTR</tt></dt>

<dd>
<p>The string displayed when building loadable modules. If this is
not set, then <tt class="ENVAR">$LDMODULECOM</tt> (the command
line) is displayed.</p>
</dd>

<dt><a name="CV-LDMODULEFLAGS"></a><tt class=
"ENVAR">LDMODULEFLAGS</tt></dt>

<dd>
<p>General user options passed to the linker for building loadable
modules.</p>
</dd>

<dt><a name="CV-LDMODULEPREFIX"></a><tt class=
"ENVAR">LDMODULEPREFIX</tt></dt>

<dd>
<p>The prefix used for loadable module file names. On Mac OS X,
this is null; on other systems, this is the same as <tt class=
"ENVAR">$SHLIBPREFIX</tt>.</p>
</dd>

<dt><a name="CV-LDMODULESUFFIX"></a><tt class=
"ENVAR">LDMODULESUFFIX</tt></dt>

<dd>
<p>The suffix used for loadable module file names. On Mac OS X,
this is null; on other systems, this is the same as
$SHLIBSUFFIX.</p>
</dd>

<dt><a name="CV-LEX"></a><tt class="ENVAR">LEX</tt></dt>

<dd>
<p>The lexical analyzer generator.</p>
</dd>

<dt><a name="CV-LEXCOM"></a><tt class="ENVAR">LEXCOM</tt></dt>

<dd>
<p>The command line used to call the lexical analyzer generator to
generate a source file.</p>
</dd>

<dt><a name="CV-LEXCOMSTR"></a><tt class=
"ENVAR">LEXCOMSTR</tt></dt>

<dd>
<p>The string displayed when generating a source file using the
lexical analyzer generator. If this is not set, then <tt class=
"ENVAR">$LEXCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(LEXCOMSTR = "Lex'ing $TARGET from $SOURCES")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-LEXFLAGS"></a><tt class="ENVAR">LEXFLAGS</tt></dt>

<dd>
<p>General options passed to the lexical analyzer generator.</p>
</dd>

<dt><a name="CV-_LIBDIRFLAGS"></a><tt class=
"ENVAR">_LIBDIRFLAGS</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
linker command-line options for specifying directories to be
searched for library. The value of <tt class=
"ENVAR">$_LIBDIRFLAGS</tt> is created by appending <tt class=
"ENVAR">$LIBDIRPREFIX</tt> and <tt class="ENVAR">$LIBDIRSUFFIX</tt>
to the beginning and end of each directory in <tt class=
"ENVAR">$LIBPATH</tt>.</p>
</dd>

<dt><a name="CV-LIBDIRPREFIX"></a><tt class=
"ENVAR">LIBDIRPREFIX</tt></dt>

<dd>
<p>The prefix used to specify a library directory on the linker
command line. This will be appended to the beginning of each
directory in the <tt class="ENVAR">$LIBPATH</tt> construction
variable when the <tt class="ENVAR">$_LIBDIRFLAGS</tt> variable is
automatically generated.</p>
</dd>

<dt><a name="CV-LIBDIRSUFFIX"></a><tt class=
"ENVAR">LIBDIRSUFFIX</tt></dt>

<dd>
<p>The suffix used to specify a library directory on the linker
command line. This will be appended to the end of each directory in
the <tt class="ENVAR">$LIBPATH</tt> construction variable when the
<tt class="ENVAR">$_LIBDIRFLAGS</tt> variable is automatically
generated.</p>
</dd>

<dt><a name="CV-_LIBFLAGS"></a><tt class=
"ENVAR">_LIBFLAGS</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
linker command-line options for specifying libraries to be linked
with the resulting target. The value of <tt class=
"ENVAR">$_LIBFLAGS</tt> is created by appending <tt class=
"ENVAR">$LIBLINKPREFIX</tt> and <tt class=
"ENVAR">$LIBLINKSUFFIX</tt> to the beginning and end of each
filename in <tt class="ENVAR">$LIBS</tt>.</p>
</dd>

<dt><a name="CV-LIBLINKPREFIX"></a><tt class=
"ENVAR">LIBLINKPREFIX</tt></dt>

<dd>
<p>The prefix used to specify a library to link on the linker
command line. This will be appended to the beginning of each
library in the <tt class="ENVAR">$LIBS</tt> construction variable
when the <tt class="ENVAR">$_LIBFLAGS</tt> variable is
automatically generated.</p>
</dd>

<dt><a name="CV-LIBLINKSUFFIX"></a><tt class=
"ENVAR">LIBLINKSUFFIX</tt></dt>

<dd>
<p>The suffix used to specify a library to link on the linker
command line. This will be appended to the end of each library in
the <tt class="ENVAR">$LIBS</tt> construction variable when the <tt
class="ENVAR">$_LIBFLAGS</tt> variable is automatically
generated.</p>
</dd>

<dt><a name="CV-LIBPATH"></a><tt class="ENVAR">LIBPATH</tt></dt>

<dd>
<p>The list of directories that will be searched for libraries. The
implicit dependency scanner will search these directories for
include files. Don't explicitly put include directory arguments in
<tt class="ENVAR">$LINKFLAGS</tt> or <tt class=
"ENVAR">$SHLINKFLAGS</tt> because the result will be non-portable
and the directories will not be searched by the dependency scanner.
Note: directory names in LIBPATH will be looked-up relative to the
SConscript directory when they are used in a command. To force <tt
class="APPLICATION">scons</tt> to look-up a directory relative to
the root of the source tree use #:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(LIBPATH='#/libs')
</pre>
</td>
</tr>
</table>

<p>The directory look-up can also be forced using the <tt class=
"FUNCTION">Dir</tt>() function:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
libs = Dir('libs')
env = Environment(LIBPATH=libs)
</pre>
</td>
</tr>
</table>

<p>The directory list will be added to command lines through the
automatically-generated <tt class="ENVAR">$_LIBDIRFLAGS</tt>
construction variable, which is constructed by appending the values
of the <tt class="ENVAR">$LIBDIRPREFIX</tt> and <tt class=
"ENVAR">$LIBDIRSUFFIX</tt> construction variables to the beginning
and end of each directory in <tt class="ENVAR">$LIBPATH</tt>. Any
command lines you define that need the LIBPATH directory list
should include <tt class="ENVAR">$_LIBDIRFLAGS</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(LINKCOM="my_linker $_LIBDIRFLAGS $_LIBFLAGS -o $TARGET $SOURCE")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-LIBPREFIX"></a><tt class=
"ENVAR">LIBPREFIX</tt></dt>

<dd>
<p>The prefix used for (static) library file names. A default value
is set for each platform (posix, win32, os2, etc.), but the value
is overridden by individual tools (ar, mslib, sgiar, sunar, tlib,
etc.) to reflect the names of the libraries they create.</p>
</dd>

<dt><a name="CV-LIBPREFIXES"></a><tt class=
"ENVAR">LIBPREFIXES</tt></dt>

<dd>
<p>An array of legal prefixes for library file names.</p>
</dd>

<dt><a name="CV-LIBS"></a><tt class="ENVAR">LIBS</tt></dt>

<dd>
<p>A list of one or more libraries that will be linked with any
executable programs created by this environment.</p>

<p>The library list will be added to command lines through the
automatically-generated <tt class="ENVAR">$_LIBFLAGS</tt>
construction variable, which is constructed by appending the values
of the <tt class="ENVAR">$LIBLINKPREFIX</tt> and <tt class=
"ENVAR">$LIBLINKSUFFIX</tt> construction variables to the beginning
and end of each filename in <tt class="ENVAR">$LIBS</tt>. Any
command lines you define that need the LIBS library list should
include <tt class="ENVAR">$_LIBFLAGS</tt>:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(LINKCOM="my_linker $_LIBDIRFLAGS $_LIBFLAGS -o $TARGET $SOURCE")
</pre>
</td>
</tr>
</table>

<p>If you add a File object to the <tt class="ENVAR">$LIBS</tt>
list, the name of that file will be added to <tt class=
"ENVAR">$_LIBFLAGS</tt>, and thus the link line, as is, without <tt
class="ENVAR">$LIBLINKPREFIX</tt> or <tt class=
"ENVAR">$LIBLINKSUFFIX</tt>. For example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.Append(LIBS=File('/tmp/mylib.so'))
</pre>
</td>
</tr>
</table>

<p>In all cases, scons will add dependencies from the executable
program to all the libraries in this list.</p>
</dd>

<dt><a name="CV-LIBSUFFIX"></a><tt class=
"ENVAR">LIBSUFFIX</tt></dt>

<dd>
<p>The suffix used for (static) library file names. A default value
is set for each platform (posix, win32, os2, etc.), but the value
is overridden by individual tools (ar, mslib, sgiar, sunar, tlib,
etc.) to reflect the names of the libraries they create.</p>
</dd>

<dt><a name="CV-LIBSUFFIXES"></a><tt class=
"ENVAR">LIBSUFFIXES</tt></dt>

<dd>
<p>An array of legal suffixes for library file names.</p>
</dd>

<dt><a name="CV-LINK"></a><tt class="ENVAR">LINK</tt></dt>

<dd>
<p>The linker.</p>
</dd>

<dt><a name="CV-LINKCOM"></a><tt class="ENVAR">LINKCOM</tt></dt>

<dd>
<p>The command line used to link object files into an
executable.</p>
</dd>

<dt><a name="CV-LINKCOMSTR"></a><tt class=
"ENVAR">LINKCOMSTR</tt></dt>

<dd>
<p>The string displayed when object files are linked into an
executable. If this is not set, then <tt class=
"ENVAR">$LINKCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(LINKCOMSTR = "Linking $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-LINKFLAGS"></a><tt class=
"ENVAR">LINKFLAGS</tt></dt>

<dd>
<p>General user options passed to the linker. Note that this
variable should <i class="EMPHASIS">not</i> contain <tt class=
"OPTION">-l</tt> (or similar) options for linking with the
libraries listed in <tt class="ENVAR">$LIBS</tt>, nor <tt class=
"OPTION">-L</tt> (or similar) library search path options that
scons generates automatically from <tt class="ENVAR">$LIBPATH</tt>.
See <tt class="ENVAR">$_LIBFLAGS</tt> above, for the variable that
expands to library-link options, and <tt class=
"ENVAR">$_LIBDIRFLAGS</tt> above, for the variable that expands to
library search path options.</p>
</dd>

<dt><a name="CV-M4"></a><tt class="ENVAR">M4</tt></dt>

<dd>
<p>The M4 macro preprocessor.</p>
</dd>

<dt><a name="CV-M4COM"></a><tt class="ENVAR">M4COM</tt></dt>

<dd>
<p>The command line used to pass files through the M4 macro
preprocessor.</p>
</dd>

<dt><a name="CV-M4COMSTR"></a><tt class="ENVAR">M4COMSTR</tt></dt>

<dd>
<p>The string displayed when a file is passed through the M4 macro
preprocessor. If this is not set, then <tt class=
"ENVAR">$M4COM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-M4FLAGS"></a><tt class="ENVAR">M4FLAGS</tt></dt>

<dd>
<p>General options passed to the M4 macro preprocessor.</p>
</dd>

<dt><a name="CV-MAXLINELENGTH"></a><tt class=
"ENVAR">MAXLINELENGTH</tt></dt>

<dd>
<p>The maximum number of characters allowed on an external command
line. On Win32 systems, link lines longer than this many characters
are linked via a temporary file name.</p>
</dd>

<dt><a name="CV-MSVS"></a><tt class="ENVAR">MSVS</tt></dt>

<dd>
<p>When the Microsoft Visual Studio tools are initialized, they set
up this dictionary with the following keys:</p>

<p><tt class="ENVAR">VERSION</tt> the version of MSVS being used
(can be set via MSVS_VERSION)</p>

<p><tt class="ENVAR">VERSIONS</tt> the available versions of MSVS
installed</p>

<p><tt class="ENVAR">VCINSTALLDIR</tt> installed directory of
Visual C++</p>

<p><tt class="ENVAR">VSINSTALLDIR</tt> installed directory of
Visual Studio</p>

<p><tt class="ENVAR">FRAMEWORKDIR</tt> installed directory of the
.NET framework</p>

<p><tt class="ENVAR">FRAMEWORKVERSIONS</tt> list of installed
versions of the .NET framework, sorted latest to oldest.</p>

<p><tt class="ENVAR">FRAMEWORKVERSION</tt> latest installed version
of the .NET framework</p>

<p><tt class="ENVAR">FRAMEWORKSDKDIR</tt> installed location of the
.NET SDK.</p>

<p><tt class="ENVAR">PLATFORMSDKDIR</tt> installed location of the
Platform SDK.</p>

<p><tt class="ENVAR">PLATFORMSDK_MODULES</tt> dictionary of
installed Platform SDK modules, where the dictionary keys are
keywords for the various modules, and the values are 2-tuples where
the first is the release date, and the second is the version
number.</p>

<p>If a value isn't set, it wasn't available in the registry.</p>
</dd>

<dt><a name="CV-MSVS_IGNORE_IDE_PATHS"></a><tt class=
"ENVAR">MSVS_IGNORE_IDE_PATHS</tt></dt>

<dd>
<p>Tells the MS Visual Studio tools to use minimal INCLUDE, LIB,
and PATH settings, instead of the settings from the IDE.</p>

<p>For Visual Studio, SCons will (by default) automatically
determine where MSVS is installed, and use the LIB, INCLUDE, and
PATH variables set by the IDE. You can override this behavior by
setting these variables after Environment initialization, or by
setting <tt class="ENVAR">MSVS_IGNORE_IDE_PATHS = 1</tt> in the
Environment initialization. Specifying this will not leave these
unset, but will set them to a minimal set of paths needed to run
the tools successfully.</p>

<p>For VS6, the mininimal set is:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
   INCLUDE:'VSDir\VC98\ATL\include;VSDir\VC98\MFC\include;VSDir\VC98\include'
   LIB:'VSDir\VC98\MFC\lib;VSDir\VC98\lib'
   PATH:'VSDir\Common\MSDev98\bin;VSDir\VC98\bin'
</pre>
</td>
</tr>
</table>

<p>For VS7, it is:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
   INCLUDE:'VSDir\Vc7\atlmfc\include;VSDir\Vc7\include'
   LIB:'VSDir\Vc7\atlmfc\lib;VSDir\Vc7\lib'
   PATH:'VSDir\Common7\Tools\bin;VSDir\Common7\Tools;VSDir\Vc7\bin'
</pre>
</td>
</tr>
</table>

<p>Where 'VSDir' is the installed location of Visual Studio.</p>
</dd>

<dt><a name="CV-MSVS_USE_MFC_DIRS"></a><tt class=
"ENVAR">MSVS_USE_MFC_DIRS</tt></dt>

<dd>
<p>Tells the MS Visual Studio tool(s) to use the MFC directories in
its default paths for compiling and linking. Under MSVS version 6,
setting <tt class="ENVAR">MSVS_USE_MFC_DIRS</tt> to a non-zero
value adds the <tt class="FILENAME">ATL\include</tt> and <tt class=
"FILENAME">MFC\include</tt> directories to the default <tt class=
"ENVAR">INCLUDE</tt> external environment variable, and adds the
<tt class="ENVAR">MFC\lib</tt> directory to the default <tt class=
"ENVAR">LIB</tt> external environment variable. Under MSVS version
7, setting <tt class="ENVAR">MSVS_USE_MFC_DIRS</tt> to a non-zero
value adds the <tt class="ENVAR">atlmfc\include</tt> directory to
the default <tt class="ENVAR">INCLUDE</tt> external environment
variable, and adds the <tt class="ENVAR">atlmfc\lib</tt> directory
to the default <tt class="ENVAR">LIB</tt> external environment
variable. The current default value is <tt class="LITERAL">1</tt>
which means these directories are added to the paths by default.
This default value is likely to change in a future release, so
users who want the ATL and MFC values included in their paths are
encouraged to enable the <tt class="ENVAR">MSVS_USE_MFC_DIRS</tt>
value explicitly to avoid future incompatibility. This variable has
no effect if the <tt class="ENVAR">INCLUDE</tt> or <tt class=
"ENVAR">LIB</tt> environment variables are set explictly.</p>
</dd>

<dt><a name="CV-MSVS_VERSION"></a><tt class=
"ENVAR">MSVS_VERSION</tt></dt>

<dd>
<p>Sets the preferred version of MSVS to use.</p>

<p>SCons will (by default) select the latest version of MSVS
installed on your machine. So, if you have version 6 and version 7
(MSVS .NET) installed, it will prefer version 7. You can override
this by specifying the <tt class="ENVAR">MSVS_VERSION</tt> variable
in the Environment initialization, setting it to the appropriate
version ('6.0' or '7.0', for example). If the given version isn't
installed, tool initialization will fail.</p>
</dd>

<dt><a name="CV-MSVSPROJECTCOM"></a><tt class=
"ENVAR">MSVSPROJECTCOM</tt></dt>

<dd>
<p>The action used to generate Microsoft Visual Studio project and
solution files.</p>
</dd>

<dt><a name="CV-MSVSPROJECTSUFFIX"></a><tt class=
"ENVAR">MSVSPROJECTSUFFIX</tt></dt>

<dd>
<p>The suffix used for Microsoft Visual Studio project (DSP) files.
The default value is <tt class="FILENAME">.vcproj</tt> when using
Visual Studio version 7.x (.NET), and <tt class=
"FILENAME">.dsp</tt> when using earlier versions of Visual
Studio.</p>
</dd>

<dt><a name="CV-MSVSSOLUTIONSUFFIX"></a><tt class=
"ENVAR">MSVSSOLUTIONSUFFIX</tt></dt>

<dd>
<p>The suffix used for Microsoft Visual Studio solution (DSW)
files. The default value is <tt class="FILENAME">.sln</tt> when
using Visual Studio version 7.x (.NET), and <tt class=
"FILENAME">.dsw</tt> when using earlier versions of Visual
Studio.</p>
</dd>

<dt><a name="CV-MWCW_VERSION"></a><tt class=
"ENVAR">MWCW_VERSION</tt></dt>

<dd>
<p>The version number of the MetroWerks CodeWarrior C compiler to
be used.</p>
</dd>

<dt><a name="CV-MWCW_VERSIONS"></a><tt class=
"ENVAR">MWCW_VERSIONS</tt></dt>

<dd>
<p>A list of installed versions of the MetroWerks CodeWarrior C
compiler on this system.</p>
</dd>

<dt><a name="CV-NO_IMPORT_LIB"></a><tt class=
"ENVAR">no_import_lib</tt></dt>

<dd>
<p>When set to non-zero, suppresses creation of a corresponding
Win32 static import lib by the <tt class=
"LITERAL">SharedLibrary</tt> builder when used with MinGW,
Microsoft Visual Studio or Metrowerks. This also suppresses
creation of an export (.exp) file when using Microsoft Visual
Studio.</p>
</dd>

<dt><a name="CV-OBJPREFIX"></a><tt class=
"ENVAR">OBJPREFIX</tt></dt>

<dd>
<p>The prefix used for (static) object file names.</p>
</dd>

<dt><a name="CV-OBJSUFFIX"></a><tt class=
"ENVAR">OBJSUFFIX</tt></dt>

<dd>
<p>The suffix used for (static) object file names.</p>
</dd>

<dt><a name="CV-P4"></a><tt class="ENVAR">P4</tt></dt>

<dd>
<p>The Perforce executable.</p>
</dd>

<dt><a name="CV-P4COM"></a><tt class="ENVAR">P4COM</tt></dt>

<dd>
<p>The command line used to fetch source files from Perforce.</p>
</dd>

<dt><a name="CV-P4COMSTR"></a><tt class="ENVAR">P4COMSTR</tt></dt>

<dd>
<p>The string displayed when fetching a source file from Perforce.
If this is not set, then <tt class="ENVAR">$P4COM</tt> (the command
line) is displayed.</p>
</dd>

<dt><a name="CV-P4FLAGS"></a><tt class="ENVAR">P4FLAGS</tt></dt>

<dd>
<p>General options that are passed to Perforce.</p>
</dd>

<dt><a name="CV-PCH"></a><tt class="ENVAR">PCH</tt></dt>

<dd>
<p>The Microsoft Visual C++ precompiled header that will be used
when compiling object files. This variable is ignored by tools
other than Microsoft Visual C++. When this variable is defined
SCons will add options to the compiler command line to cause it to
use the precompiled header, and will also set up the dependencies
for the PCH file. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env['PCH'] = 'StdAfx.pch'
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-PCHCOM"></a><tt class="ENVAR">PCHCOM</tt></dt>

<dd>
<p>The command line used by the <tt class="FUNCTION">PCH</tt>
builder to generated a precompiled header.</p>
</dd>

<dt><a name="CV-PCHCOMSTR"></a><tt class=
"ENVAR">PCHCOMSTR</tt></dt>

<dd>
<p>The string displayed when generating a precompiled header. If
this is not set, then <tt class="ENVAR">$PCHCOM</tt> (the command
line) is displayed.</p>
</dd>

<dt><a name="CV-PCHSTOP"></a><tt class="ENVAR">PCHSTOP</tt></dt>

<dd>
<p>This variable specifies how much of a source file is
precompiled. This variable is ignored by tools other than Microsoft
Visual C++, or when the PCH variable is not being used. When this
variable is define it must be a string that is the name of the
header that is included at the end of the precompiled portion of
the source files, or the empty string if the "#pragma hrdstop"
construct is being used:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env['PCHSTOP'] = 'StdAfx.h'
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-PDB"></a><tt class="ENVAR">PDB</tt></dt>

<dd>
<p>The Microsoft Visual C++ PDB file that will store debugging
information for object files, shared libraries, and programs. This
variable is ignored by tools other than Microsoft Visual C++. When
this variable is defined SCons will add options to the compiler and
linker command line to cause them to generate external debugging
information, and will also set up the dependencies for the PDB
file. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env['PDB'] = 'hello.pdb'
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-PDFCOM"></a><tt class="ENVAR">PDFCOM</tt></dt>

<dd>
<p>A deprecated synonym for <tt class="ENVAR">$DVIPDFCOM</tt>.</p>
</dd>

<dt><a name="CV-PDFPREFIX"></a><tt class=
"ENVAR">PDFPREFIX</tt></dt>

<dd>
<p>The prefix used for PDF file names.</p>
</dd>

<dt><a name="CV-PDFSUFFIX"></a><tt class=
"ENVAR">PDFSUFFIX</tt></dt>

<dd>
<p>The suffix used for PDF file names.</p>
</dd>

<dt><a name="CV-PLATFORM"></a><tt class="ENVAR">PLATFORM</tt></dt>

<dd>
<p>The name of the platform used to create the Environment. If no
platform is specified when the Environment is created, <tt class=
"APPLICATION">scons</tt> autodetects the platform.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(tools = [])
if env['PLATFORM'] == 'cygwin':
    Tool('mingw')(env)
else:
    Tool('msvc')(env)
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-PRINT_CMD_LINE_FUNC"></a><tt class=
"ENVAR">PRINT_CMD_LINE_FUNC</tt></dt>

<dd>
<p>A Python function used to print the command lines as they are
executed (assuming command printing is not disabled by the <tt
class="OPTION">-q</tt> or <tt class="OPTION">-s</tt> options or
their equivalents). The function should take four arguments: <tt
class="VARNAME">s</tt>, the command being executed (a string), <tt
class="VARNAME">target</tt>, the target being built (file node,
list, or string name(s)), <tt class="VARNAME">source</tt>, the
source(s) used (file node, list, or string name(s)), and <tt class=
"VARNAME">env</tt>, the environment being used.</p>

<p>The function must do the printing itself. The default
implementation, used if this variable is not set or is None,
is:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
def print_cmd_line(s, target, source, env):
  sys.stdout.write(s + "\n")
</pre>
</td>
</tr>
</table>

<p>Here's an example of a more interesting function:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
def print_cmd_line(s, target, source, env):
   sys.stdout.write("Building %s -&gt; %s...\n" %
    (' and '.join([str(x) for x in source]),
     ' and '.join([str(x) for x in target])))
env=Environment(PRINT_CMD_LINE_FUNC=print_cmd_line)
env.Program('foo', 'foo.c')
</pre>
</td>
</tr>
</table>

<p>This just prints "Building <tt class="VARNAME">targetname</tt>
from <tt class="VARNAME">sourcename</tt>..." instead of the actual
commands. Such a function could also log the actual commands to a
log file, for example.</p>
</dd>

<dt><a name="CV-PROGPREFIX"></a><tt class=
"ENVAR">PROGPREFIX</tt></dt>

<dd>
<p>The prefix used for executable file names.</p>
</dd>

<dt><a name="CV-PROGSUFFIX"></a><tt class=
"ENVAR">PROGSUFFIX</tt></dt>

<dd>
<p>The suffix used for executable file names.</p>
</dd>

<dt><a name="CV-PSCOM"></a><tt class="ENVAR">PSCOM</tt></dt>

<dd>
<p>The command line used to convert TeX DVI files into a PostScript
file.</p>
</dd>

<dt><a name="CV-PSCOMSTR"></a><tt class="ENVAR">PSCOMSTR</tt></dt>

<dd>
<p>The string displayed when a TeX DVI file is converted into a
PostScript file. If this is not set, then <tt class=
"ENVAR">$PSCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-PSPREFIX"></a><tt class="ENVAR">PSPREFIX</tt></dt>

<dd>
<p>The prefix used for PostScript file names.</p>
</dd>

<dt><a name="CV-PSSUFFIX"></a><tt class="ENVAR">PSSUFFIX</tt></dt>

<dd>
<p>The prefix used for PostScript file names.</p>
</dd>

<dt><a name="CV-QT_AUTOSCAN"></a><tt class=
"ENVAR">QT_AUTOSCAN</tt></dt>

<dd>
<p>Turn off scanning for mocable files. Use the Moc Builder to
explicitely specify files to run moc on.</p>
</dd>

<dt><a name="CV-QT_BINPATH"></a><tt class=
"ENVAR">QT_BINPATH</tt></dt>

<dd>
<p>The path where the qt binaries are installed. The default value
is '<tt class="ENVAR">$QTDIR</tt>/bin'.</p>
</dd>

<dt><a name="CV-QT_CPPPATH"></a><tt class=
"ENVAR">QT_CPPPATH</tt></dt>

<dd>
<p>The path where the qt header files are installed. The default
value is '<tt class="ENVAR">$QTDIR</tt>/include'. Note: If you set
this variable to None, the tool won't change the <tt class=
"ENVAR">$CPPPATH</tt> construction variable.</p>
</dd>

<dt><a name="CV-QT_DEBUG"></a><tt class="ENVAR">QT_DEBUG</tt></dt>

<dd>
<p>Prints lots of debugging information while scanning for moc
files.</p>
</dd>

<dt><a name="CV-QT_LIB"></a><tt class="ENVAR">QT_LIB</tt></dt>

<dd>
<p>Default value is 'qt'. You may want to set this to 'qt-mt'.
Note: If you set this variable to None, the tool won't change the
<tt class="ENVAR">$LIBS</tt> variable.</p>
</dd>

<dt><a name="CV-QT_LIBPATH"></a><tt class=
"ENVAR">QT_LIBPATH</tt></dt>

<dd>
<p>The path where the qt libraries are installed. The default value
is '<tt class="ENVAR">$QTDIR</tt>/lib'. Note: If you set this
variable to None, the tool won't change the <tt class=
"ENVAR">$LIBPATH</tt> construction variable.</p>
</dd>

<dt><a name="CV-QT_MOC"></a><tt class="ENVAR">QT_MOC</tt></dt>

<dd>
<p>Default value is '<tt class=
"ENVAR">$QT_BINPATH</tt>/bin/moc'.</p>
</dd>

<dt><a name="CV-QT_MOCCXXPREFIX"></a><tt class=
"ENVAR">QT_MOCCXXPREFIX</tt></dt>

<dd>
<p>Default value is ''. Prefix for moc output files, when source is
a cxx file.</p>
</dd>

<dt><a name="CV-QT_MOCCXXSUFFIX"></a><tt class=
"ENVAR">QT_MOCCXXSUFFIX</tt></dt>

<dd>
<p>Default value is '.moc'. Suffix for moc output files, when
source is a cxx file.</p>
</dd>

<dt><a name="CV-QT_MOCFROMCPPFLAGS"></a><tt class=
"ENVAR">QT_MOCFROMCPPFLAGS</tt></dt>

<dd>
<p>Default value is '-i'. These flags are passed to moc, when
moccing a cpp file.</p>
</dd>

<dt><a name="CV-QT_MOCFROMCXXCOM"></a><tt class=
"ENVAR">QT_MOCFROMCXXCOM</tt></dt>

<dd>
<p>Command to generate a moc file from a cpp file.</p>
</dd>

<dt><a name="CV-QT_MOCFROMCXXCOMSTR"></a><tt class=
"ENVAR">QT_MOCFROMCXXCOMSTR</tt></dt>

<dd>
<p>The string displayed when generating a moc file from a cpp file.
If this is not set, then <tt class="ENVAR">$QT_MOCFROMCXXCOM</tt>
(the command line) is displayed.</p>
</dd>

<dt><a name="CV-QT_MOCFROMHCOM"></a><tt class=
"ENVAR">QT_MOCFROMHCOM</tt></dt>

<dd>
<p>Command to generate a moc file from a header.</p>
</dd>

<dt><a name="CV-QT_MOCFROMHCOMSTR"></a><tt class=
"ENVAR">QT_MOCFROMHCOMSTR</tt></dt>

<dd>
<p>The string displayed when generating a moc file from a cpp file.
If this is not set, then <tt class="ENVAR">$QT_MOCFROMHCOM</tt>
(the command line) is displayed.</p>
</dd>

<dt><a name="CV-QT_MOCFROMHFLAGS"></a><tt class=
"ENVAR">QT_MOCFROMHFLAGS</tt></dt>

<dd>
<p>Default value is ''. These flags are passed to moc, when moccing
a header file.</p>
</dd>

<dt><a name="CV-QT_MOCHPREFIX"></a><tt class=
"ENVAR">QT_MOCHPREFIX</tt></dt>

<dd>
<p>Default value is 'moc_'. Prefix for moc output files, when
source is a header.</p>
</dd>

<dt><a name="CV-QT_MOCHSUFFIX"></a><tt class=
"ENVAR">QT_MOCHSUFFIX</tt></dt>

<dd>
<p>Default value is '<tt class="ENVAR">$CXXFILESUFFIX</tt>'. Suffix
for moc output files, when source is a header.</p>
</dd>

<dt><a name="CV-QT_UIC"></a><tt class="ENVAR">QT_UIC</tt></dt>

<dd>
<p>Default value is '<tt class="ENVAR">$QT_BINPATH</tt>/uic'.</p>
</dd>

<dt><a name="CV-QT_UICCOM"></a><tt class=
"ENVAR">QT_UICCOM</tt></dt>

<dd>
<p>Command to generate header files from .ui files.</p>
</dd>

<dt><a name="CV-QT_UICCOMSTR"></a><tt class=
"ENVAR">QT_UICCOMSTR</tt></dt>

<dd>
<p>The string displayed when generating header files from .ui
files. If this is not set, then <tt class="ENVAR">$QT_UICCOM</tt>
(the command line) is displayed.</p>
</dd>

<dt><a name="CV-QT_UICDECLFLAGS"></a><tt class=
"ENVAR">QT_UICDECLFLAGS</tt></dt>

<dd>
<p>Default value is ''. These flags are passed to uic, when
creating a a h file from a .ui file.</p>
</dd>

<dt><a name="CV-QT_UICDECLPREFIX"></a><tt class=
"ENVAR">QT_UICDECLPREFIX</tt></dt>

<dd>
<p>Default value is ''. Prefix for uic generated header files.</p>
</dd>

<dt><a name="CV-QT_UICDECLSUFFIX"></a><tt class=
"ENVAR">QT_UICDECLSUFFIX</tt></dt>

<dd>
<p>Default value is '.h'. Suffix for uic generated header
files.</p>
</dd>

<dt><a name="CV-QT_UICIMPLFLAGS"></a><tt class=
"ENVAR">QT_UICIMPLFLAGS</tt></dt>

<dd>
<p>Default value is ''. These flags are passed to uic, when
creating a cxx file from a .ui file.</p>
</dd>

<dt><a name="CV-QT_UICIMPLPREFIX"></a><tt class=
"ENVAR">QT_UICIMPLPREFIX</tt></dt>

<dd>
<p>Default value is 'uic_'. Prefix for uic generated implementation
files.</p>
</dd>

<dt><a name="CV-QT_UICIMPLSUFFIX"></a><tt class=
"ENVAR">QT_UICIMPLSUFFIX</tt></dt>

<dd>
<p>Default value is '<tt class="ENVAR">$CXXFILESUFFIX</tt>'. Suffix
for uic generated implementation files.</p>
</dd>

<dt><a name="CV-QT_UISUFFIX"></a><tt class=
"ENVAR">QT_UISUFFIX</tt></dt>

<dd>
<p>Default value is '.ui'. Suffix of designer input files.</p>
</dd>

<dt><a name="CV-QTDIR"></a><tt class="ENVAR">QTDIR</tt></dt>

<dd>
<p>The qt tool tries to take this from os.environ. It also
initializes all QT_* construction variables listed below. (Note
that all paths are constructed with python's os.path.join() method,
but are listed here with the '/' separator for easier reading.) In
addition, the construction environment variables <tt class=
"ENVAR">$CPPPATH</tt>, <tt class="ENVAR">$LIBPATH</tt> and <tt
class="ENVAR">$LIBS</tt> may be modified and the variables
PROGEMITTER, SHLIBEMITTER and LIBEMITTER are modified. Because the
build-performance is affected when using this tool, you have to
explicitly specify it at Environment creation:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
Environment(tools=['default','qt'])
</pre>
</td>
</tr>
</table>

<p>The qt tool supports the following operations:</p>

<p>.B Automatic moc file generation from header files. You do not
have to specify moc files explicitly, the tool does it for you.
However, there are a few preconditions to do so: Your header file
must have the same filebase as your implementation file and must
stay in the same directory. It must have one of the suffixes .h,
.hpp, .H, .hxx, .hh. You can turn off automatic moc file generation
by setting QT_AUTOSCAN to 0. See also the corresponding builder
method .B Moc()</p>

<p>.B Automatic moc file generation from cxx files. As stated in
the qt documentation, include the moc file at the end of the cxx
file. Note that you have to include the file, which is generated by
the transformation ${QT_MOCCXXPREFIX}basename${QT_MOCCXXSUFFIX}, by
default basename.moc. A warning is generated after building the moc
file, if you do not include the correct file. If you are using
BuildDir, you may need to specify duplicate=1. You can turn off
automatic moc file generation by setting QT_AUTOSCAN to 0. See also
the corresponding builder method .B Moc()</p>

<p>.B Automatic handling of .ui files. The implementation files
generated from .ui files are handled much the same as yacc or lex
files. Each .ui file given as a source of Program, Library or
SharedLibrary will generate three files, the declaration file, the
implementation file and a moc file. Because there are also
generated headers, you may need to specify duplicate=1 in calls to
BuildDir. See also the corresponding builder method .B Uic()</p>
</dd>

<dt><a name="CV-RANLIB"></a><tt class="ENVAR">RANLIB</tt></dt>

<dd>
<p>The archive indexer.</p>
</dd>

<dt><a name="CV-RANLIBFLAGS"></a><tt class=
"ENVAR">RANLIBFLAGS</tt></dt>

<dd>
<p>General options passed to the archive indexer.</p>
</dd>

<dt><a name="CV-RC"></a><tt class="ENVAR">RC</tt></dt>

<dd>
<p>The resource compiler used by the RES builder.</p>
</dd>

<dt><a name="CV-RCCOM"></a><tt class="ENVAR">RCCOM</tt></dt>

<dd>
<p>The command line used by the RES builder.</p>
</dd>

<dt><a name="CV-RCCOMSTR"></a><tt class="ENVAR">RCCOMSTR</tt></dt>

<dd>
<p>The string displayed when invoking the resource compiler. If
this is not set, then <tt class="ENVAR">$RCCOM</tt> (the command
line) is displayed.</p>
</dd>

<dt><a name="CV-RCFLAGS"></a><tt class="ENVAR">RCFLAGS</tt></dt>

<dd>
<p>The flags passed to the resource compiler by the RES
builder.</p>
</dd>

<dt><a name="CV-RCS"></a><tt class="ENVAR">RCS</tt></dt>

<dd>
<p>The RCS executable. Note that this variable is not actually used
for the command to fetch source files from RCS; see the <tt class=
"ENVAR">$RCS_CO</tt> construction variable, below.</p>
</dd>

<dt><a name="CV-RCS_CO"></a><tt class="ENVAR">RCS_CO</tt></dt>

<dd>
<p>The RCS "checkout" executable, used to fetch source files from
RCS.</p>
</dd>

<dt><a name="CV-RCS_COCOM"></a><tt class=
"ENVAR">RCS_COCOM</tt></dt>

<dd>
<p>The command line used to fetch (checkout) source files from
RCS.</p>
</dd>

<dt><a name="CV-RCS_COCOMSTR"></a><tt class=
"ENVAR">RCS_COCOMSTR</tt></dt>

<dd>
<p>The string displayed when fetching a source file from RCS. If
this is not set, then <tt class="ENVAR">$RCS_COCOM</tt> (the
command line) is displayed.</p>
</dd>

<dt><a name="CV-RCS_COFLAGS"></a><tt class=
"ENVAR">RCS_COFLAGS</tt></dt>

<dd>
<p>Options that are passed to the <tt class="ENVAR">$RCS_CO</tt>
command.</p>
</dd>

<dt><a name="CV-RDIRS"></a><tt class="ENVAR">RDirs</tt></dt>

<dd>
<p>A function that converts a file name into a list of Dir
instances by searching the repositories.</p>
</dd>

<dt><a name="CV-REGSVR"></a><tt class="ENVAR">REGSVR</tt></dt>

<dd>
<p>The program used on WIN32 systems to register a newly-built DLL
library whenever the <tt class="FUNCTION">SharedLibrary</tt>
builder is passed a keyword argument of <tt class=
"LITERAL">register=1</tt>.</p>
</dd>

<dt><a name="CV-REGSVRCOM"></a><tt class=
"ENVAR">REGSVRCOM</tt></dt>

<dd>
<p>The command line used on WIN32 systems to register a newly-built
DLL library whenever the <tt class="FUNCTION">SharedLibrary</tt>
builder is passed a keyword argument of <tt class=
"LITERAL">register=1</tt>.</p>
</dd>

<dt><a name="CV-REGSVRCOMSTR"></a><tt class=
"ENVAR">REGSVRCOMSTR</tt></dt>

<dd>
<p>The string displayed when registering a newly-built DLL file. If
this is not set, then <tt class="ENVAR">$REGSVRCOM</tt> (the
command line) is displayed.</p>
</dd>

<dt><a name="CV-REGSVRFLAGS"></a><tt class=
"ENVAR">REGSVRFLAGS</tt></dt>

<dd>
<p>Flags passed to the DLL registration program on WIN32 systems
when a newly-built DLL library is registered. By default, this
includes the <tt class="OPTION">/s</tt> that prevents dialog boxes
from popping up and requiring user attention.</p>
</dd>

<dt><a name="CV-RMIC"></a><tt class="ENVAR">RMIC</tt></dt>

<dd>
<p>The Java RMI stub compiler.</p>
</dd>

<dt><a name="CV-RMICCOM"></a><tt class="ENVAR">RMICCOM</tt></dt>

<dd>
<p>The command line used to compile stub and skeleton class files
from Java classes that contain RMI implementations. Any options
specified in the <tt class="ENVAR">$RMICFLAGS</tt> construction
variable are included on this command line.</p>
</dd>

<dt><a name="CV-RMICCOMSTR"></a><tt class=
"ENVAR">RMICCOMSTR</tt></dt>

<dd>
<p>The string displayed when compiling stub and skeleton class
files from Java classes that contain RMI implementations. If this
is not set, then <tt class="ENVAR">$RMICCOM</tt> (the command line)
is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(RMICCOMSTR = "Generating stub/skeleton class files $TARGETS from $SOURCES")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-RMICFLAGS"></a><tt class=
"ENVAR">RMICFLAGS</tt></dt>

<dd>
<p>General options passed to the Java RMI stub compiler.</p>
</dd>

<dt><a name="CV-_RPATH"></a><tt class="ENVAR">_RPATH</tt></dt>

<dd>
<p>An automatically-generated construction variable containing the
rpath flags to be used when linking a program with shared
libraries. The value of <tt class="ENVAR">$_RPATH</tt> is created
by appending <tt class="ENVAR">$RPATHPREFIX</tt> and <tt class=
"ENVAR">$RPATHSUFFIX</tt> to the beginning and end of each
directory in <tt class="ENVAR">$RPATH</tt>.</p>
</dd>

<dt><a name="CV-RPATH"></a><tt class="ENVAR">RPATH</tt></dt>

<dd>
<p>A list of paths to search for shared libraries when running
programs. Currently only used in the GNU linker (gnulink) and IRIX
linker (sgilink). Ignored on platforms and toolchains that don't
support it. Note that the paths added to RPATH are not transformed
by <tt class="APPLICATION">scons</tt> in any way: if you want an
absolute path, you must make it absolute yourself.</p>
</dd>

<dt><a name="CV-RPATHPREFIX"></a><tt class=
"ENVAR">RPATHPREFIX</tt></dt>

<dd>
<p>The prefix used to specify a directory to be searched for shared
libraries when running programs. This will be appended to the
beginning of each directory in the <tt class="ENVAR">$RPATH</tt>
construction variable when the <tt class="ENVAR">$_RPATH</tt>
variable is automatically generated.</p>
</dd>

<dt><a name="CV-RPATHSUFFIX"></a><tt class=
"ENVAR">RPATHSUFFIX</tt></dt>

<dd>
<p>The suffix used to specify a directory to be searched for shared
libraries when running programs. This will be appended to the end
of each directory in the <tt class="ENVAR">$RPATH</tt> construction
variable when the <tt class="ENVAR">$_RPATH</tt> variable is
automatically generated.</p>
</dd>

<dt><a name="CV-RPCGEN"></a><tt class="ENVAR">RPCGEN</tt></dt>

<dd>
<p>The RPC protocol compiler.</p>
</dd>

<dt><a name="CV-RPCGENCLIENTFLAGS"></a><tt class=
"ENVAR">RPCGENCLIENTFLAGS</tt></dt>

<dd>
<p>Options passed to the RPC protocol compiler when generating
client side stubs. These are in addition to any flags specified in
the <tt class="ENVAR">$RPCGENFLAGS</tt> construction variable.</p>
</dd>

<dt><a name="CV-RPCGENFLAGS"></a><tt class=
"ENVAR">RPCGENFLAGS</tt></dt>

<dd>
<p>General options passed to the RPC protocol compiler.</p>
</dd>

<dt><a name="CV-RPCGENHEADERFLAGS"></a><tt class=
"ENVAR">RPCGENHEADERFLAGS</tt></dt>

<dd>
<p>Options passed to the RPC protocol compiler when generating a
header file. These are in addition to any flags specified in the
<tt class="ENVAR">$RPCGENFLAGS</tt> construction variable.</p>
</dd>

<dt><a name="CV-RPCGENSERVICEFLAGS"></a><tt class=
"ENVAR">RPCGENSERVICEFLAGS</tt></dt>

<dd>
<p>Options passed to the RPC protocol compiler when generating
server side stubs. These are in addition to any flags specified in
the <tt class="ENVAR">$RPCGENFLAGS</tt> construction variable.</p>
</dd>

<dt><a name="CV-RPCGENXDRFLAGS"></a><tt class=
"ENVAR">RPCGENXDRFLAGS</tt></dt>

<dd>
<p>Options passed to the RPC protocol compiler when generating XDR
routines. These are in addition to any flags specified in the <tt
class="ENVAR">$RPCGENFLAGS</tt> construction variable.</p>
</dd>

<dt><a name="CV-SCANNERS"></a><tt class="ENVAR">SCANNERS</tt></dt>

<dd>
<p>A list of the available implicit dependency scanners. New file
scanners may be added by appending to this list, although the more
flexible approach is to associate scanners with a specific Builder.
See the sections "Builder Objects" and "Scanner Objects," below,
for more information.</p>
</dd>

<dt><a name="CV-SCCS"></a><tt class="ENVAR">SCCS</tt></dt>

<dd>
<p>The SCCS executable.</p>
</dd>

<dt><a name="CV-SCCSCOM"></a><tt class="ENVAR">SCCSCOM</tt></dt>

<dd>
<p>The command line used to fetch source files from SCCS.</p>
</dd>

<dt><a name="CV-SCCSCOMSTR"></a><tt class=
"ENVAR">SCCSCOMSTR</tt></dt>

<dd>
<p>The string displayed when fetching a source file from a CVS
repository. If this is not set, then <tt class=
"ENVAR">$SCCSCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-SCCSFLAGS"></a><tt class=
"ENVAR">SCCSFLAGS</tt></dt>

<dd>
<p>General options that are passed to SCCS.</p>
</dd>

<dt><a name="CV-SCCSGETFLAGS"></a><tt class=
"ENVAR">SCCSGETFLAGS</tt></dt>

<dd>
<p>Options that are passed specifically to the SCCS "get"
subcommand. This can be set, for example, to <tt class=
"OPTION">-e</tt> to check out editable files from SCCS.</p>
</dd>

<dt><a name="CV-SHCC"></a><tt class="ENVAR">SHCC</tt></dt>

<dd>
<p>The C compiler used for generating shared-library objects.</p>
</dd>

<dt><a name="CV-SHCCCOM"></a><tt class="ENVAR">SHCCCOM</tt></dt>

<dd>
<p>The command line used to compile a C source file to a
shared-library object file. Any options specified in the <tt class=
"ENVAR">$SHCCFLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line.</p>
</dd>

<dt><a name="CV-SHCCCOMSTR"></a><tt class=
"ENVAR">SHCCCOMSTR</tt></dt>

<dd>
<p>The string displayed when a C source file is compiled to a
shared object file. If this is not set, then <tt class=
"ENVAR">$SHCCCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(SHCCCOMSTR = "Compiling shared object $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-SHCCFLAGS"></a><tt class=
"ENVAR">SHCCFLAGS</tt></dt>

<dd>
<p>Options that are passed to the C compiler to generate
shared-library objects.</p>
</dd>

<dt><a name="CV-SHCXX"></a><tt class="ENVAR">SHCXX</tt></dt>

<dd>
<p>The C++ compiler used for generating shared-library objects.</p>
</dd>

<dt><a name="CV-SHCXXCOM"></a><tt class="ENVAR">SHCXXCOM</tt></dt>

<dd>
<p>The command line used to compile a C++ source file to a
shared-library object file. Any options specified in the <tt class=
"ENVAR">$SHCXXFLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line.</p>
</dd>

<dt><a name="CV-SHCXXCOMSTR"></a><tt class=
"ENVAR">SHCXXCOMSTR</tt></dt>

<dd>
<p>The string displayed when a C++ source file is compiled to a
shared object file. If this is not set, then <tt class=
"ENVAR">$SHCXXCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(SHCXXCOMSTR = "Compiling shared object $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-SHCXXFLAGS"></a><tt class=
"ENVAR">SHCXXFLAGS</tt></dt>

<dd>
<p>Options that are passed to the C++ compiler to generate
shared-library objects.</p>
</dd>

<dt><a name="CV-SHELL"></a><tt class="ENVAR">SHELL</tt></dt>

<dd>
<p>A string naming the shell program that will be passed to the <tt
class="ENVAR">$SPAWN</tt> function. See the <tt class=
"ENVAR">$SPAWN</tt> construction variable for more information.</p>
</dd>

<dt><a name="CV-SHF77"></a><tt class="ENVAR">SHF77</tt></dt>

<dd>
<p>The Fortran 77 compiler used for generating shared-library
objects. You should normally set the <tt class=
"ENVAR">$SHFORTRAN</tt> variable, which specifies the default
Fortran compiler for all Fortran versions. You only need to set <tt
class="ENVAR">$SHF77</tt> if you need to use a specific compiler or
compiler version for Fortran 77 files.</p>
</dd>

<dt><a name="CV-SHF77COM"></a><tt class="ENVAR">SHF77COM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 77 source file to a
shared-library object file. You only need to set <tt class=
"ENVAR">$SHF77COM</tt> if you need to use a specific command line
for Fortran 77 files. You should normally set the <tt class=
"ENVAR">$SHFORTRANCOM</tt> variable, which specifies the default
command line for all Fortran versions.</p>
</dd>

<dt><a name="CV-SHF77COMSTR"></a><tt class=
"ENVAR">SHF77COMSTR</tt></dt>

<dd>
<p>The string displayed when a Fortran 77 source file is compiled
to a shared-library object file. If this is not set, then <tt
class="ENVAR">$SHF77COM</tt> or <tt class=
"ENVAR">$SHFORTRANCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-SHF77FLAGS"></a><tt class=
"ENVAR">SHF77FLAGS</tt></dt>

<dd>
<p>Options that are passed to the Fortran 77 compiler to generated
shared-library objects. You only need to set <tt class=
"ENVAR">$SHF77FLAGS</tt> if you need to define specific user
options for Fortran 77 files. You should normally set the <tt
class="ENVAR">$SHFORTRANFLAGS</tt> variable, which specifies the
user-specified options passed to the default Fortran compiler for
all Fortran versions.</p>
</dd>

<dt><a name="CV-SHF77PPCOM"></a><tt class=
"ENVAR">SHF77PPCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 77 source file to a
shared-library object file after first running the file through the
C preprocessor. Any options specified in the <tt class=
"ENVAR">$SHF77FLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line. You only
need to set <tt class="ENVAR">$SHF77PPCOM</tt> if you need to use a
specific C-preprocessor command line for Fortran 77 files. You
should normally set the <tt class="ENVAR">$SHFORTRANPPCOM</tt>
variable, which specifies the default C-preprocessor command line
for all Fortran versions.</p>
</dd>

<dt><a name="CV-SHF90"></a><tt class="ENVAR">SHF90</tt></dt>

<dd>
<p>The Fortran 90 compiler used for generating shared-library
objects. You should normally set the <tt class=
"ENVAR">$SHFORTRAN</tt> variable, which specifies the default
Fortran compiler for all Fortran versions. You only need to set <tt
class="ENVAR">$SHF90</tt> if you need to use a specific compiler or
compiler version for Fortran 90 files.</p>
</dd>

<dt><a name="CV-SHF90COM"></a><tt class="ENVAR">SHF90COM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 90 source file to a
shared-library object file. You only need to set <tt class=
"ENVAR">$SHF90COM</tt> if you need to use a specific command line
for Fortran 90 files. You should normally set the <tt class=
"ENVAR">$SHFORTRANCOM</tt> variable, which specifies the default
command line for all Fortran versions.</p>
</dd>

<dt><a name="CV-SHF90COMSTR"></a><tt class=
"ENVAR">SHF90COMSTR</tt></dt>

<dd>
<p>The string displayed when a Fortran 90 source file is compiled
to a shared-library object file. If this is not set, then <tt
class="ENVAR">$SHF90COM</tt> or <tt class=
"ENVAR">$SHFORTRANCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-SHF90FLAGS"></a><tt class=
"ENVAR">SHF90FLAGS</tt></dt>

<dd>
<p>Options that are passed to the Fortran 90 compiler to generated
shared-library objects. You only need to set <tt class=
"ENVAR">$SHF90FLAGS</tt> if you need to define specific user
options for Fortran 90 files. You should normally set the <tt
class="ENVAR">$SHFORTRANFLAGS</tt> variable, which specifies the
user-specified options passed to the default Fortran compiler for
all Fortran versions.</p>
</dd>

<dt><a name="CV-SHF90PPCOM"></a><tt class=
"ENVAR">SHF90PPCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 90 source file to a
shared-library object file after first running the file through the
C preprocessor. Any options specified in the <tt class=
"ENVAR">$SHF90FLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line. You only
need to set <tt class="ENVAR">$SHF90PPCOM</tt> if you need to use a
specific C-preprocessor command line for Fortran 90 files. You
should normally set the <tt class="ENVAR">$SHFORTRANPPCOM</tt>
variable, which specifies the default C-preprocessor command line
for all Fortran versions.</p>
</dd>

<dt><a name="CV-SHF95"></a><tt class="ENVAR">SHF95</tt></dt>

<dd>
<p>The Fortran 95 compiler used for generating shared-library
objects. You should normally set the <tt class=
"ENVAR">$SHFORTRAN</tt> variable, which specifies the default
Fortran compiler for all Fortran versions. You only need to set <tt
class="ENVAR">$SHF95</tt> if you need to use a specific compiler or
compiler version for Fortran 95 files.</p>
</dd>

<dt><a name="CV-SHF95COM"></a><tt class="ENVAR">SHF95COM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 95 source file to a
shared-library object file. You only need to set <tt class=
"ENVAR">$SHF95COM</tt> if you need to use a specific command line
for Fortran 95 files. You should normally set the <tt class=
"ENVAR">$SHFORTRANCOM</tt> variable, which specifies the default
command line for all Fortran versions.</p>
</dd>

<dt><a name="CV-SHF95COMSTR"></a><tt class=
"ENVAR">SHF95COMSTR</tt></dt>

<dd>
<p>The string displayed when a Fortran 95 source file is compiled
to a shared-library object file. If this is not set, then <tt
class="ENVAR">$SHF95COM</tt> or <tt class=
"ENVAR">$SHFORTRANCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-SHF95FLAGS"></a><tt class=
"ENVAR">SHF95FLAGS</tt></dt>

<dd>
<p>Options that are passed to the Fortran 95 compiler to generated
shared-library objects. You only need to set <tt class=
"ENVAR">$SHF95FLAGS</tt> if you need to define specific user
options for Fortran 95 files. You should normally set the <tt
class="ENVAR">$SHFORTRANFLAGS</tt> variable, which specifies the
user-specified options passed to the default Fortran compiler for
all Fortran versions.</p>
</dd>

<dt><a name="CV-SHF95PPCOM"></a><tt class=
"ENVAR">SHF95PPCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran 95 source file to a
shared-library object file after first running the file through the
C preprocessor. Any options specified in the <tt class=
"ENVAR">$SHF95FLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line. You only
need to set <tt class="ENVAR">$SHF95PPCOM</tt> if you need to use a
specific C-preprocessor command line for Fortran 95 files. You
should normally set the <tt class="ENVAR">$SHFORTRANPPCOM</tt>
variable, which specifies the default C-preprocessor command line
for all Fortran versions.</p>
</dd>

<dt><a name="CV-SHFORTRAN"></a><tt class=
"ENVAR">SHFORTRAN</tt></dt>

<dd>
<p>The default Fortran compiler used for generating shared-library
objects.</p>
</dd>

<dt><a name="CV-SHFORTRANCOM"></a><tt class=
"ENVAR">SHFORTRANCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran source file to a
shared-library object file.</p>
</dd>

<dt><a name="CV-SHFORTRANCOMSTR"></a><tt class=
"ENVAR">SHFORTRANCOMSTR</tt></dt>

<dd>
<p>The string displayed when a Fortran source file is compiled to a
shared-library object file. If this is not set, then <tt class=
"ENVAR">$SHFORTRANCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-SHFORTRANFLAGS"></a><tt class=
"ENVAR">SHFORTRANFLAGS</tt></dt>

<dd>
<p>Options that are passed to the Fortran compiler to generate
shared-library objects.</p>
</dd>

<dt><a name="CV-SHFORTRANPPCOM"></a><tt class=
"ENVAR">SHFORTRANPPCOM</tt></dt>

<dd>
<p>The command line used to compile a Fortran source file to a
shared-library object file after first running the file through the
C preprocessor. Any options specified in the <tt class=
"ENVAR">$SHFORTRANFLAGS</tt> and <tt class="ENVAR">$CPPFLAGS</tt>
construction variables are included on this command line.</p>
</dd>

<dt><a name="CV-SHLIBPREFIX"></a><tt class=
"ENVAR">SHLIBPREFIX</tt></dt>

<dd>
<p>The prefix used for shared library file names.</p>
</dd>

<dt><a name="CV-SHLIBSUFFIX"></a><tt class=
"ENVAR">SHLIBSUFFIX</tt></dt>

<dd>
<p>The suffix used for shared library file names.</p>
</dd>

<dt><a name="CV-SHLINK"></a><tt class="ENVAR">SHLINK</tt></dt>

<dd>
<p>The linker for programs that use shared libraries.</p>
</dd>

<dt><a name="CV-SHLINKCOM"></a><tt class=
"ENVAR">SHLINKCOM</tt></dt>

<dd>
<p>The command line used to link programs using shared
libaries.</p>
</dd>

<dt><a name="CV-SHLINKCOMSTR"></a><tt class=
"ENVAR">SHLINKCOMSTR</tt></dt>

<dd>
<p>The string displayed when programs using shared libraries are
linked. If this is not set, then <tt class="ENVAR">$SHLINKCOM</tt>
(the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(SHLINKCOMSTR = "Linking shared $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-SHLINKFLAGS"></a><tt class=
"ENVAR">SHLINKFLAGS</tt></dt>

<dd>
<p>General user options passed to the linker for programs using
shared libraries. Note that this variable should <i class=
"EMPHASIS">not</i> contain <tt class="OPTION">-l</tt> (or similar)
options for linking with the libraries listed in <tt class=
"ENVAR">$LIBS</tt>, nor <tt class="OPTION">-L</tt> (or similar)
include search path options that scons generates automatically from
<tt class="ENVAR">$LIBPATH</tt>. See <tt class=
"ENVAR">$_LIBFLAGS</tt> above, for the variable that expands to
library-link options, and <tt class="ENVAR">$_LIBDIRFLAGS</tt>
above, for the variable that expands to library search path
options.</p>
</dd>

<dt><a name="CV-SHOBJPREFIX"></a><tt class=
"ENVAR">SHOBJPREFIX</tt></dt>

<dd>
<p>The prefix used for shared object file names.</p>
</dd>

<dt><a name="CV-SHOBJSUFFIX"></a><tt class=
"ENVAR">SHOBJSUFFIX</tt></dt>

<dd>
<p>The suffix used for shared object file names.</p>
</dd>

<dt><a name="CV-SOURCE"></a><tt class="ENVAR">SOURCE</tt></dt>

<dd>
<p>A reserved variable name that may not be set or used in a
construction environment. (See "Variable Substitution," below.)</p>
</dd>

<dt><a name="CV-SOURCES"></a><tt class="ENVAR">SOURCES</tt></dt>

<dd>
<p>A reserved variable name that may not be set or used in a
construction environment. (See "Variable Substitution," below.)</p>
</dd>

<dt><a name="CV-SPAWN"></a><tt class="ENVAR">SPAWN</tt></dt>

<dd>
<p>A command interpreter function that will be called to execute
command line strings. The function must expect the following
arguments:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
def spawn(shell, escape, cmd, args, env):
</pre>
</td>
</tr>
</table>

<p><tt class="VARNAME">sh</tt> is a string naming the shell program
to use. <tt class="VARNAME">escape</tt> is a function that can be
called to escape shell special characters in the command line. <tt
class="VARNAME">cmd</tt> is the path to the command to be executed.
<tt class="VARNAME">args</tt> is the arguments to the command. <tt
class="VARNAME">env</tt> is a dictionary of the environment
variables in which the command should be executed.</p>
</dd>

<dt><a name="CV-SWIG"></a><tt class="ENVAR">SWIG</tt></dt>

<dd>
<p>The scripting language wrapper and interface generator.</p>
</dd>

<dt><a name="CV-SWIGCFILESUFFIX"></a><tt class=
"ENVAR">SWIGCFILESUFFIX</tt></dt>

<dd>
<p>The suffix that will be used for intermediate C source files
generated by the scripting language wrapper and interface
generator. The default value is <tt class="FILENAME">_wrap</tt><tt
class="ENVAR">$CFILESUFFIX</tt>. By default, this value is used
whenever the <tt class="OPTION">-c++</tt> option is <i class=
"EMPHASIS">not</i> specified as part of the <tt class=
"ENVAR">$SWIGFLAGS</tt> construction variable.</p>
</dd>

<dt><a name="CV-SWIGCOM"></a><tt class="ENVAR">SWIGCOM</tt></dt>

<dd>
<p>The command line used to call the scripting language wrapper and
interface generator.</p>
</dd>

<dt><a name="CV-SWIGCOMSTR"></a><tt class=
"ENVAR">SWIGCOMSTR</tt></dt>

<dd>
<p>The string displayed when calling the scripting language wrapper
and interface generator. If this is not set, then <tt class=
"ENVAR">$SWIGCOM</tt> (the command line) is displayed.</p>
</dd>

<dt><a name="CV-SWIGCXXFILESUFFIX"></a><tt class=
"ENVAR">SWIGCXXFILESUFFIX</tt></dt>

<dd>
<p>The suffix that will be used for intermediate C++ source files
generated by the scripting language wrapper and interface
generator. The default value is <tt class="FILENAME">_wrap</tt><tt
class="ENVAR">$CFILESUFFIX</tt>. By default, this value is used
whenever the <tt class="FILENAME">-c++</tt> option is specified as
part of the <tt class="ENVAR">$SWIGFLAGS</tt> construction
variable.</p>
</dd>

<dt><a name="CV-SWIGFLAGS"></a><tt class=
"ENVAR">SWIGFLAGS</tt></dt>

<dd>
<p>General options passed to the scripting language wrapper and
interface generator. This is where you should set <tt class=
"OPTION">-python</tt>, <tt class="OPTION">-perl5</tt>, <tt class=
"OPTION">-tcl</tt>, or whatever other options you want to specify
to SWIG. If you set the <tt class="OPTION">-c++</tt> option in this
variable, <tt class="APPLICATION">scons</tt> will, by default,
generate a C++ intermediate source file with the extension that is
specified as the <tt class="ENVAR">$CXXFILESUFFIX</tt>
variable.</p>
</dd>

<dt><a name="CV-TAR"></a><tt class="ENVAR">TAR</tt></dt>

<dd>
<p>The tar archiver.</p>
</dd>

<dt><a name="CV-TARCOM"></a><tt class="ENVAR">TARCOM</tt></dt>

<dd>
<p>The command line used to call the tar archiver.</p>
</dd>

<dt><a name="CV-TARCOMSTR"></a><tt class=
"ENVAR">TARCOMSTR</tt></dt>

<dd>
<p>The string displayed when archiving files using the tar
archiver. If this is not set, then <tt class="ENVAR">$TARCOM</tt>
(the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(TARCOMSTR = "Archiving $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-TARFLAGS"></a><tt class="ENVAR">TARFLAGS</tt></dt>

<dd>
<p>General options passed to the tar archiver.</p>
</dd>

<dt><a name="CV-TARGET"></a><tt class="ENVAR">TARGET</tt></dt>

<dd>
<p>A reserved variable name that may not be set or used in a
construction environment. (See "Variable Substitution," below.)</p>
</dd>

<dt><a name="CV-TARGETS"></a><tt class="ENVAR">TARGETS</tt></dt>

<dd>
<p>A reserved variable name that may not be set or used in a
construction environment. (See "Variable Substitution," below.)</p>
</dd>

<dt><a name="CV-TARSUFFIX"></a><tt class=
"ENVAR">TARSUFFIX</tt></dt>

<dd>
<p>The suffix used for tar file names.</p>
</dd>

<dt><a name="CV-TEX"></a><tt class="ENVAR">TEX</tt></dt>

<dd>
<p>The TeX formatter and typesetter.</p>
</dd>

<dt><a name="CV-TEXCOM"></a><tt class="ENVAR">TEXCOM</tt></dt>

<dd>
<p>The command line used to call the TeX formatter and
typesetter.</p>
</dd>

<dt><a name="CV-TEXCOMSTR"></a><tt class=
"ENVAR">TEXCOMSTR</tt></dt>

<dd>
<p>The string displayed when calling the TeX formatter and
typesetter. If this is not set, then <tt class="ENVAR">$TEXCOM</tt>
(the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(TEXCOMSTR = "Building $TARGET from TeX input $SOURCES")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-TEXFLAGS"></a><tt class="ENVAR">TEXFLAGS</tt></dt>

<dd>
<p>General options passed to the TeX formatter and typesetter.</p>
</dd>

<dt><a name="CV-TOOLS"></a><tt class="ENVAR">TOOLS</tt></dt>

<dd>
<p>A list of the names of the Tool specifications that are part of
this construction environment.</p>
</dd>

<dt><a name="CV-WIN32_INSERT_DEF"></a><tt class=
"ENVAR">WIN32_INSERT_DEF</tt></dt>

<dd>
<p>When this is set to true, a library build of a WIN32 shared
library (.dll file) will also build a corresponding .def file at
the same time, if a .def file is not already listed as a build
target. The default is 0 (do not build a .def file).</p>
</dd>

<dt><a name="CV-WIN32DEFPREFIX"></a><tt class=
"ENVAR">WIN32DEFPREFIX</tt></dt>

<dd>
<p>The prefix used for WIN32 .def file names.</p>
</dd>

<dt><a name="CV-WIN32DEFSUFFIX"></a><tt class=
"ENVAR">WIN32DEFSUFFIX</tt></dt>

<dd>
<p>The suffix used for WIN32 .def file names.</p>
</dd>

<dt><a name="CV-WIN32EXPPREFIX"></a><tt class=
"ENVAR">WIN32EXPPREFIX</tt></dt>

<dd>
<p>XXX The prefix used for WIN32 .def file names.</p>
</dd>

<dt><a name="CV-WIN32EXPSUFFIX"></a><tt class=
"ENVAR">WIN32EXPSUFFIX</tt></dt>

<dd>
<p>XXX The suffix used for WIN32 .def file names.</p>
</dd>

<dt><a name="CV-YACC"></a><tt class="ENVAR">YACC</tt></dt>

<dd>
<p>The parser generator.</p>
</dd>

<dt><a name="CV-YACCCOM"></a><tt class="ENVAR">YACCCOM</tt></dt>

<dd>
<p>The command line used to call the parser generator to generate a
source file.</p>
</dd>

<dt><a name="CV-YACCCOMSTR"></a><tt class=
"ENVAR">YACCCOMSTR</tt></dt>

<dd>
<p>The string displayed when generating a source file using the
parser generator. If this is not set, then <tt class=
"ENVAR">$YACCCOM</tt> (the command line) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(YACCCOMSTR = "Yacc'ing $TARGET from $SOURCES")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-YACCFLAGS"></a><tt class=
"ENVAR">YACCFLAGS</tt></dt>

<dd>
<p>General options passed to the parser generator. If <tt class=
"ENVAR">$YACCFLAGS</tt> contains a <tt class="OPTION">-d</tt>
option, SCons assumes that the call will also create a .h file (if
the yacc source file ends in a .y suffix) or a .hpp file (if the
yacc source file ends in a .yy suffix)</p>
</dd>

<dt><a name="CV-ZIP"></a><tt class="ENVAR">ZIP</tt></dt>

<dd>
<p>The zip compression and file packaging utility.</p>
</dd>

<dt><a name="CV-ZIPCOM"></a><tt class="ENVAR">ZIPCOM</tt></dt>

<dd>
<p>The command line used to call the zip utility, or the internal
Python function used to create a zip archive.</p>
</dd>

<dt><a name="CV-ZIPCOMPRESSION"></a><tt class=
"ENVAR">ZIPCOMPRESSION</tt></dt>

<dd>
<p>The <tt class="VARNAME">compression</tt> flag from the Python
<tt class="FILENAME">zipfile</tt> module used by the internal
Python function to control whether the zip archive is compressed or
not. The default value is <tt class=
"VARNAME">zipfile.ZIP_DEFLATED</tt>, which creates a compressed zip
archive. This value has no effect when using Python 1.5.2 or if the
<tt class="VARNAME">zipfile</tt> module is otherwise
unavailable.</p>
</dd>

<dt><a name="CV-ZIPCOMSTR"></a><tt class=
"ENVAR">ZIPCOMSTR</tt></dt>

<dd>
<p>The string displayed when archiving files using the zip utility.
If this is not set, then <tt class="ENVAR">$ZIPCOM</tt> (the
command line or internal Python function) is displayed.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env = Environment(ZIPCOMSTR = "Zipping $TARGET")
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="CV-ZIPFLAGS"></a><tt class="ENVAR">ZIPFLAGS</tt></dt>

<dd>
<p>General options passed to the zip utility.</p>
</dd>
</dl>
</div>
</div>

<div class="APPENDIX">
<hr>
<h1><a name="APP-BUILDERS"></a>Builders</h1>

<p>&#13;This appendix contains descriptions of all of the Builders
that are <i class="EMPHASIS">potentially</i> available "out of the
box" in this version of SCons.&#13;</p>

<div class="VARIABLELIST">
<dl>
<dt><a name="B-CFILE"></a><tt class="FUNCTION">CFile()</tt>, <tt
class="FUNCTION">env.CFile()</tt></dt>

<dd>
<p>Builds a C source file given a lex (<tt class=
"FILENAME">.l</tt>) or yacc (<tt class="FILENAME">.y</tt>) input
file. The suffix specified by the <tt class=
"ENVAR">$CFILESUFFIX</tt> construction variable (<tt class=
"FILENAME">.c</tt> by default) is automatically added to the target
if it is not already present. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# builds foo.c
env.CFile(target = 'foo.c', source = 'foo.l')
# builds bar.c
env.CFile(target = 'bar', source = 'bar.y')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-CXXFILE"></a><tt class="FUNCTION">CXXFile()</tt>,
<tt class="FUNCTION">env.CXXFile()</tt></dt>

<dd>
<p>Builds a C++ source file given a lex (<tt class=
"FILENAME">.ll</tt>) or yacc (<tt class="FILENAME">.yy</tt>) input
file. The suffix specified by the <tt class=
"ENVAR">$CXXFILESUFFIX</tt> construction variable (<tt class=
"FILENAME">.cc</tt> by default) is automatically added to the
target if it is not already present. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# builds foo.cc
env.CXXFile(target = 'foo.cc', source = 'foo.ll')
# builds bar.cc
env.CXXFile(target = 'bar', source = 'bar.yy')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-DVI"></a><tt class="FUNCTION">DVI()</tt>, <tt class=
"FUNCTION">env.DVI()</tt></dt>

<dd>
<p>Builds a <tt class="FILENAME">.dvi</tt> file from a <tt class=
"FILENAME">.tex</tt>, <tt class="FILENAME">.ltx</tt> or <tt class=
"FILENAME">.latex</tt> input file. If the source file suffix is <tt
class="FILENAME">.tex</tt>, <tt class="APPLICATION">scons</tt> will
examine the contents of the file; if the string <tt class=
"LITERAL">\documentclass</tt> or <tt class=
"LITERAL">\documentstyle</tt> is found, the file is assumed to be a
LaTeX file and the target is built by invoking the <tt class=
"ENVAR">$LATEXCOM</tt> command line; otherwise, the <tt class=
"ENVAR">$TEXCOM</tt> command line is used. If the file is a LaTeX
file, the <tt class="FUNCTION">DVI</tt> builder method will also
examine the contents of the <tt class="FILENAME">.aux</tt> file and
invoke the <tt class="ENVAR">$BIBTEX</tt> command line if the
string <tt class="LITERAL">bibdata</tt> is found, and will examine
the contents <tt class="FILENAME">.log</tt> file and re-run the <tt
class="ENVAR">$LATEXCOM</tt> command if the log file says it is
necessary.</p>

<p>The suffix <tt class="FILENAME">.dvi</tt> (hard-coded within TeX
itself) is automatically added to the target if it is not already
present. Examples:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# builds from aaa.tex
env.DVI(target = 'aaa.dvi', source = 'aaa.tex')
# builds bbb.dvi
env.DVI(target = 'bbb', source = 'bbb.ltx')
# builds from ccc.latex
env.DVI(target = 'ccc.dvi', source = 'ccc.latex')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-JAR"></a><tt class="FUNCTION">Jar()</tt>, <tt class=
"FUNCTION">env.Jar()</tt></dt>

<dd>
<p>Builds a Java archive (<tt class="FILENAME">.jar</tt>) file from
a source tree of <tt class="FILENAME">.class</tt> files. If the <tt
class="ENVAR">$JARCHDIR</tt> value is set, the <tt class=
"APPLICATION">jar</tt> command will change to the specified
directory using the <tt class="OPTION">-C</tt> option. If the
contents any of the source files begin with the string <tt class=
"LITERAL">Manifest-Version</tt>, the file is assumed to be a
manifest and is passed to the <tt class="APPLICATION">jar</tt>
command with the <tt class="OPTION">m</tt> option set.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.Jar(target = 'foo.jar', source = 'classes')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-JAVA"></a><tt class="FUNCTION">Java()</tt>, <tt
class="FUNCTION">env.Java()</tt></dt>

<dd>
<p>Builds one or more Java class files from one or more source
trees of <tt class="FILENAME">.java</tt> files. The class files
will be placed underneath the specified target directory. SCons
will parse each source <tt class="FILENAME">.java</tt> file to find
the classes (including inner classes) defined within that file, and
from that figure out the target <tt class="FILENAME">.class</tt>
files that will be created. SCons will also search each Java file
for the Java package name, which it assumes can be found on a line
beginning with the string <tt class="LITERAL">package</tt> in the
first column; the resulting <tt class="FILENAME">.class</tt> files
will be placed in a directory reflecting the specified package
name. For example, the file <tt class="FILENAME">Foo.java</tt>
defining a single public <tt class="CLASSNAME">Foo</tt> class and
containing a package name of <tt class="CLASSNAME">sub.dir</tt>
will generate a corresponding <tt class=
"FILENAME">sub/dir/Foo.class</tt> class file.</p>

<p>Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.Java(target = 'classes', source = 'src')
env.Java(target = 'classes', source = ['src1', 'src2'])
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-JAVAH"></a><tt class="FUNCTION">JavaH()</tt>, <tt
class="FUNCTION">env.JavaH()</tt></dt>

<dd>
<p>Builds C header and source files for implementing Java native
methods. The target can be either a directory in which the header
files will be written, or a header file name which will contain all
of the definitions. The source can be either the names of <tt
class="FILENAME">.class</tt> files, or the objects returned from
the <tt class="FUNCTION">Java</tt> builder method.</p>

<p>If the construction variable <tt class=
"ENVAR">$JAVACLASSDIR</tt> is set, either in the environment or in
the call to the <tt class="FUNCTION">JavaH</tt> builder method
itself, then the value of the variable will be stripped from the
beginning of any <tt class="FILENAME">.class</tt> file names.</p>

<p>Examples:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# builds java_native.h
classes = env.Java(target = 'classdir', source = 'src')
env.JavaH(target = 'java_native.h', source = classes)

# builds include/package_foo.h and include/package_bar.h
env.JavaH(target = 'include',
          source = ['package/foo.class', 'package/bar.class'])

# builds export/foo.h and export/bar.h
env.JavaH(target = 'export',
          source = ['classes/foo.class', 'classes/bar.class'],
          JAVACLASSDIR = 'classes')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-LIBRARY"></a><tt class="FUNCTION">Library()</tt>,
<tt class="FUNCTION">env.Library()</tt></dt>

<dd>
<p>A synonym for the <tt class="FUNCTION">StaticLibrary</tt>
builder method.</p>
</dd>

<dt><a name="B-M4"></a><tt class="FUNCTION">M4()</tt>, <tt class=
"FUNCTION">env.M4()</tt></dt>

<dd>
<p>Builds an output file from an M4 input file. This uses a default
<tt class="ENVAR">$M4FLAGS</tt> value of <tt class=
"OPTION">-E</tt>, which considers all warnings to be fatal and
stops on the first warning when using the GNU version of m4.
Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.M4(target = 'foo.c', source = 'foo.c.m4')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-MOC"></a><tt class="FUNCTION">Moc()</tt>, <tt class=
"FUNCTION">env.Moc()</tt></dt>

<dd>
<p>Builds an output file from a moc input file. Moc input files are
either header files or cxx files. This builder is only available
after using the tool 'qt'. See the <tt class="ENVAR">$QTDIR</tt>
variable for more information. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.Moc('foo.h') # generates moc_foo.cc
env.Moc('foo.cpp') # generates foo.moc
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-MSVSPROJECT"></a><tt class=
"FUNCTION">MSVSProject()</tt>, <tt class=
"FUNCTION">env.MSVSProject()</tt></dt>

<dd>
<p>Builds Microsoft Visual Studio project files. This builds a
Visual Studio project file, based on the version of Visual Studio
that is configured (either the latest installed version, or the
version set by <tt class="ENVAR">$MSVS_VERSION</tt> in the
Environment constructor). For VS 6, it will generate <tt class=
"FILENAME">.dsp</tt> and <tt class="FILENAME">.dsw</tt> files, for
VS 7, it will generate <tt class="FILENAME">.vcproj</tt> and <tt
class="FILENAME">.sln</tt> files.</p>

<p>It takes several lists of filenames to be placed into the
project file, currently these are limited to <tt class=
"LITERAL">srcs</tt>, <tt class="LITERAL">incs</tt>, <tt class=
"LITERAL">localincs</tt>, <tt class="LITERAL">resources</tt>, and
<tt class="LITERAL">misc</tt>. These are pretty self explanatory,
but it should be noted that the <tt class="LITERAL">srcs</tt> list
is NOT added to the <tt class="ENVAR">$SOURCES</tt> construction
variable. This is because it represents a list of files to be added
to the project file, not the source used to build the project file
(in this case, the "source" is the <tt class=
"FILENAME">SConscript</tt> file used to call MSVSProject).</p>

<p>In addition to these values (which are all optional, although
not specifying any of them results in an empty project file), the
following values must be specified:</p>

<p>target: The name of the target <tt class="FILENAME">.dsp</tt> or
<tt class="FILENAME">.vcproj</tt> file. The correct suffix for the
version of Visual Studio must be used, but the <tt class=
"ENVAR">$MSVSPROJECTSUFFIX</tt> construction value will be defined
to the correct value (see example below).</p>

<p>variant: The name of this particular variant. These are
typically things like "Debug" or "Release", but really can be
anything you want. Multiple calls to MSVSProject with different
variants are allowed: all variants will be added to the project
file with their appropriate build targets and sources.</p>

<p>buildtarget: A list of SCons.Node.FS objects which is returned
from the command which builds the target. This is used to tell
SCons what to build when the 'build' button is pressed inside of
the IDE.</p>

<p>Example usage:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
barsrcs = ['bar.cpp'],
barincs = ['bar.h'],
barlocalincs = ['StdAfx.h']
barresources = ['bar.rc','resource.h']
barmisc = ['bar_readme.txt']

dll = local.SharedLibrary(target = 'bar.dll',
                          source = barsrcs)

local.MSVSProject(target = 'Bar' + env['MSVSPROJECTSUFFIX'],
                  srcs = barsrcs,
                  incs = barincs,
                  localincs = barlocalincs,
                  resources = barresources,
                  misc = barmisc,
                  buildtarget = dll,
                  variant = 'Release')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-OBJECT"></a><tt class="FUNCTION">Object()</tt>, <tt
class="FUNCTION">env.Object()</tt></dt>

<dd>
<p>A synonym for the <tt class="FUNCTION">StaticObject</tt> builder
method.</p>
</dd>

<dt><a name="B-PCH"></a><tt class="FUNCTION">PCH()</tt>, <tt class=
"FUNCTION">env.PCH()</tt></dt>

<dd>
<p>Builds a Microsoft Visual C++ precompiled header. Calling this
builder method returns a list of two targets: the PCH as the first
element, and the object file as the second element. Normally the
object file is ignored. This builder method is only provided when
Microsoft Visual C++ is being used as the compiler. The PCH builder
method is generally used in conjuction with the PCH construction
variable to force object files to use the precompiled header:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env['PCH'] = env.PCH('StdAfx.cpp')[0]
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-PDF"></a><tt class="FUNCTION">PDF()</tt>, <tt class=
"FUNCTION">env.PDF()</tt></dt>

<dd>
<p>Builds a <tt class="FILENAME">.pdf</tt> file from a <tt class=
"FILENAME">.dvi</tt> input file (or, by extension, a <tt class=
"FILENAME">.tex</tt>, <tt class="FILENAME">.ltx</tt>, or <tt class=
"FILENAME">.latex</tt> input file). The suffix specified by the <tt
class="ENVAR">$PDFSUFFIX</tt> construction variable (<tt class=
"FILENAME">.pdf</tt> by default) is added automatically to the
target if it is not already present. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# builds from aaa.tex
env.PDF(target = 'aaa.pdf', source = 'aaa.tex')
# builds bbb.pdf from bbb.dvi
env.PDF(target = 'bbb', source = 'bbb.dvi')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-POSTSCRIPT"></a><tt class=
"FUNCTION">PostScript()</tt>, <tt class=
"FUNCTION">env.PostScript()</tt></dt>

<dd>
<p>Builds a <tt class="FILENAME">.ps</tt> file from a <tt class=
"FILENAME">.dvi</tt> input file (or, by extension, a <tt class=
"FILENAME">.tex</tt>, <tt class="FILENAME">.ltx</tt>, or <tt class=
"FILENAME">.latex</tt> input file). The suffix specified by the <tt
class="ENVAR">$PSSUFFIX</tt> construction variable (<tt class=
"FILENAME">.ps</tt> by default) is added automatically to the
target if it is not already present. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# builds from aaa.tex
env.PostScript(target = 'aaa.ps', source = 'aaa.tex')
# builds bbb.ps from bbb.dvi
env.PostScript(target = 'bbb', source = 'bbb.dvi')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-PROGRAM"></a><tt class="FUNCTION">Program()</tt>,
<tt class="FUNCTION">env.Program()</tt></dt>

<dd>
<p>Builds an executable given one or more object files or C, C++,
D, or Fortran source files. If any C, C++, D or Fortran source
files are specified, then they will be automatically compiled to
object files using the <tt class="FUNCTION">Object</tt> builder
method; see that builder method's description for a list of legal
source file suffixes and how they are interpreted. The target
executable file prefix (specified by the <tt class=
"ENVAR">$PROGPREFIX</tt> construction variable; nothing by default)
and suffix (specified by the <tt class="ENVAR">$PROGSUFFIX</tt>
construction variable; by default, <tt class="FILENAME">.exe</tt>
on Windows systems, nothing on POSIX systems) are automatically
added to the target if not already present. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.Program(target = 'foo', source = ['foo.o', 'bar.c', 'baz.f'])
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-RES"></a><tt class="FUNCTION">RES()</tt>, <tt class=
"FUNCTION">env.RES()</tt></dt>

<dd>
<p>Builds a Microsoft Visual C++ resource file. This builder method
is only provided when Microsoft Visual C++ or MinGW is being used
as the compiler. The <tt class="FILENAME">.res</tt> (or <tt class=
"FILENAME">.o</tt> for MinGW) suffix is added to the target name if
no other suffix is given. The source file is scanned for implicit
dependencies as though it were a C file. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.RES('resource.rc')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-RMIC"></a><tt class="FUNCTION">RMIC()</tt>, <tt
class="FUNCTION">env.RMIC()</tt></dt>

<dd>
<p>Builds stub and skeleton class files for remote objects from
Java <tt class="FILENAME">.class</tt> files. The target is a
directory relative to which the stub and skeleton class files will
be written. The source can be the names of <tt class=
"FILENAME">.class</tt> files, or the objects return from the <tt
class="FUNCTION">Java</tt> builder method.</p>

<p>If the construction variable <tt class=
"ENVAR">$JAVACLASSDIR</tt> is set, either in the environment or in
the call to the <tt class="FUNCTION">RMIC</tt> builder method
itself, then the value of the variable will be stripped from the
beginning of any <tt class="FILENAME">.class</tt> file names.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
classes = env.Java(target = 'classdir', source = 'src')
env.RMIC(target = 'outdir1', source = classes)

env.RMIC(target = 'outdir2',
         source = ['package/foo.class', 'package/bar.class'])

env.RMIC(target = 'outdir3',
         source = ['classes/foo.class', 'classes/bar.class'],
         JAVACLASSDIR = 'classes')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-RPCGENCLIENT"></a><tt class=
"FUNCTION">RPCGenClient()</tt>, <tt class=
"FUNCTION">env.RPCGenClient()</tt></dt>

<dd>
<p>Generates an RPC client stub (<tt class="FILENAME">_clnt.c</tt>)
file from a specified RPC (<tt class="FILENAME">.x</tt>) source
file. Because rpcgen only builds output files in the local
directory, the command will be executed in the source file's
directory by default.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# Builds src/rpcif_clnt.c
env.RPCGenClient('src/rpcif.x')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-RPCGENHEADER"></a><tt class=
"FUNCTION">RPCGenHeader()</tt>, <tt class=
"FUNCTION">env.RPCGenHeader()</tt></dt>

<dd>
<p>Generates an RPC header (<tt class="FILENAME">.h</tt>) file from
a specified RPC (<tt class="FILENAME">.x</tt>) source file. Because
rpcgen only builds output files in the local directory, the command
will be executed in the source file's directory by default.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# Builds src/rpcif.h
env.RPCGenHeader('src/rpcif.x')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-RPCGENSERVICE"></a><tt class=
"FUNCTION">RPCGenService()</tt>, <tt class=
"FUNCTION">env.RPCGenService()</tt></dt>

<dd>
<p>Generates an RPC server-skeleton (<tt class=
"FILENAME">_svc.c</tt>) file from a specified RPC (<tt class=
"FILENAME">.x</tt>) source file. Because rpcgen only builds output
files in the local directory, the command will be executed in the
source file's directory by default.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# Builds src/rpcif_svc.c
env.RPCGenClient('src/rpcif.x')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-RPCGENXDR"></a><tt class=
"FUNCTION">RPCGenXDR()</tt>, <tt class=
"FUNCTION">env.RPCGenXDR()</tt></dt>

<dd>
<p>Generates an RPC XDR routine (<tt class="FILENAME">_xdr.c</tt>)
file from a specified RPC (<tt class="FILENAME">.x</tt>) source
file. Because rpcgen only builds output files in the local
directory, the command will be executed in the source file's
directory by default.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
# Builds src/rpcif_xdr.c
env.RPCGenClient('src/rpcif.x')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-SHAREDLIBRARY"></a><tt class=
"FUNCTION">SharedLibrary()</tt>, <tt class=
"FUNCTION">env.SharedLibrary()</tt></dt>

<dd>
<p>Builds a shared library (<tt class="FILENAME">.so</tt> on a
POSIX system, <tt class="FILENAME">.dll</tt> on WIN32) given one or
more object files or C, C++, D or Fortran source files. If any
source files are given, then they will be automatically compiled to
object files. The static library prefix and suffix (if any) are
automatically added to the target. The target library file prefix
(specified by the <tt class="ENVAR">$SHLIBPREFIX</tt> construction
variable; by default, <tt class="FILENAME">lib</tt> on POSIX
systems, nothing on Windows systems) and suffix (specified by the
<tt class="ENVAR">$SHLIBSUFFIX</tt> construction variable; by
default, <tt class="FILENAME">.dll</tt> on Windows systems, <tt
class="FILENAME">.so</tt> on POSIX systems) are automatically added
to the target if not already present. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.SharedLibrary(target = 'bar', source = ['bar.c', 'foo.o'])
</pre>
</td>
</tr>
</table>

<p>On WIN32 systems, the <tt class="FUNCTION">SharedLibrary</tt>
builder method will always build an import (<tt class=
"FILENAME">.lib</tt>) library in addition to the shared (<tt class=
"FILENAME">.dll</tt>) library, adding a <tt class=
"FILENAME">.lib</tt> library with the same basename if there is not
already a <tt class="FILENAME">.lib</tt> file explicitly listed in
the targets.</p>

<p>Any object files listed in the <tt class="LITERAL">source</tt>
must have been built for a shared library (that is, using the <tt
class="FUNCTION">SharedObject</tt> builder method). <tt class=
"APPLICATION">scons</tt> will raise an error if there is any
mismatch.</p>

<p>On WIN32 systems, specifying <tt class="LITERAL">register=1</tt>
will cause the <tt class="FILENAME">.dll</tt> to be registered
after it is built using REGSVR32. The command that is run
("regsvr32" by default) is determined by <tt class=
"ENVAR">$REGSVR</tt> construction variable, and the flags passed
are determined by <tt class="ENVAR">$REGSVRFLAGS</tt>. By default,
<tt class="ENVAR">$REGSVRFLAGS</tt> includes the <tt class=
"OPTION">/s</tt> option, to prevent dialogs from popping up and
requiring user attention when it is run. If you change <tt class=
"ENVAR">$REGSVRFLAGS</tt>, be sure to include the <tt class=
"OPTION">/s</tt> option. For example,</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.SharedLibrary(target = 'bar',
                  source = ['bar.cxx', 'foo.obj'],
                  register=1)
</pre>
</td>
</tr>
</table>

<p>will register <tt class="FILENAME">bar.dll</tt> as a COM object
when it is done linking it.</p>
</dd>

<dt><a name="B-SHAREDOBJECT"></a><tt class=
"FUNCTION">SharedObject()</tt>, <tt class=
"FUNCTION">env.SharedObject()</tt></dt>

<dd>
<p>Builds an object file for inclusion in a shared library. Source
files must have one of the same set of extensions specified above
for the <tt class="FUNCTION">StaticObject</tt> builder method. On
some platforms building a shared object requires additional
compiler option (e.g. <tt class="OPTION">-fPIC</tt> for gcc) in
addition to those needed to build a normal (static) object, but on
some platforms there is no difference between a shared object and a
normal (static) one. When there is a difference, SCons will only
allow shared objects to be linked into a shared library, and will
use a different suffix for shared objects. On platforms where there
is no difference, SCons will allow both normal (static) and shared
objects to be linked into a shared library, and will use the same
suffix for shared and normal (static) objects. The target object
file prefix (specified by the <tt class="ENVAR">$SHOBJPREFIX</tt>
construction variable; by default, the same as <tt class=
"ENVAR">$OBJPREFIX</tt>) and suffix (specified by the <tt class=
"ENVAR">$SHOBJSUFFIX</tt> construction variable) are automatically
added to the target if not already present. Examples:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.SharedObject(target = 'ddd', source = 'ddd.c')
env.SharedObject(target = 'eee.o', source = 'eee.cpp')
env.SharedObject(target = 'fff.obj', source = 'fff.for')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-STATICLIBRARY"></a><tt class=
"FUNCTION">StaticLibrary()</tt>, <tt class=
"FUNCTION">env.StaticLibrary()</tt></dt>

<dd>
<p>Builds a static library given one or more object files or C,
C++, D or Fortran source files. If any source files are given, then
they will be automatically compiled to object files. The static
library prefix and suffix (if any) are automatically added to the
target. The target library file prefix (specified by the <tt class=
"ENVAR">$LIBPREFIX</tt> construction variable; by default, <tt
class="FILENAME">lib</tt> on POSIX systems, nothing on Windows
systems) and suffix (specified by the <tt class=
"ENVAR">$LIBSUFFIX</tt> construction variable; by default, <tt
class="FILENAME">.lib</tt> on Windows systems, <tt class=
"FILENAME">.a</tt> on POSIX systems) are automatically added to the
target if not already present. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.StaticLibrary(target = 'bar', source = ['bar.c', 'foo.o'])
</pre>
</td>
</tr>
</table>

<p>Any object files listed in the <tt class="LITERAL">source</tt>
must have been built for a static library (that is, using the <tt
class="FUNCTION">StaticObject</tt> builder method). <tt class=
"APPLICATION">scons</tt> will raise an error if there is any
mismatch.</p>
</dd>

<dt><a name="B-STATICOBJECT"></a><tt class=
"FUNCTION">StaticObject()</tt>, <tt class=
"FUNCTION">env.StaticObject()</tt></dt>

<dd>
<p>Builds a static object file from one or more C, C++, D, or
Fortran source files. Source files must have one of the following
extensions:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
  .asm    assembly language file
  .ASM    assembly language file
  .c      C file
  .C      WIN32:  C file
          POSIX:  C++ file
  .cc     C++ file
  .cpp    C++ file
  .cxx    C++ file
  .cxx    C++ file
  .c++    C++ file
  .C++    C++ file
  .d      D file
  .f      Fortran file
  .F      WIN32:  Fortran file
          POSIX:  Fortran file + C pre-processor
  .for    Fortran file
  .FOR    Fortran file
  .fpp    Fortran file + C pre-processor
  .FPP    Fortran file + C pre-processor
  .s      assembly language file
  .S      WIN32:  assembly language file
          POSIX:  assembly language file + C pre-processor
  .spp    assembly language file + C pre-processor
  .SPP    assembly language file + C pre-processor
</pre>
</td>
</tr>
</table>

<p>The target object file prefix (specified by the <tt class=
"ENVAR">$OBJPREFIX</tt> construction variable; nothing by default)
and suffix (specified by the <tt class="ENVAR">$OBJSUFFIX</tt>
construction variable; <tt class="FILENAME">.obj</tt> on Windows
systems, <tt class="FILENAME">.o</tt> on POSIX systems) are
automatically added to the target if not already present.
Examples:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.StaticObject(target = 'aaa', source = 'aaa.c')
env.StaticObject(target = 'bbb.o', source = 'bbb.c++')
env.StaticObject(target = 'ccc.obj', source = 'ccc.f')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-TAR"></a><tt class="FUNCTION">Tar()</tt>, <tt class=
"FUNCTION">env.Tar()</tt></dt>

<dd>
<p>Builds a tar archive of the specified files and/or directories.
Unlike most builder methods, the <tt class="FUNCTION">Tar</tt>
builder method may be called multiple times for a given target;
each additional call adds to the list of entries that will be built
into the archive.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.Tar('src.tar', 'src')

# Create the stuff.tar file.
env.Tar('stuff', ['subdir1', 'subdir2'])
# Also add "another" to the stuff.tar file.
env.Tar('stuff', 'another')

# Set TARFLAGS to create a gzip-filtered archive.
env = Environment(TARFLAGS = '-c -z')
env.Tar('foo.tar.gz', 'foo')

# Also set the suffix to .tgz.
env = Environment(TARFLAGS = '-c -z',
                  TARSUFFIX = '.tgz')
env.Tar('foo')
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-TYPELIBRARY"></a><tt class=
"FUNCTION">TypeLibrary()</tt>, <tt class=
"FUNCTION">env.TypeLibrary()</tt></dt>

<dd>
<p>Builds a Windows type library (<tt class="FILENAME">.tlb</tt>)
file from an input IDL file (<tt class="FILENAME">.idl</tt>). In
addition, it will build the associated inteface stub and proxy
source files, naming them according to the base name of the <tt
class="FILENAME">.idl</tt> file. For example,</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.TypeLibrary(source="foo.idl")
</pre>
</td>
</tr>
</table>

<p>Will create <tt class="FILENAME">foo.tlb</tt>, <tt class=
"FILENAME">foo.h</tt>, <tt class="FILENAME">foo_i.c</tt>, <tt
class="FILENAME">foo_p.c</tt> and <tt class=
"FILENAME">foo_data.c</tt> files.</p>
</dd>

<dt><a name="B-UIC"></a><tt class="FUNCTION">Uic()</tt>, <tt class=
"FUNCTION">env.Uic()</tt></dt>

<dd>
<p>Builds a header file, an implementation file and a moc file from
an ui file. and returns the corresponding nodes in the above order.
This builder is only available after using the tool 'qt'. Note: you
can specify <tt class="FILENAME">.ui</tt> files directly as source
files to the <tt class="FUNCTION">Program</tt>, <tt class=
"FUNCTION">Library</tt> and <tt class="FUNCTION">SharedLibrary</tt>
builders without using this builder. Using this builder lets you
override the standard naming conventions (be careful: prefixes are
always prepended to names of built files; if you don't want
prefixes, you may set them to ``). See the <tt class=
"ENVAR">$QTDIR</tt> variable for more information. Example:</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.Uic('foo.ui') # -&gt; ['foo.h', 'uic_foo.cc', 'moc_foo.cc']
env.Uic(target = Split('include/foo.h gen/uicfoo.cc gen/mocfoo.cc'),
        source = 'foo.ui') # -&gt; ['include/foo.h', 'gen/uicfoo.cc', 'gen/mocfoo.cc']
</pre>
</td>
</tr>
</table>
</dd>

<dt><a name="B-ZIP"></a><tt class="FUNCTION">Zip()</tt>, <tt class=
"FUNCTION">env.Zip()</tt></dt>

<dd>
<p>Builds a zip archive of the specified files and/or directories.
Unlike most builder methods, the <tt class="FUNCTION">Zip</tt>
builder method may be called multiple times for a given target;
each additional call adds to the list of entries that will be built
into the archive.</p>

<table border="0" bgcolor="#E0E0E0" width="90%">
<tr>
<td>
<pre class="PROGRAMLISTING">
env.Zip('src.zip', 'src')

# Create the stuff.zip file.
env.Zip('stuff', ['subdir1', 'subdir2'])
# Also add "another" to the stuff.tar file.
env.Zip('stuff', 'another')
</pre>
</td>
</tr>
</table>
</dd>
</dl>
</div>
</div>

<div class="APPENDIX">
<hr>
<h1><a name="APP-TOOLS"></a>Tools</h1>

<p>&#13;This appendix contains descriptions of all of the Tools
that are available "out of the box" in this version of
SCons.&#13;</p>

<div class="VARIABLELIST">
<dl>
<dt><a name="T-386ASM"></a><tt class="LITERAL">386asm</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-AIXCXX"></a><tt class="LITERAL">aixc++</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-AIXCC"></a><tt class="LITERAL">aixcc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-AIXF77"></a><tt class="LITERAL">aixf77</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-AIXLINK"></a><tt class="LITERAL">aixlink</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-AR"></a><tt class="LITERAL">ar</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-AS"></a><tt class="LITERAL">as</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-BCC32"></a><tt class="LITERAL">bcc32</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-BITKEEPER"></a><tt class=
"LITERAL">BitKeeper</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-CXX"></a><tt class="LITERAL">c++</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-CC"></a><tt class="LITERAL">cc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-CVF"></a><tt class="LITERAL">cvf</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-CVS"></a><tt class="LITERAL">CVS</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-DEFAULT"></a><tt class="LITERAL">default</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-DMD"></a><tt class="LITERAL">dmd</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-DVIPDF"></a><tt class="LITERAL">dvipdf</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-DVIPS"></a><tt class="LITERAL">dvips</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-F77"></a><tt class="LITERAL">f77</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-F90"></a><tt class="LITERAL">f90</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-F95"></a><tt class="LITERAL">f95</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-FORTRAN"></a><tt class="LITERAL">fortran</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-GXX"></a><tt class="LITERAL">g++</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-G77"></a><tt class="LITERAL">g77</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-GAS"></a><tt class="LITERAL">gas</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-GCC"></a><tt class="LITERAL">gcc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-GNULINK"></a><tt class="LITERAL">gnulink</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-GS"></a><tt class="LITERAL">gs</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-HPCXX"></a><tt class="LITERAL">hpc++</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-HPCC"></a><tt class="LITERAL">hpcc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-HPLINK"></a><tt class="LITERAL">hplink</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-ICC"></a><tt class="LITERAL">icc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-ICL"></a><tt class="LITERAL">icl</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-IFL"></a><tt class="LITERAL">ifl</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-IFORT"></a><tt class="LITERAL">ifort</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-ILINK"></a><tt class="LITERAL">ilink</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-ILINK32"></a><tt class="LITERAL">ilink32</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-INTELC"></a><tt class="LITERAL">intelc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-JAR"></a><tt class="LITERAL">jar</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-JAVAC"></a><tt class="LITERAL">javac</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-JAVAH"></a><tt class="LITERAL">javah</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-LATEX"></a><tt class="LITERAL">latex</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-LEX"></a><tt class="LITERAL">lex</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-LINK"></a><tt class="LITERAL">link</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-LINKLOC"></a><tt class="LITERAL">linkloc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-M4"></a><tt class="LITERAL">m4</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MASM"></a><tt class="LITERAL">masm</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MIDL"></a><tt class="LITERAL">midl</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MINGW"></a><tt class="LITERAL">mingw</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MSLIB"></a><tt class="LITERAL">mslib</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MSLINK"></a><tt class="LITERAL">mslink</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MSVC"></a><tt class="LITERAL">msvc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MSVS"></a><tt class="LITERAL">msvs</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MWCC"></a><tt class="LITERAL">mwcc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-MWLD"></a><tt class="LITERAL">mwld</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-NASM"></a><tt class="LITERAL">nasm</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-PDFLATEX"></a><tt class="LITERAL">pdflatex</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-PDFTEX"></a><tt class="LITERAL">pdftex</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-PERFORCE"></a><tt class="LITERAL">Perforce</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-QT"></a><tt class="LITERAL">qt</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-RCS"></a><tt class="LITERAL">RCS</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-RMIC"></a><tt class="LITERAL">rmic</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-RPCGEN"></a><tt class="LITERAL">rpcgen</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SCCS"></a><tt class="LITERAL">SCCS</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SGIAR"></a><tt class="LITERAL">sgiar</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SGICXX"></a><tt class="LITERAL">sgic++</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SGICC"></a><tt class="LITERAL">sgicc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SGILINK"></a><tt class="LITERAL">sgilink</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SUBVERSION"></a><tt class=
"LITERAL">Subversion</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SUNAR"></a><tt class="LITERAL">sunar</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SUNCXX"></a><tt class="LITERAL">sunc++</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SUNCC"></a><tt class="LITERAL">suncc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SUNLINK"></a><tt class="LITERAL">sunlink</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-SWIG"></a><tt class="LITERAL">swig</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-TAR"></a><tt class="LITERAL">tar</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-TEX"></a><tt class="LITERAL">tex</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-TLIB"></a><tt class="LITERAL">tlib</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-YACC"></a><tt class="LITERAL">yacc</tt></dt>

<dd>
<p>XXX</p>
</dd>

<dt><a name="T-ZIP"></a><tt class="LITERAL">zip</tt></dt>

<dd>
<p>XXX</p>
</dd>
</dl>
</div>
</div>

<div class="APPENDIX">
<hr>
<h1><a name="APP-TASKS"></a>Handling Common Tasks</h1>

<p>There is a common set of simple tasks that many build
configurations rely on as they become more complex. Most build
tools have special purpose constructs for performing these tasks,
but since <tt class="FILENAME">SConscript</tt> files are <tt class=
"APPLICATION">Python</tt> scripts, you can use more flexible
built-in <tt class="APPLICATION">Python</tt> services to perform
these tasks. This appendix lists a number of these tasks and how to
implement them in <tt class="APPLICATION">Python</tt>.</p>

<div class="EXAMPLE"><a name="AEN6078"></a>
<p><b>Example 1. Wildcard globbing to create a list of
filenames</b></p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import glob
files = glob.glob(wildcard)
</pre>
</td>
</tr>
</table>
</div>

<div class="EXAMPLE"><a name="AEN6081"></a>
<p><b>Example 2. Filename extension substitution</b></p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import os.path
filename = os.path.splitext(filename)[0]+extension
</pre>
</td>
</tr>
</table>
</div>

<div class="EXAMPLE"><a name="AEN6084"></a>
<p><b>Example 3. Appending a path prefix to a list of
filenames</b></p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import os.path
filenames = [os.path.join(prefix, x) for x in filenames]
</pre>
</td>
</tr>
</table>

<p>or in Python 1.5.2:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import os.path
new_filenames = [] 
for x in filenames:
    new_filenames.append(os.path.join(prefix, x))
</pre>
</td>
</tr>
</table>
</div>

<div class="EXAMPLE"><a name="AEN6089"></a>
<p><b>Example 4. Substituting a path prefix with another
one</b></p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
if filename.find(old_prefix) == 0:
    filename = filename.replace(old_prefix, new_prefix)
</pre>
</td>
</tr>
</table>

<p>or in Python 1.5.2:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import string
if string.find(filename, old_prefix) == 0:
    filename = string.replace(filename, old_prefix, new_prefix)     
</pre>
</td>
</tr>
</table>
</div>

<div class="EXAMPLE"><a name="AEN6094"></a>
<p><b>Example 5. Filtering a filename list to exclude/retain only a
specific set of extensions</b></p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import os.path
filenames = [x for x in filenames if os.path.splitext(x)[1] in extensions]
</pre>
</td>
</tr>
</table>

<p>or in Python 1.5.2:</p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import os.path
new_filenames = []
for x in filenames:
    if os.path.splitext(x)[1] in extensions:
        new_filenames.append(x)
</pre>
</td>
</tr>
</table>
</div>

<div class="EXAMPLE"><a name="AEN6099"></a>
<p><b>Example 6. The "backtick function": run a shell command and
capture the output</b></p>

<table border="0" bgcolor="#E0E0E0" width="100%">
<tr>
<td>
<pre class="PROGRAMLISTING">
import os
output = os.popen(command).read()
</pre>
</td>
</tr>
</table>
</div>
</div>
</div>

<h3 class="FOOTNOTES">Notes</h3>

<table border="0" class="FOOTNOTES" width="100%">
<tr>
<td align="LEFT" valign="TOP" width="5%"><a name="FTN.AEN380" href=
"#AEN380">[1]</a></td>
<td align="LEFT" valign="TOP" width="95%">
<p>In programming parlance, the <tt class=
"FILENAME">SConstruct</tt> file is <i class=
"EMPHASIS">declarative</i>, meaning you tell <tt class=
"APPLICATION">SCons</tt> what you want done and let it figure out
the order in which to do it, rather than strictly <i class=
"EMPHASIS">imperative</i>, where you specify explicitly the order
in which to do things.</p>
</td>
</tr>
</table>
</body>
</html>

