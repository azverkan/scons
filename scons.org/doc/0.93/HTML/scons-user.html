<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>SCons User Guide 0.93</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
></A
>SCons User Guide 0.93</H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
></A
>Steven Knight</H3
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2003 by Steven Knight</P
><DIV
CLASS="LEGALNOTICE"
><A
NAME="AEN12"
></A
><P
></P
><A
NAME="AEN13"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>&#13;  SCons User's Guide Copyright (c) 2003 Steven Knight

 </P
></BLOCKQUOTE
><P
></P
></DIV
><SPAN
CLASS="RELEASEINFO"
>version 0.93<BR></SPAN
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#CHAP-PREFACE"
>Preface</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN29"
><TT
CLASS="APPLICATION"
>SCons</TT
> Principles</A
></DT
><DT
><A
HREF="#AEN54"
>Acknowledgements</A
></DT
><DT
><A
HREF="#AEN75"
>Contact</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-SIMPLE"
>Simple Builds</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN112"
>The <TT
CLASS="FILENAME"
>SConstruct</TT
> File</A
></DT
><DT
><A
HREF="#AEN131"
>Making the Output Less Verbose</A
></DT
><DT
><A
HREF="#AEN148"
>Compiling Multiple Source Files</A
></DT
><DT
><A
HREF="#AEN170"
>Keeping <TT
CLASS="FILENAME"
>SConstruct</TT
> Files Easy to Read</A
></DT
><DT
><A
HREF="#AEN196"
>Keyword Arguments</A
></DT
><DT
><A
HREF="#AEN207"
>Compiling Multiple Programs</A
></DT
><DT
><A
HREF="#AEN221"
>Sharing Source Files Between Multiple Programs</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-LIBRARIES"
>Building and Linking with Libraries</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN239"
>Building Libraries</A
></DT
><DT
><A
HREF="#AEN256"
>Linking with Libraries</A
></DT
><DT
><A
HREF="#AEN275"
>Finding Libraries:  the <TT
CLASS="VARNAME"
>LIBPATH</TT
> Construction Variable</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-DEPENDS"
>Dependencies</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN320"
>Source File Signatures</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN326"
>MD5 Source File Signatures</A
></DT
><DT
><A
HREF="#AEN350"
>Source File Time Stamps</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN364"
>Target File Signatures</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN369"
>Build Signatures</A
></DT
><DT
><A
HREF="#AEN389"
>File Contents</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN407"
>Implicit Dependencies:  The <TT
CLASS="LITERAL"
>CPPPATH</TT
> Construction Variable</A
></DT
><DT
><A
HREF="#AEN464"
>Caching Implicit Dependencies</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN483"
>The <TT
CLASS="LITERAL"
>--implicit-deps-changed</TT
> Option</A
></DT
><DT
><A
HREF="#AEN495"
>The <TT
CLASS="LITERAL"
>--implicit-deps-unchanged</TT
> Option</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN508"
>The <TT
CLASS="FUNCTION"
>Ignore</TT
> Method</A
></DT
><DT
><A
HREF="#AEN528"
>The <TT
CLASS="FUNCTION"
>Depends</TT
> Method</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-ENVIRONMENTS"
>Construction Environments</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN561"
>Multiple <TT
CLASS="LITERAL"
>Construction Environments</TT
></A
></DT
><DT
><A
HREF="#AEN599"
>Copying <TT
CLASS="LITERAL"
>Construction Environments</TT
></A
></DT
><DT
><A
HREF="#AEN623"
>Fetching Values From a <TT
CLASS="LITERAL"
>Construction Environment</TT
></A
></DT
><DT
><A
HREF="#AEN644"
>Modifying a <TT
CLASS="LITERAL"
>Construction Environment</TT
></A
></DT
><DD
><DL
><DT
><A
HREF="#AEN650"
>Replacing Values in a <TT
CLASS="LITERAL"
>Construction Environment</TT
></A
></DT
><DT
><A
HREF="#AEN659"
>Appending to the End of Values in a <TT
CLASS="LITERAL"
>Construction Environment</TT
></A
></DT
><DT
><A
HREF="#AEN667"
>Appending to the Beginning of Values in a <TT
CLASS="LITERAL"
>Construction Environment</TT
></A
></DT
></DL
></DD
></DL
></DD
><DT
><A
HREF="#CHAP-DEFAULT"
>Default Targets</A
></DT
><DT
><A
HREF="#CHAP-HELP"
>Providing Build Help</A
></DT
><DT
><A
HREF="#CHAP-INSTALL"
>Installing Files in Other Directories</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN758"
>Installing Multiple Files in a Directory</A
></DT
><DT
><A
HREF="#AEN768"
>Installing a File Under a Different Name</A
></DT
><DT
><A
HREF="#AEN779"
>Installing Multiple Files Under Different Names</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-PRECIOUS"
>Preventing Removal of Targets</A
></DT
><DT
><A
HREF="#CHAP-HIERARCHICAL"
>Hierarchical Builds</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN808"
><TT
CLASS="FILENAME"
>SConscript</TT
> Files</A
></DT
><DT
><A
HREF="#AEN836"
>Path Names Are Relative to the <TT
CLASS="FILENAME"
>SConscript</TT
> Directory</A
></DT
><DT
><A
HREF="#AEN862"
>Top-Level Path Names in Subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> Files</A
></DT
><DT
><A
HREF="#AEN882"
>Absolute Path Names</A
></DT
><DT
><A
HREF="#AEN891"
>Sharing Environments (and Other Variables) Between <TT
CLASS="FILENAME"
>SConscript</TT
> Files</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN903"
>Exporting Variables</A
></DT
><DT
><A
HREF="#AEN931"
>Importing Variables</A
></DT
><DT
><A
HREF="#AEN954"
>Returning Values From an <TT
CLASS="FILENAME"
>SConscript</TT
> File</A
></DT
></DL
></DD
></DL
></DD
><DT
><A
HREF="#CHAP-SEPARATE"
>Separating Source and Build Directories</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN983"
>Specifying a Build Directory as Part of an <TT
CLASS="FILENAME"
>SConscript</TT
> Call</A
></DT
><DT
><A
HREF="#AEN1013"
>Why <TT
CLASS="APPLICATION"
>SCons</TT
> Duplicates Source Files in a Build Directory</A
></DT
><DT
><A
HREF="#AEN1030"
>Telling <TT
CLASS="APPLICATION"
>SCons</TT
> to Not Duplicate Source Files in the Build Directory</A
></DT
><DT
><A
HREF="#AEN1046"
>The <TT
CLASS="FUNCTION"
>BuildDir</TT
> Function</A
></DT
><DT
><A
HREF="#AEN1075"
>Using <TT
CLASS="FUNCTION"
>BuildDir</TT
> With an <TT
CLASS="FILENAME"
>SConscript</TT
> File</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-VARIANTS"
>Variant Builds</A
></DT
><DT
><A
HREF="#CHAP-BUILDERS-WRITING"
>Writing Your Own Builders</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1117"
>Writing Builders That Execute External Commands</A
></DT
><DT
><A
HREF="#AEN1126"
>Attaching a Builder to a <TT
CLASS="LITERAL"
>Construction Environment</TT
></A
></DT
><DT
><A
HREF="#AEN1178"
>Letting <TT
CLASS="APPLICATION"
>SCons</TT
> Handle The File Suffixes</A
></DT
><DT
><A
HREF="#AEN1199"
>Builders That Execute Python Functions</A
></DT
><DT
><A
HREF="#AEN1235"
>Builders That Create Actions Using a <TT
CLASS="LITERAL"
>Generator</TT
></A
></DT
><DT
><A
HREF="#AEN1278"
>Builders That Modify the Target or Source Lists Using an <TT
CLASS="LITERAL"
>Emitter</TT
></A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-BUILDERS-COMMANDS"
>Not Writing a Builder:  The <TT
CLASS="FUNCTION"
>Command</TT
> Builder</A
></DT
><DT
><A
HREF="#CHAP-SCANNERS"
>Writing Scanners</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1317"
>A Simple Scanner Example</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-REPOSITORIES"
>Building From Code Repositories</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1365"
>The <TT
CLASS="FUNCTION"
>Repository</TT
> Method</A
></DT
><DT
><A
HREF="#AEN1377"
>Finding source files in repositories</A
></DT
><DT
><A
HREF="#AEN1409"
>Finding the <TT
CLASS="FILENAME"
>SConstruct</TT
> file in repositories</A
></DT
><DT
><A
HREF="#AEN1427"
>Finding derived files in repositories</A
></DT
><DT
><A
HREF="#AEN1454"
>Guaranteeing local copies of files</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-CACHING"
>Caching Built Files</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1481"
>Specifying the Shared Cache Directory</A
></DT
><DT
><A
HREF="#AEN1495"
>Keeping Build Output Consistent</A
></DT
><DT
><A
HREF="#AEN1508"
>Not Retrieving Files From a Shared Cache</A
></DT
><DT
><A
HREF="#AEN1520"
>Populating a Shared Cache With Already-Built Files</A
></DT
></DL
></DD
><DT
><A
HREF="#CHAP-ALIAS"
>Alias Targets</A
></DT
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-PREFACE"
></A
>Preface</H1
><P
>&#13;  Thank you for taking the time to read about <TT
CLASS="APPLICATION"
>SCons</TT
>.
  <TT
CLASS="APPLICATION"
>SCons</TT
> is a next-generation
  software construction tool,
  or make tool--that is, a software utility
  for building software (or other files)
  and keeping built software up-to-date
  whenever the underlying input files change.

  </P
><P
>&#13;  The most distinctive thing about <TT
CLASS="APPLICATION"
>SCons</TT
>
  is that its configuration files are
  actually <I
CLASS="EMPHASIS"
>scripts</I
>,
  written in the <TT
CLASS="APPLICATION"
>Python</TT
> programming language.
  This is in contrast to most alternative build tools,
  which typically invent a new language to
  configure the build.
  <TT
CLASS="APPLICATION"
>SCons</TT
> still has a learning curve, of course,
  because you have to know what functions to call
  to set up your build properly,
  but the underlying syntax used should be familiar
  to anyone who has ever looked at a Python script.

  </P
><P
>&#13;  Paradoxically,
  using Python as the configuration file format
  makes <TT
CLASS="APPLICATION"
>SCons</TT
>
  <I
CLASS="EMPHASIS"
>easier</I
>
  for non-programmers to learn
  than the cryptic languages of other build tools,
  which are usually invented by programmers for other programmers.
  This is in no small part due to the
  consistency and readability that are built in to Python.
  It just so happens that making a real, live
  scripting language the basis for the
  configuration files
  makes it a snap for more accomplished programmers
  to do more complicated things with builds,
  as necessary.

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN29"
></A
><TT
CLASS="APPLICATION"
>SCons</TT
> Principles</H1
><P
>&#13;    There are a few overriding principles
    we try to live up to in designing and implementing <TT
CLASS="APPLICATION"
>SCons</TT
>:

    </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Correctness</DT
><DD
><P
>&#13;      First and foremost,
      by default, <TT
CLASS="APPLICATION"
>SCons</TT
> guarantees a correct build
      even if it means sacrificing performance a little.
      We strive to guarantee the build is correct
      regardless of how the software being built is structured,
      how it may have been written,
      or how unusual the tools are that build it.

      </P
></DD
><DT
>Performance</DT
><DD
><P
>&#13;      Given that the build is correct,
      we try to make <TT
CLASS="APPLICATION"
>SCons</TT
> build software
      as quickly as possible.
      In particular, wherever we may have needed to slow
      down the default <TT
CLASS="APPLICATION"
>SCons</TT
> behavior to guarantee a correct build,
      we also try to make it easy to speed up <TT
CLASS="APPLICATION"
>SCons</TT
>
      through optimization options that let you trade off
      guaranteed correctness in all end cases for
      a speedier build in the usual cases.

      </P
></DD
><DT
>Convenience</DT
><DD
><P
>&#13;      <TT
CLASS="APPLICATION"
>SCons</TT
> tries to do as much for you out of the box as reasonable,
      including detecting the right tools on your system
      and using them correctly to build the software.

      </P
></DD
></DL
></DIV
><P
>&#13;    In a nutshell, we try hard to make <TT
CLASS="APPLICATION"
>SCons</TT
> just
    "do the right thing" and build software correctly,
    with a minimum of hassles.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN54"
></A
>Acknowledgements</H1
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> would not exist without a lot of help
    from a lot of people,
    many of whom may not even be aware
    that they helped or served as inspiration.
    So in no particular order,
    and at the risk of leaving out someone:

    </P
><P
>&#13;    First and foremost,
    <TT
CLASS="APPLICATION"
>SCons</TT
> owes a tremendous debt to Bob Sidebotham,
    the original author of the classic Perl-based <TT
CLASS="APPLICATION"
>Cons</TT
> tool
    which Bob first released to the world back around 1996.
    Bob's work on Cons classic provided the underlying architecture
    and model of specifying a build configuration
    using a real scripting language.
    My real-world experience working on Cons
    informed many of the design decisions in SCons,
    including the improved parallel build support,
    making Builder objects easily definable by users,
    and separating the build engine from the wrapping interface.

    </P
><P
>&#13;    Greg Wilson was instrumental in getting
    <TT
CLASS="APPLICATION"
>SCons</TT
> started as a real project
    when he initiated the Software Carpentry design
    competition in February 2000.
    Without that nudge,
    marrying the advantages of the Cons classic
    architecture with the readability of Python
    might have just stayed no more than a nice idea.

    </P
><P
>&#13;    The entire <TT
CLASS="APPLICATION"
>SCons</TT
> team have been
    absolutely wonderful to work with,
    and <TT
CLASS="APPLICATION"
>SCons</TT
> would be nowhere near as useful a
    tool without the energy, enthusiasm
    and time people have contributed over the past few years.
    The "core team"
    of Chad Austin, Anthony Roach, Charles Crain,
    Steve Leblanc, Gary Oerbrunner, Greg Spencer and Christoph Wiedemann
    have been great about reviewing my (and other) changes
    and catching problems before they get in the code base.
    Of particular technical note:
    Anthony's outstanding and innovative work on the tasking engine
    has given <TT
CLASS="APPLICATION"
>SCons</TT
> a vastly superior parallel build model;
    Charles has been the master of the crucial Node infrastructure;
    Christoph's work on the Configure infrastructure
    has added crucial Autoconf-like functionality;
    and Greg has provided excellent support
    for Microsoft Visual Studio.

    </P
><P
>&#13;    Special thanks to David Snopek for contributing
    his underlying "Autoscons" code that formed
    the basis of Christoph's work with the Configure functionality.
    David was extremely generous in making
    this code available to <TT
CLASS="APPLICATION"
>SCons</TT
>,
    given that he initially released it under the GPL
    and <TT
CLASS="APPLICATION"
>SCons</TT
> is released under a less-restrictive MIT-style license.

    </P
><P
>&#13;    Thanks to Peter Miller
    for his splendid change management system, <TT
CLASS="APPLICATION"
>Aegis</TT
>,
    which has provided the <TT
CLASS="APPLICATION"
>SCons</TT
> project
    with a robust development methodology from day one,
    and which showed me how you could
    integrate incremental regression tests into
    a practical development cycle
    (years before eXtreme Programming arrived on the scene).

    </P
><P
>&#13;    And last, thanks to Guido van Rossum
    for his elegant scripting language,
    which is the basis not only for the <TT
CLASS="APPLICATION"
>SCons</TT
> implementation,
    but for the interface itself.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN75"
></A
>Contact</H1
><P
>&#13;    The best way to contact people involved with SCons,
    including the author,
    is through the SCons mailing lists.

    </P
><P
>&#13;    If you want to ask general questions about how to use <TT
CLASS="APPLICATION"
>SCons</TT
>
    send email to <TT
CLASS="LITERAL"
>scons-users@lists.sourceforge.net</TT
>.

    </P
><P
>&#13;    If you want to contact the <TT
CLASS="APPLICATION"
>SCons</TT
> development community directly,
    send email to <TT
CLASS="LITERAL"
>scons-devel@lists.sourceforge.net</TT
>.

    </P
><P
>&#13;    If you want to receive announcements about <TT
CLASS="APPLICATION"
>SCons</TT
>,
    join the low-volume <TT
CLASS="LITERAL"
>scons-announce@lists.sourceforge.net</TT
> mailing list.

    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-SIMPLE"
></A
>Simple Builds</H1
><P
>&#13; Here's the famous "Hello, World!" program in C:

 </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    int
    main()
    {
        printf("Hello, world!\n");
    }
 </PRE
></TD
></TR
></TABLE
><P
>&#13; And here's how to build it using <TT
CLASS="APPLICATION"
>SCons</TT
>.
 Enter the following into a file named <TT
CLASS="FILENAME"
>SConstruct</TT
>:

 </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    Program('hello.c')
 </PRE
></TD
></TR
></TABLE
><P
>&#13; That's it.  Now run the <TT
CLASS="APPLICATION"
>scons</TT
> command to build the program.
 On a POSIX-compliant system like Linux or UNIX,
 you'll see something like:

 </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;Reading&nbsp;SConscript&nbsp;files&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;done&nbsp;reading&nbsp;SConscript&nbsp;files.<br>
&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;Building&nbsp;targets&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;done&nbsp;building&nbsp;targets.<br>
&nbsp;</P
><P
>&#13; On a Windows system with the Microsoft Visual C++ compiler,
 you'll see something like:

 </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;Reading&nbsp;SConscript&nbsp;files&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;done&nbsp;reading&nbsp;SConscript&nbsp;files.<br>
&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;Building&nbsp;targets&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;hello.c&nbsp;/Fohello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;/nologo&nbsp;/OUT:hello.exe&nbsp;hello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;done&nbsp;building&nbsp;targets.<br>
&nbsp;</P
><P
>&#13; First, notice that you only need
 to specify the name of the source file,
 and that <TT
CLASS="APPLICATION"
>SCons</TT
> deduces the names of
 the object and executable files
 correctly from the base of the source file name.

 </P
><P
>&#13; Second, notice that the same input <TT
CLASS="FILENAME"
>SConstruct</TT
> file,
 without any changes,
 generates the correct output file names on both systems:
 <TT
CLASS="FILENAME"
>hello.o</TT
> and <TT
CLASS="FILENAME"
>hello</TT
>
 on POSIX systems,
 <TT
CLASS="FILENAME"
>hello.obj</TT
> and <TT
CLASS="FILENAME"
>hello.exe</TT
>
 on Windows systems.
 This is a simple example of how <TT
CLASS="APPLICATION"
>SCons</TT
>
 makes it extremely easy to
 write portable software builds.

 </P
><P
>&#13; (Note that we won't provide duplicate side-by-side
 POSIX and Windows output for all of the examples in this guide;
 just keep in mind that, unless otherwise specified,
 any of the examples should work equally well on both types of systems.)

 </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN112"
></A
>The <TT
CLASS="FILENAME"
>SConstruct</TT
> File</H1
><P
>&#13;   If you're used to build systems like <TT
CLASS="APPLICATION"
>Make</TT
>
   you've already figured out that the <TT
CLASS="FILENAME"
>SConstruct</TT
> file
   is the <TT
CLASS="APPLICATION"
>SCons</TT
> equivalent of a <TT
CLASS="FILENAME"
>Makefile</TT
>.
   That is, the <TT
CLASS="FILENAME"
>SConstruct</TT
> file is the input file
   that <TT
CLASS="APPLICATION"
>SCons</TT
> reads to control the build.

   </P
><P
>&#13;   There is, however, an important difference between
   an <TT
CLASS="FILENAME"
>SConstruct</TT
> file and a <TT
CLASS="FILENAME"
>Makefile</TT
>:
   the <TT
CLASS="FILENAME"
>SConstruct</TT
> file is actually a Python script.
   If you're not already familiar with Python, don't worry.
   This User's Guide will introduce you step-by-step
   to the relatively small amount of Python you'll
   need to know to be able to use <TT
CLASS="APPLICATION"
>SCons</TT
> effectively.
   And Python is very easy to learn.

   </P
><P
>&#13;   One aspect of using Python as the
   scripting language is that you can put comments
   in your <TT
CLASS="FILENAME"
>SConstruct</TT
> file using Python's commenting convention;
   that is, everything between a '#' and the end of the line
   will be ignored:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      # Arrange to build the "hello" program.
      Program('hello.c')    # "hello.c" is the source file.
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   You'll see throughout the remainder of this Guide
   that being able to use the power of a
   real scripting language
   can greatly simplify the solutions
   to complex requirements of real-world builds.

   </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN131"
></A
>Making the Output Less Verbose</H1
><P
>&#13;   You've already seen how <TT
CLASS="APPLICATION"
>SCons</TT
> prints
   some messages about what it's doing,
   surrounding the actual commands used to build the software:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;Reading&nbsp;SConscript&nbsp;files&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;done&nbsp;reading&nbsp;SConscript&nbsp;files.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;Building&nbsp;targets&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;hello.c&nbsp;/Fohello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;/nologo&nbsp;/OUT:hello.exe&nbsp;hello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;done&nbsp;building&nbsp;targets.<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   These messages emphasize the
   order in which <TT
CLASS="APPLICATION"
>SCons</TT
> does its work:
   the configuration files
   (generically referred to as <TT
CLASS="FILENAME"
>SConscript</TT
> files)
   are read and executed first,
   and only then are the target files built.
   Among other benefits, these messages help to distinguish between
   errors that occur while the configuration files are read,
   and errors that occur while targets are being built.

   </P
><P
>&#13;   The drawback, of course, is that these messages clutter the output.
   Fortunately, they're easily disabled by using
   the <TT
CLASS="LITERAL"
>-Q</TT
> option when invoking <TT
CLASS="APPLICATION"
>SCons</TT
>:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;hello.c&nbsp;/Fohello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;/nologo&nbsp;/OUT:hello.exe&nbsp;hello.obj<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   Because we want this User's Guide to focus
   on what <TT
CLASS="APPLICATION"
>SCons</TT
> is actually doing,
   we're going use the <TT
CLASS="LITERAL"
>-Q</TT
> option
   to remove these messages from the
   output of all the remaining examples in this Guide.

   </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN148"
></A
>Compiling Multiple Source Files</H1
><P
>&#13;   You've just seen how to configure <TT
CLASS="APPLICATION"
>SCons</TT
>
   to compile a program from a single source file.
   It's more common, of course,
   that you'll need to build a program from
   many input source files, not just one.
   To do this, you need to put the
   source files in a Python list
   (enclosed in square brackets),
   like so:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Program(['prog.c', 'file1.c', 'file2.c'])
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   A build of the above example would look like:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;file1.o&nbsp;file1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;file2.o&nbsp;file2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog.o&nbsp;prog.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog&nbsp;prog.o&nbsp;file1.o&nbsp;file2.o<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   Notice that <TT
CLASS="APPLICATION"
>SCons</TT
>
   deduces the output program name
   from the first source file specified
   in the list--that is,
   because the first source file was <TT
CLASS="FILENAME"
>prog.c</TT
>,
   <TT
CLASS="APPLICATION"
>SCons</TT
> will name the resulting program <TT
CLASS="FILENAME"
>prog</TT
>
   (or <TT
CLASS="FILENAME"
>prog.exe</TT
> on a Windows system).
   If you want to specify a different program name,
   then you slide the list of source files
   over to the right
   to make room for the output program file name.
   (<TT
CLASS="APPLICATION"
>SCons</TT
> puts the output file name to the left
   of the source file names
   so that the order mimics that of an
   assignment statement:  "program = source files".)
   This makes our example:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Program('program', ['main.c', 'file1.c', 'file2.c'])
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   On Linux, a build of this example would look like:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;file1.o&nbsp;file1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;file2.o&nbsp;file2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;main.o&nbsp;main.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;program&nbsp;main.o&nbsp;file1.o&nbsp;file2.o<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   Or on Windows:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;file1.c&nbsp;/Fofile1.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;file2.c&nbsp;/Fofile2.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;main.c&nbsp;/Fomain.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;/nologo&nbsp;/OUT:program.exe&nbsp;main.obj&nbsp;file1.obj&nbsp;file2.obj<br>
&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN170"
></A
>Keeping <TT
CLASS="FILENAME"
>SConstruct</TT
> Files Easy to Read</H1
><P
>&#13;   One drawback to the use of a Python list
   for source files is that 
   each file name must be enclosed in quotes
   (either single quotes or double quotes).
   This can get cumbersome and difficult to read
   when the list of file names is long.
   Fortunately, <TT
CLASS="APPLICATION"
>SCons</TT
> and Python provide a number of ways
   to make sure that
   the <TT
CLASS="FILENAME"
>SConstruct</TT
> file stays easy to read.

   </P
><P
>&#13;   To make long lists of file names
   easier to deal with, <TT
CLASS="APPLICATION"
>SCons</TT
> provides a
   <TT
CLASS="FUNCTION"
>Split</TT
> function
   that takes a quoted list of file names,
   with the names separated by spaces or other white-space characters,
   and turns it into a list of separate file names.
   Using the <TT
CLASS="FUNCTION"
>Split</TT
> function turns the
   previous example into:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Program('program', Split('main.c file1.c file2.'))
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   (If you're already familiar with Python,
   you'll have realized that this is similar to the
   <TT
CLASS="FUNCTION"
>split()</TT
> method
   in the Python standard <TT
CLASS="FUNCTION"
>string</TT
> module.
   Unlike the <TT
CLASS="FUNCTION"
>string.split()</TT
> method,
   however, the <TT
CLASS="FUNCTION"
>Split</TT
> function
   does not require a string as input
   and will wrap up a single non-string object in a list,
   or return its argument untouched if it's already a list.
   This comes in handy as a way to make sure
   arbitrary values can be passed to <TT
CLASS="APPLICATION"
>SCons</TT
> functions
   without having to check the type of the variable by hand.)

   </P
><P
>&#13;   Putting the call to the <TT
CLASS="FUNCTION"
>Split</TT
> function
   inside the <TT
CLASS="FUNCTION"
>Program</TT
> call
   can also be a little unwieldy.
   A more readable alternative is to
   assign the output from the <TT
CLASS="FUNCTION"
>Split</TT
> call
   to a variable name,
   and then use the variable when calling the
   <TT
CLASS="FUNCTION"
>Program</TT
> function:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      list = Split('main.c file1.c file2.')
      Program('program', list)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Lastly, the <TT
CLASS="FUNCTION"
>Split</TT
> function
   doesn't care how much white space separates
   the file names in the quoted string.
   This allows you to create lists of file
   names that span multiple lines,
   which often makes for easier editing:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      list = Split('main.c
                    file1.c
                    file2.c')
      Program('program', list)
   </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN196"
></A
>Keyword Arguments</H1
><P
>&#13;   <TT
CLASS="APPLICATION"
>SCons</TT
> also allows you to identify
   the output file and input source files
   using Python keyword arguments.
   The output file is known as the
   <I
CLASS="EMPHASIS"
>target</I
>,
   and the source file(s) are known (logically enough) as the
   <I
CLASS="EMPHASIS"
>source</I
>.
   The Python syntax for this is:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      list = Split('main.c file1.c file2.')
      Program(target = 'program', source = list)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Because the keywords explicitly identify
   what each argument is,
   you can actually reverse the order if you prefer:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      list = Split('main.c file1.c file2.')
      Program(source = list, target = 'program')
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Whether or not you choose to use keyword arguments
   to identify the target and source files,
   and the order in which you specify them
   when using keywords,
   are purely personal choices;
   <TT
CLASS="APPLICATION"
>SCons</TT
> functions the same regardless.

   </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN207"
></A
>Compiling Multiple Programs</H1
><P
>&#13;   In order to compile multiple programs
   within the same <TT
CLASS="FILENAME"
>SConstruct</TT
> file,
   simply call the <TT
CLASS="FUNCTION"
>Program</TT
> method
   multiple times,
   once for each program you need to build:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Program('foo.c')
      Program('bar', ['bar1.c', 'bar2.c'])
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   <TT
CLASS="APPLICATION"
>SCons</TT
> would then build the programs as follows:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;bar1.o&nbsp;bar1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;bar2.o&nbsp;bar2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;bar&nbsp;bar1.o&nbsp;bar2.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   Notice that <TT
CLASS="APPLICATION"
>SCons</TT
> does not necessarily build the
   programs in the same order in which you specify
   them in the <TT
CLASS="FILENAME"
>SConstruct</TT
> file.
   <TT
CLASS="APPLICATION"
>SCons</TT
> does, however, recognize that
   the individual object files must be built
   before the resulting program can be built.
   We'll discuss this in greater detail in
   the "Dependencies" section, below.

   </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN221"
></A
>Sharing Source Files Between Multiple Programs</H1
><P
>&#13;   It's common to re-use code by sharing source files
   between multiple programs.
   One way to do this is to create a library
   from the common source files,
   which can then be linked into resulting programs.
   (Creating libraries is discussed in
   section XXX, below.)

   </P
><P
>&#13;   A more straightforward, but perhaps less convenient,
   way to share source files between multiple programs
   is simply to include the common files
   in the lists of source files for each program:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Program(Split('foo.c common1.c common2.c'))
      Program('bar', Split('bar1.c bar2.c common1.c common2.c'))
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   <TT
CLASS="APPLICATION"
>SCons</TT
> recognizes that the object files for
   the <TT
CLASS="APPLICATION"
>common1.c</TT
> and <TT
CLASS="APPLICATION"
>common2.c</TT
> source files
   each only need to be built once,
   even though the resulting object files are
   each linked in to both of the resulting executable programs:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;bar1.o&nbsp;bar1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;bar2.o&nbsp;bar2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;common1.o&nbsp;common1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;common2.o&nbsp;common2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;bar&nbsp;bar1.o&nbsp;bar2.o&nbsp;common1.o&nbsp;common2.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo&nbsp;foo.o&nbsp;common1.o&nbsp;common2.o<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   If two or more programs
   share a lot of common source files,
   repeating the common files in the list for each program
   can be a maintenance problem when you need to change the
   list of common files.
   You can simplify this by creating a separate Python list
   to hold the common file names,
   and concatenating it with other lists
   using the Python <TT
CLASS="LITERAL"
>+</TT
> operator:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      common = ['common1.c', 'common2.c']
      foo_files = ['foo.c'] + common
      bar_files = ['bar1.c', 'bar2.c'] + common
      Program('foo', foo_files)
      Program('bar', bar_files)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   This is functionally equivalent to the previous example.

   </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-LIBRARIES"
></A
>Building and Linking with Libraries</H1
><P
>&#13;  One of the more useful ways in which you can use multiple
  construction environments is to link programs
  with different sets of libraries.

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN239"
></A
>Building Libraries</H1
><P
>&#13;    You build your own libraries by specifying <TT
CLASS="FUNCTION"
>Library</TT
>
    instead of <TT
CLASS="FUNCTION"
>Program</TT
>:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Library('foo', ['f1.c', 'f2.c', 'f3.c'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> uses the appropriate library prefix and suffix for your system.
    So on POSIX or Linux systems,
    the above example would build as follows
    (although <TT
CLASS="APPLICATION"
>ranlib</TT
> may not be called on all systems):

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f1.o&nbsp;f1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f2.o&nbsp;f2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f3.o&nbsp;f3.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ar&nbsp;r&nbsp;libfoo.a&nbsp;f1.o&nbsp;f2.o&nbsp;f3.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ranlib&nbsp;libfoo.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    On a Windows system,
    a build of the above example would look like:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;f1.c&nbsp;/Fof1.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;f2.c&nbsp;/Fof2.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;f3.c&nbsp;/Fof3.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib&nbsp;/nologo&nbsp;/OUT:foo.lib&nbsp;f1.obj&nbsp;f2.obj&nbsp;f3.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    The rules for the target name of the library
    are similar to those for programs:
    if you don't explicitly specify a target library name,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will deduce one from the
    name of the first source file specified,
    and <TT
CLASS="APPLICATION"
>SCons</TT
> will add an appropriate
    file prefix and suffix if you leave them off.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN256"
></A
>Linking with Libraries</H1
><P
>&#13;    Usually, you build a library
    because you want to link it with one or more programs.
    You link libraries with a program by specifying
    the libraries in the <TT
CLASS="VARNAME"
>LIBS</TT
> construction variable,
    and by specifying the directory in which
    the library will be found in the 
    <TT
CLASS="VARNAME"
>LIBPATH</TT
> construction variable:
      env = Environment(LIBS = 'foo', LIBPATH = '.')

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Library('foo', ['f1.c', 'f2.c', 'f3.c'])
      Program('prog.c', LIBS='foo', LIBPATH='.')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Notice, of course, that you don't need to specify a library
    prefix (like <TT
CLASS="LITERAL"
>lib</TT
>)
    or suffix (like <TT
CLASS="LITERAL"
>.a</TT
> or <TT
CLASS="LITERAL"
>.lib</TT
>).
    <TT
CLASS="APPLICATION"
>SCons</TT
> uses the correct prefix or suffix for the current system.

    </P
><P
>&#13;    On a POSIX or Linux system,
    a build of the above example would look like:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f1.o&nbsp;f1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f2.o&nbsp;f2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f3.o&nbsp;f3.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ar&nbsp;r&nbsp;libfoo.a&nbsp;f1.o&nbsp;f2.o&nbsp;f3.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ranlib&nbsp;libfoo.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog.o&nbsp;prog.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog&nbsp;prog.o&nbsp;-L.&nbsp;-lfoo<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    On a Windows system,
    a build of the above example would look like:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;f1.c&nbsp;/Fof1.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;f2.c&nbsp;/Fof2.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;f3.c&nbsp;/Fof3.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib&nbsp;/nologo&nbsp;/OUT:foo.lib&nbsp;f1.obj&nbsp;f2.obj&nbsp;f3.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;prog.c&nbsp;/Foprog.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;/nologo&nbsp;/OUT:prog.exe&nbsp;/LIBPATH:.&nbsp;foo.lib&nbsp;prog.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    As usual, notice that <TT
CLASS="APPLICATION"
>SCons</TT
> has taken care
    of constructing the correct command lines
    to link with the specified library on each system.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN275"
></A
>Finding Libraries:  the <TT
CLASS="VARNAME"
>LIBPATH</TT
> Construction Variable</H1
><P
>&#13;    By default, the linker will only look in
    certain system-defined directories for libraries.
    <TT
CLASS="APPLICATION"
>SCons</TT
> knows how to look for libraries
    in directories that you specify with the
    <TT
CLASS="VARNAME"
>LIBPATH</TT
> construction variable.
    <TT
CLASS="VARNAME"
>LIBPATH</TT
> consists of a list of
    directory names, like so:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Program('prog.c', LIBS = 'm',
                        LIBPATH = ['/usr/lib', '/usr/local/lib'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Using a Python list is preferred because it's portable
    across systems.  Alternatively, you could put all of
    the directory names in a single string, separated by the
    system-specific path separator character:
    a colon on POSIX systems:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      LIBPATH = '/usr/lib:/usr/local/lib'
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    or a semi-colon on Windows systems:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      LIBPATH = 'C:\lib;D:\lib'
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    When the linker is executed,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will create appropriate flags
    so that the linker will look for
    libraries in the same directories as <TT
CLASS="APPLICATION"
>SCons</TT
>.
    So on a POSIX or Linux system,
    a build of the above example would look like:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog.o&nbsp;prog.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog&nbsp;prog.o&nbsp;-L/usr/lib&nbsp;-L/usr/local/lib&nbsp;-lm<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    On a Windows system,
    a build of the above example would look like:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/c&nbsp;prog.c&nbsp;/Foprog.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;/nologo&nbsp;/OUT:prog.exe&nbsp;/LIBPATH:\usr\lib&nbsp;/LIBPATH:\usr\local\lib&nbsp;m.lib&nbsp;prog.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Note again that <TT
CLASS="APPLICATION"
>SCons</TT
> has taken care of
    the system-specific details of creating
    the right command-line options.

    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-DEPENDS"
></A
>Dependencies</H1
><P
>&#13;  So far we've seen how <TT
CLASS="APPLICATION"
>SCons</TT
> handles one-time builds.
  But the real point of a build tool like <TT
CLASS="APPLICATION"
>SCons</TT
>
  is to rebuild only the necessary things
  when source files change--or, put another way,
  <TT
CLASS="APPLICATION"
>SCons</TT
> should <I
CLASS="EMPHASIS"
>not</I
>
  waste time rebuilding things that have already been built.
  You can see this at work simply be re-invoking <TT
CLASS="APPLICATION"
>SCons</TT
>
  after building our simple <TT
CLASS="APPLICATION"
>hello</TT
> example:

  </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`.'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;</P
><P
>&#13;  The second time it is executed,
  <TT
CLASS="APPLICATION"
>SCons</TT
> realizes that the <TT
CLASS="APPLICATION"
>hello</TT
> program
  is up-to-date with respect to the current <TT
CLASS="FILENAME"
>hello.c</TT
> source file,
  and avoids rebuilding it.
  You can see this more clearly by naming
  the <TT
CLASS="APPLICATION"
>hello</TT
> program explicitly on the command line:

  </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;</P
><P
>&#13;  Note that <TT
CLASS="APPLICATION"
>SCons</TT
> reports <TT
CLASS="LITERAL"
>"...is up to date"</TT
>
  only for target files named explicitly on the command line,
  to avoid cluttering the output.

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN320"
></A
>Source File Signatures</H1
><P
>&#13;    The other side of avoiding unnecessary rebuilds
    is the fundamental build tool behavior
    of <I
CLASS="EMPHASIS"
>rebuilding</I
>
    things when a source file changes,
    so that the built software is up to date.
    <TT
CLASS="APPLICATION"
>SCons</TT
> keeps track of this through a
    <TT
CLASS="LITERAL"
>signature</TT
> for each source file,
    and allows you to configure
    whether you want to use the source
    file contents or the modification time (timestamp)
    as the signature.

    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN326"
></A
>MD5 Source File Signatures</H2
><P
>&#13;      By default,
      <TT
CLASS="APPLICATION"
>SCons</TT
> keeps track of whether a source file has changed
      based on the file's contents,
      not the modification time.
      This means that you may be surprised by the
      default <TT
CLASS="APPLICATION"
>SCons</TT
> behavior if you are used to the
      <TT
CLASS="APPLICATION"
>Make</TT
> convention of forcing
      a rebuild by updating the file's modification time
      (using the <TT
CLASS="APPLICATION"
>touch</TT
> command, for example):

      </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>touch hello.c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;      Even though the file's modification time has changed,
      <TT
CLASS="APPLICATION"
>SCons</TT
> realizes that the contents of the
      <TT
CLASS="FILENAME"
>hello.c</TT
> file have <I
CLASS="EMPHASIS"
>not</I
> changed,
      and therefore that the <TT
CLASS="APPLICATION"
>hello</TT
> program
      need not be rebuilt.
      This avoids unnecessary rebuilds when,
      for example, someone rewrites the
      contents of a file without making a change.
      But if the contents of the file really do change,
      then <TT
CLASS="APPLICATION"
>SCons</TT
> detects the change
      and rebuilds the program as required:

      </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>edit hello.c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[CHANGE&nbsp;THE&nbsp;CONTENTS&nbsp;OF&nbsp;hello.c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;      Note that you can, if you wish,
      specify this default behavior
      (MD5 signatures) explicitly
      using the <TT
CLASS="FUNCTION"
>SourceSignatures</TT
> function as follows:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Program('hello.c')
        SourceSignatures('MD5')
      </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN350"
></A
>Source File Time Stamps</H2
><P
>&#13;      If you prefer, you can
      configure <TT
CLASS="APPLICATION"
>SCons</TT
> to use the modification time
      of source files,
      not the file contents,
      when deciding if something needs to be rebuilt.
      To do this, call the <TT
CLASS="FUNCTION"
>SourceSignatures</TT
>
      function as follows:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Program('hello.c')
        SourceSignatures('timestamp')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      This makes <TT
CLASS="APPLICATION"
>SCons</TT
> act like <TT
CLASS="APPLICATION"
>Make</TT
>
      when a file's modification time is updated
      (using the <TT
CLASS="APPLICATION"
>touch</TT
> command, for example):

      </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>touch hello.c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN364"
></A
>Target File Signatures</H1
><P
>&#13;    As you've just seen,
    <TT
CLASS="APPLICATION"
>SCons</TT
> uses signatures to decide whether a 
    target file is up to date or must be rebuilt.
    When a target file depends on another target file,
    <TT
CLASS="APPLICATION"
>SCons</TT
> allows you to separately configure
    how the signatures of "intermediate" target files
    are used when deciding if a dependent target file
    must be rebuilt.

    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN369"
></A
>Build Signatures</H2
><P
>&#13;      Modifying a source file
      will cause not only its direct target file to be rebuilt,
      but also the target file(s)
      that depend on that direct target file.
      In our example,
      changing the contents of the <TT
CLASS="FILENAME"
>hello.c</TT
> file causes
      the <TT
CLASS="FILENAME"
>hello.o</TT
> file to be rebuilt,
      which in turn causes the
      <TT
CLASS="APPLICATION"
>hello</TT
> program to be rebuilt:

      </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>edit hello.c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[CHANGE&nbsp;THE&nbsp;CONTENTS&nbsp;OF&nbsp;hello.c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;      What's not obvious, though,
      is that <TT
CLASS="APPLICATION"
>SCons</TT
> internally handles the signature of
      the target file(s)
      (<TT
CLASS="FILENAME"
>hello.o</TT
> in the above example)
      differently from the signature of the source file
      (<TT
CLASS="FILENAME"
>hello.c</TT
>).
      By default,
      <TT
CLASS="APPLICATION"
>SCons</TT
> tracks whether a target file must be rebuilt
      by using a <TT
CLASS="LITERAL"
>build signature</TT
>
      that consists of the combined
      signatures of all the files
      that go into making the target file.
      This is efficient because
      the accumulated signatures
      actually give <TT
CLASS="APPLICATION"
>SCons</TT
> all of the
      information it needs
      to decide if the target file is out of date.

      </P
><P
>&#13;      If you wish, you can
      specify this default behavior
      (build signatures) explicitly
      using the <TT
CLASS="FUNCTION"
>TargetSignatures</TT
> function:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Program('hello.c')
        TargetSignatures('build')
      </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN389"
></A
>File Contents</H2
><P
>&#13;      Sometimes a source file can be changed
      in such a way that the contents of the
      rebuilt target file(s)
      will be exactly the same as the last time
      the file was built.
      If so, then any other target files
      that depend on such a built-but-not-changed target
      file actually need not be rebuilt.
      You can make <TT
CLASS="APPLICATION"
>SCons</TT
>
      realize that it does not need to rebuild
      a dependent target file in this situation
      using the <TT
CLASS="FUNCTION"
>TargetSignatures</TT
> function as follows:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Program('hello.c')
        TargetSignatures('content')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      So if, for example,
      a user were to only change a comment in a C file,
      then the rebuilt <TT
CLASS="FILENAME"
>hello.o</TT
> file
      would be exactly the same as the one previously built
      (assuming the compiler doesn't put any build-specific
      information in the object file).
      <TT
CLASS="APPLICATION"
>SCons</TT
> would then realize that it would not
      need to rebuild the <TT
CLASS="APPLICATION"
>hello</TT
> program as follows:

      </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>edit hello.c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[CHANGE&nbsp;A&nbsp;COMMENT&nbsp;IN&nbsp;hello.c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;      In essence, <TT
CLASS="APPLICATION"
>SCons</TT
> has
      "short-circuited" any dependent builds
      when it realizes that a target file
      has been rebuilt to exactly the same file as the last build.
      So configured,
      <TT
CLASS="APPLICATION"
>SCons</TT
> does take some extra processing time
      to scan the contents of the target (<TT
CLASS="FILENAME"
>hello.o</TT
>) file,
      but this may save time
      if the rebuild that was avoided
      would have been very time-consuming and expensive.

      </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN407"
></A
>Implicit Dependencies:  The <TT
CLASS="LITERAL"
>CPPPATH</TT
> Construction Variable</H1
><P
>&#13;    Now suppose that our "Hello, World!" program
    actually has a <TT
CLASS="LITERAL"
>#include</TT
> line
    to include the <TT
CLASS="FILENAME"
>hello.h</TT
> file in the compilation:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       #include "hello.h" 
       int
       main()
       {
           printf("Hello, %s!\n", string);
       }
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    And, for completeness, the <TT
CLASS="FILENAME"
>hello.h</TT
> file looks like this:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       #define string    "world"
      </PRE
></TD
></TR
></TABLE
><P
>&#13;    In this case, we want <TT
CLASS="APPLICATION"
>SCons</TT
> to recognize that,
    if the contents of the <TT
CLASS="FILENAME"
>hello.h</TT
> file change,
    the <TT
CLASS="APPLICATION"
>hello</TT
> program must be recompiled.
    To do this, we need to modify the
    <TT
CLASS="FILENAME"
>SConstruct</TT
> file like so:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       Program('hello.c', CPPPATH = '.')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;    The <TT
CLASS="LITERAL"
>CPPPATH</TT
> value
    tells <TT
CLASS="APPLICATION"
>SCons</TT
> to look in the current directory
    (<TT
CLASS="LITERAL"
>'.'</TT
>)
    for any files included by C source files
    (<TT
CLASS="FILENAME"
>.c</TT
> or <TT
CLASS="FILENAME"
>.h</TT
> files).
    With this assignment in the <TT
CLASS="FILENAME"
>SConstruct</TT
> file:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-I.&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>edit hello.h</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[CHANGE&nbsp;THE&nbsp;CONTENTS&nbsp;OF&nbsp;hello.h]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-I.&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    First, notice that <TT
CLASS="APPLICATION"
>SCons</TT
>
    added the <TT
CLASS="LITERAL"
>-I.</TT
> argument
    from the <TT
CLASS="LITERAL"
>CPPPATH</TT
> variable
    so that the compilation would find the
    <TT
CLASS="FILENAME"
>hello.h</TT
> file in the local directory.

    </P
><P
>&#13;    Second, realize that <TT
CLASS="APPLICATION"
>SCons</TT
> knows that the <TT
CLASS="APPLICATION"
>hello</TT
>
    program must be rebuilt
    because it scans the contents of
    the <TT
CLASS="FILENAME"
>hello.c</TT
> file
    for the <TT
CLASS="LITERAL"
>#include</TT
> lines that indicate
    another file is being included in the compilation.
    <TT
CLASS="APPLICATION"
>SCons</TT
> records these as
    <I
CLASS="EMPHASIS"
>implicit dependencies</I
>
    of the target file,
    Consequently,
    when the <TT
CLASS="FILENAME"
>hello.h</TT
> file changes,
    <TT
CLASS="APPLICATION"
>SCons</TT
> realizes that the <TT
CLASS="FILENAME"
>hello.c</TT
> file includes it,
    and rebuilds the resulting <TT
CLASS="APPLICATION"
>hello</TT
> program
    that depends on both the <TT
CLASS="FILENAME"
>hello.c</TT
> and <TT
CLASS="FILENAME"
>hello.h</TT
> files.

    </P
><P
>&#13;    Like the <TT
CLASS="VARNAME"
>LIBPATH</TT
> variable,
    the <TT
CLASS="LITERAL"
>CPPPATH</TT
> variable
    may be a list of directories,
    or a string separated by
    the system-specific path separate character
    (':' on POSIX/Linux, ';' on Windows).
    Either way, <TT
CLASS="APPLICATION"
>SCons</TT
> creates the
    right command-line options
    so that the following example:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       Program('hello.c', CPPPATH = ['include', '/home/project/inc'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Will look like this on POSIX or Linux:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-Iinclude&nbsp;-I/home/project/inc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    And like this on Windows:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons -Q hello.exe</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/Iinclude&nbsp;/I\home\project\inc&nbsp;/c&nbsp;hello.c&nbsp;/Fohello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;/nologo&nbsp;/OUT:hello.exe&nbsp;hello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN464"
></A
>Caching Implicit Dependencies</H1
><P
>&#13;    Scanning each file for <TT
CLASS="LITERAL"
>#include</TT
> lines
    does take some extra processing time.
    When you're doing a full build of a large system,
    the scanning time is usually a very small percentage
    of the overall time spent on the build.
    You're most likely to notice the scanning time,
    however, when you <I
CLASS="EMPHASIS"
>rebuild</I
>
    all or part of a large system:
    <TT
CLASS="APPLICATION"
>SCons</TT
> will likely take some extra time to "think about"
    what must be built before it issues the
    first build command
    (or decides that everything is up to date
    and nothing must be rebuilt).

 

    </P
><P
>&#13;    In practice, having <TT
CLASS="APPLICATION"
>SCons</TT
> scan files saves time
    relative to the amount of potential time
    lost to tracking down subtle problems
    introduced by incorrect dependencies.
    Nevertheless, the "waiting time"
    while <TT
CLASS="APPLICATION"
>SCons</TT
> scans files can annoy
    individual developers waiting for their builds to finish.
    Consequently, <TT
CLASS="APPLICATION"
>SCons</TT
> lets you cache
    the implicit dependencies
    that its scanners find,
    for use by later builds.
    You can do this by specifying the
    <TT
CLASS="LITERAL"
>--implicit-cache</TT
> option on the command line:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q --implicit-cache hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    If you don't want to specify <TT
CLASS="LITERAL"
>--implicit-cache</TT
>
    on the command line each time,
    you can make it the default behavior for your build
    by setting the <TT
CLASS="LITERAL"
>implicit_cache</TT
> option
    in an <TT
CLASS="FILENAME"
>SConscript</TT
> file:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       SetOption('implicit_cache', 1)
    </PRE
></TD
></TR
></TABLE
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN483"
></A
>The <TT
CLASS="LITERAL"
>--implicit-deps-changed</TT
> Option</H2
><P
>&#13;      When using cached implicit dependencies,
      sometimes you want to "start fresh"
      and have <TT
CLASS="APPLICATION"
>SCons</TT
> re-scan the files
      for which it previously cached the dependencies.
      For example,
      if you have recently installed a new version of
      external code that you use for compilation,
      the external header files will have changed
      and the previously-cached implicit dependencies
      will be out of date.
      You can update them by
      running <TT
CLASS="APPLICATION"
>SCons</TT
> with the <TT
CLASS="LITERAL"
>--implicit-deps-changed</TT
> option:

      </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q --implicit-deps-changed hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;      In this case, <TT
CLASS="APPLICATION"
>SCons</TT
> will re-scan all of the implicit dependencies
      and cache updated copies of the information.

      </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN495"
></A
>The <TT
CLASS="LITERAL"
>--implicit-deps-unchanged</TT
> Option</H2
><P
>&#13;      By default when caching dependencies,
      <TT
CLASS="APPLICATION"
>SCons</TT
> notices when a file has been modified
      and re-scans the file for any updated
      implicit dependency information.
      Sometimes, however, you may want
      to force <TT
CLASS="APPLICATION"
>SCons</TT
> to use the cached implicit dependencies, 
      even if the source files changed.
      This can speed up a build for example,
      when you have changed your source files
      but know that you haven't changed
      any <TT
CLASS="LITERAL"
>#include</TT
> lines.
      In this case,
      you can use the <TT
CLASS="LITERAL"
>--implicit-deps-unchanged</TT
> option:

      </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q --implicit-deps-unchanged hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;      In this case,
      <TT
CLASS="APPLICATION"
>SCons</TT
> will assume that the cached implicit
      dependencies are correct and
      will not bother to re-scan changed files.
      For typical builds after small,
      incremental changes to source files,
      the savings may not be very big,
      but sometimes every bit of
      improved performance counts.

      </P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN508"
></A
>The <TT
CLASS="FUNCTION"
>Ignore</TT
> Method</H1
><P
>&#13;    Sometimes it makes sense 
    to not rebuild a program,
    even if a dependency file changes.
    In this case,
    you would tell <TT
CLASS="APPLICATION"
>SCons</TT
> specifically
    to ignore a dependency as follows:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      hello = Program('hello.c')
      Ignore(hello, 'hello.h')
    </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>edit hello.h</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[CHANGE&nbsp;THE&nbsp;CONTENTS&nbsp;OF&nbsp;hello.h]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Now, the above example is a little contrived,
    because it's hard to imagine a real-world situation
    where you wouldn't to rebuild <TT
CLASS="APPLICATION"
>hello</TT
>
    if the <TT
CLASS="FILENAME"
>hello.h</TT
> file changed.
    A more realistic example
    might be if the <TT
CLASS="APPLICATION"
>hello</TT
>
    program is being built in a
    directory that is shared between multiple systems
    that have different copies of the
    <TT
CLASS="FILENAME"
>stdio.h</TT
> include file.
    In that case,
    <TT
CLASS="APPLICATION"
>SCons</TT
> would notice the differences between
    the different systems' copies of <TT
CLASS="FILENAME"
>stdio.h</TT
>
    and would rebuild <TT
CLASS="APPLICATION"
>hello</TT
>
    each time you change systems.
    You could avoid these rebuilds as follows:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       hello = env.Program('hello.c')
       env.Ignore(hello, '/usr/include/stdio.h')
    </PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN528"
></A
>The <TT
CLASS="FUNCTION"
>Depends</TT
> Method</H1
><P
>&#13;    On the other hand,
    sometimes a file depends on another file
    that is not detected by an <TT
CLASS="APPLICATION"
>SCons</TT
> scanner.
    For this situation,
    <TT
CLASS="APPLICATION"
>SCons</TT
> allows you to specific explicitly that one file
    depends on another file,
    and must be rebuilt whenever that file changes.
    This is specified using the <TT
CLASS="FUNCTION"
>Depends</TT
> method:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       hello = env.Program('hello.c')
       env.Depends(hello, 'other_file')
    </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;hello.c&nbsp;-o&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>edit other_file</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[CHANGE&nbsp;THE&nbsp;CONTENTS&nbsp;OF&nbsp;other_file]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;hello.c&nbsp;-o&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-ENVIRONMENTS"
></A
>Construction Environments</H1
><P
>&#13;   It is rare that all of the software in a large,
   complicated system needs to be built the same way.
   For example, different source files may need different options
   enabled on the command line,
   or different executable programs need to be linked
   with different libraries.
   <TT
CLASS="APPLICATION"
>SCons</TT
> accomodates these different build
   requirements by allowing you to create and
   configure multiple <TT
CLASS="LITERAL"
>construction environments</TT
>
   that control how the software is built.
   Technically, a <TT
CLASS="LITERAL"
>construction environment</TT
> is an object
   that has a number of associated
   <TT
CLASS="LITERAL"
>construction variables</TT
>, each with a name and a value.
   (A <TT
CLASS="LITERAL"
>construction environment</TT
> also has an attached
   set of <TT
CLASS="CLASSNAME"
>Builder</TT
> methods,
   about which we'll learn more later.)

 </P
><P
>&#13;   A <TT
CLASS="LITERAL"
>construction environment</TT
> is created by the <TT
CLASS="FUNCTION"
>Environment</TT
> method.
   When you initialize a <TT
CLASS="LITERAL"
>construction environment</TT
>,
   you can set the values of the
   environment's <TT
CLASS="LITERAL"
>construction variables</TT
>
   to control how a program is built.
   For example:

 </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    env = Environment(CC = 'gcc',
                      CCFLAGS = '-O2')

    env.Program('foo.c')
  </PRE
></TD
></TR
></TABLE
><P
>   
   This example, rather than using the default,
   explicitly specifies use of the
   GNU C compiler <TT
CLASS="APPLICATION"
>gcc</TT
>,
   and further specifies that the <TT
CLASS="LITERAL"
>-O2</TT
>
   (optimization level two)
   flag should be used when compiling the object file.
   So a run from this example would look like:

 </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-O2&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;</P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN561"
></A
>Multiple <TT
CLASS="LITERAL"
>Construction Environments</TT
></H1
><P
>&#13;   The real advantage of construction environments
   become apparent when you realize
   that you can create as many different construction
   environments as you need,
   each tailored to a different way to build
   some piece of software or other file.
   If, for example, we need to build
   one program with the <TT
CLASS="LITERAL"
>-O2</TT
> flag
   and another with the <TT
CLASS="LITERAL"
>-g</TT
> (debug) flag,
   we would do this like so:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      opt = Environment(CCFLAGS = '-O2')
      dbg = Environment(CCFLAGS = '-g')

      opt.Program('foo', 'foo.c')

      dbg.Program('bar', 'bar.c')
   </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-g&nbsp;-c&nbsp;-o&nbsp;bar.o&nbsp;bar.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;bar&nbsp;bar.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-O2&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   We can even use multiple <TT
CLASS="LITERAL"
>construction environments</TT
> to build
   multiple versions of a single program.
   If you do this by simply trying to use the
   <TT
CLASS="FUNCTION"
>Program</TT
> builder with both environments, though,
   like this:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      opt = Environment(CCFLAGS = '-O2')
      dbg = Environment(CCFLAGS = '-g')

      opt.Program('foo', 'foo.c')

      dbg.Program('foo', 'foo.c')
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Then <TT
CLASS="APPLICATION"
>SCons</TT
> generates the following error:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;***&nbsp;Two&nbsp;different&nbsp;environments&nbsp;were&nbsp;specified&nbsp;for&nbsp;the&nbsp;same&nbsp;target:&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;"SConstruct",&nbsp;line&nbsp;6,&nbsp;in&nbsp;?<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   This is because the two <TT
CLASS="FUNCTION"
>Program</TT
> calls have
   each implicitly told <TT
CLASS="APPLICATION"
>SCons</TT
> to generate an object file named
   <TT
CLASS="FILENAME"
>foo.o</TT
>,
   one with a <TT
CLASS="VARNAME"
>CCFLAGS</TT
> value of
   <TT
CLASS="LITERAL"
>-O2</TT
>
   and one with a <TT
CLASS="VARNAME"
>CCFLAGS</TT
> value of
   <TT
CLASS="LITERAL"
>-g</TT
>.
   <TT
CLASS="APPLICATION"
>SCons</TT
> can't just decide that one of them
   should take precedence over the other,
   so it generates the error.
   To avoid this problem,
   we must explicitly specify
   that each environment compile
   <TT
CLASS="FILENAME"
>foo.c</TT
>
   to a separately-named object file
   using the <TT
CLASS="FUNCTION"
>Object</TT
> call, like so:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   </PRE
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      opt = Environment(CCFLAGS = '-O2')
      dbg = Environment(CCFLAGS = '-g')

      o = opt.Object('foo-opt', 'foo.c')
      opt.Program(o)

      d = dbg.Object('foo-dbg', 'foo.c')
      dbg.Program(d)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Notice that each call to the <TT
CLASS="FUNCTION"
>Object</TT
> builder
   returns a value,
   an internal <TT
CLASS="APPLICATION"
>SCons</TT
> object that
   represents the object file that will be built.
   We then use that object
   as input to the <TT
CLASS="FUNCTION"
>Program</TT
> builder.
   This avoids having to specify explicitly
   the object file name in multiple places,
   and makes for a compact, readable
   <TT
CLASS="FILENAME"
>SConstruct</TT
> file.
   Our <TT
CLASS="APPLICATION"
>SCons</TT
> output then looks like:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-g&nbsp;-c&nbsp;-o&nbsp;foo-dbg.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo-dbg&nbsp;foo-dbg.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-O2&nbsp;-c&nbsp;-o&nbsp;foo-opt.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo-opt&nbsp;foo-opt.o<br>
&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN599"
></A
>Copying <TT
CLASS="LITERAL"
>Construction Environments</TT
></H1
><P
>&#13;   Sometimes you want more than one <TT
CLASS="LITERAL"
>construction environment</TT
>
   to share the same values for one or more variables.
   Rather than always having to repeat all of the common
   variables when you create each <TT
CLASS="LITERAL"
>construction environment</TT
>,
   you can use the <TT
CLASS="FUNCTION"
>Copy</TT
> method
   to create a copy of a <TT
CLASS="LITERAL"
>construction environment</TT
>.

   </P
><P
>&#13;   Like the <TT
CLASS="FUNCTION"
>Environment</TT
> call that creates a <TT
CLASS="LITERAL"
>construction environment</TT
>,
   the <TT
CLASS="FUNCTION"
>Copy</TT
> method takes <TT
CLASS="LITERAL"
>construction variable</TT
> assignments,
   which will override the values in the copied <TT
CLASS="LITERAL"
>construction environment</TT
>.
   For example, suppose we want to use <TT
CLASS="APPLICATION"
>gcc</TT
>
   to create three versions of a program,
   one optimized, one debug, and one with neither.
   We could do this by creating a "base" <TT
CLASS="LITERAL"
>construction environment</TT
>
   that sets <TT
CLASS="VARNAME"
>CC</TT
> to <TT
CLASS="APPLICATION"
>gcc</TT
>,
   and then creating two copies,
   one which sets <TT
CLASS="VARNAME"
>CCFLAGS</TT
> for optimization
   and the other which sets <TT
CLASS="VARNAME"
>CCFLAGS</TT
> for debugging:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment(CC = 'gcc')
      opt = env.Copy(CCFLAGS = '-O2')
      dbg = env.Copy(CCFLAGS = '-g')

      env.Program('foo', 'foo.c')

      o = opt.Object('foo-opt', 'foo.c')
      opt.Program(o)

      d = dbg.Object('foo-dbg', 'foo.c')
      dbg.Program(d)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Then our output would look like:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-g&nbsp;-c&nbsp;-o&nbsp;foo-dbg.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-o&nbsp;foo-dbg&nbsp;foo-dbg.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-O2&nbsp;-c&nbsp;-o&nbsp;foo-opt.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-o&nbsp;foo-opt&nbsp;foo-opt.o<br>
&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN623"
></A
>Fetching Values From a <TT
CLASS="LITERAL"
>Construction Environment</TT
></H1
><P
>&#13;   You can fetch individual construction variables
   using the normal syntax
   for accessing individual named items in a Python dictionary:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment()
      print "CC is:", env['CC']
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   This example <TT
CLASS="FILENAME"
>SConstruct</TT
> file doesn't build anything,
   but because it's actually a Python script,
   it will print the value of <TT
CLASS="VARNAME"
>CC</TT
> for us:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC&nbsp;is:&nbsp;cc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`.'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   A <TT
CLASS="LITERAL"
>construction environment</TT
>, however,
   is actually a Python object with
   associated methods, etc.
   If you want to have direct access to only the
   dictionary of construction variables,
   you can fetch this using the <TT
CLASS="LITERAL"
>Dictionary</TT
> method:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment(FOO = 'foo', BAR = 'bar')
      dict = env.Dictionary()
      for key in ['OBJSUFFIX', 'LIBSUFFIX', 'PROGSUFFIX']:
          print "key = %s, value = %s" % (key, dict[key])
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   This <TT
CLASS="FILENAME"
>SConstruct</TT
> file
   will print the specified dictionary items for us on POSIX
   systems as follows:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;OBJSUFFIX,&nbsp;value&nbsp;=&nbsp;.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;LIBSUFFIX,&nbsp;value&nbsp;=&nbsp;.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;PROGSUFFIX,&nbsp;value&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`.'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   And on Win32:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;OBJSUFFIX,&nbsp;value&nbsp;=&nbsp;.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;LIBSUFFIX,&nbsp;value&nbsp;=&nbsp;.lib<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;PROGSUFFIX,&nbsp;value&nbsp;=&nbsp;.exe<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`.'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN644"
></A
>Modifying a <TT
CLASS="LITERAL"
>Construction Environment</TT
></H1
><P
>&#13;   <TT
CLASS="APPLICATION"
>SCons</TT
> provides various methods that
   support modifying existing values in a <TT
CLASS="LITERAL"
>construction environment</TT
>.

   </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN650"
></A
>Replacing Values in a <TT
CLASS="LITERAL"
>Construction Environment</TT
></H2
><P
>&#13;     You can replace existing construction variable values
     using the <TT
CLASS="FUNCTION"
>Replace</TT
> method:

     </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        env = Environment(CCFLAGS = '-DDEFINE1')
        env.Program('foo.c')
        env.Replace(CCFLAGS = '-DDEFINE2')
        env.Program('bar.c')
     </PRE
></TD
></TR
></TABLE
><P
>&#13;     The replaced value completely overwrites

     </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-DDEFINE2&nbsp;-c&nbsp;-o&nbsp;bar.o&nbsp;bar.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;bar&nbsp;bar.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-DDEFINE1&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN659"
></A
>Appending to the End of Values in a <TT
CLASS="LITERAL"
>Construction Environment</TT
></H2
><P
>&#13;     You can append a value to
     an existing construction variable
     using the <TT
CLASS="FUNCTION"
>Append</TT
> method:

     </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        env = Environment(CCFLAGS = '-DMY_VALUE')
        env.Append(CCFLAGS = ' -DLAST')
        env.Program('foo.c')
     </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-DMY_VALUE&nbsp;-DLAST&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN667"
></A
>Appending to the Beginning of Values in a <TT
CLASS="LITERAL"
>Construction Environment</TT
></H2
><P
>&#13;     You can append a value to the beginning
     an existing construction variable
     using the <TT
CLASS="FUNCTION"
>Prepend</TT
> method:

     </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        env = Environment(CCFLAGS = '-DMY_VALUE')
        env.Prepend(CCFLAGS = '-DFIRST ')
        env.Program('foo.c')
     </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-DFIRST&nbsp;-DMY_VALUE&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-DEFAULT"
></A
>Default Targets</H1
><P
>&#13;   As mentioned previously,
   <TT
CLASS="APPLICATION"
>SCons</TT
> will build every target
   in or below the current directory
   by default--that is, when you don't
   explicitly specify one or more targets
   on the command line.
   Sometimes, however, you may want
   to specify explicitly that only
   certain programs should be built by default.
   You do this with the <TT
CLASS="FUNCTION"
>Default</TT
> function:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment()
      hello = env.Program('hello.c')
      env.Program('goodbye.c')
      Default(hello)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   This <TT
CLASS="FILENAME"
>SConstruct</TT
> file knows how to build two programs,
   <TT
CLASS="APPLICATION"
>hello</TT
> and <TT
CLASS="APPLICATION"
>goodbye</TT
>,
   but only builds the
   <TT
CLASS="APPLICATION"
>hello</TT
> program by default:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q goodbye</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;goodbye.o&nbsp;goodbye.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;goodbye&nbsp;goodbye.o<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   Note that, even when you use the <TT
CLASS="FUNCTION"
>Default</TT
>
   function in your <TT
CLASS="FILENAME"
>SConstruct</TT
> file,
   you can still explicitly specify the current directory
   (<TT
CLASS="LITERAL"
>.</TT
>) on the command line
   to tell <TT
CLASS="APPLICATION"
>SCons</TT
> to build
   everything in (or below) the current directory:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q .</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;goodbye.o&nbsp;goodbye.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;goodbye&nbsp;goodbye.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   You can also call the <TT
CLASS="FUNCTION"
>Default</TT
>
   function more than once,
   in which case each call
   adds to the list of targets to be built by default:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment()
      prog1 = env.Program('prog1.c')
      Default(prog1)
      prog2 = env.Program('prog2.c')
      prog3 = env.Program('prog3.c')
      Default(prog3)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Or you can specify more than one target
   in a single call to the <TT
CLASS="FUNCTION"
>Default</TT
> function:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment()
      prog1 = env.Program('prog1.c')
      prog2 = env.Program('prog2.c')
      prog3 = env.Program('prog3.c')
      Default(prog1, prog3)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Either of these last two examples
   will build only the
   <TT
CLASS="APPLICATION"
>prog1</TT
>
   and
   <TT
CLASS="APPLICATION"
>prog3</TT
>
   programs by default:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog1.o&nbsp;prog1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog1&nbsp;prog1.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog3.o&nbsp;prog3.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog3&nbsp;prog3.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q .</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog2.o&nbsp;prog2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog2&nbsp;prog2.o<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   Lastly, if for some reason you don't want
   any targets built by default,
   you can use the Python <TT
CLASS="LITERAL"
>None</TT
>
   variable:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment()
      prog1 = env.Program('prog1.c')
      prog2 = env.Program('prog2.c')
      Default(None)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   Which would produce build output like:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;***&nbsp;No&nbsp;targets&nbsp;specified&nbsp;and&nbsp;no&nbsp;Default()&nbsp;targets&nbsp;found.&nbsp;&nbsp;Stop.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q .</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog1.o&nbsp;prog1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog1&nbsp;prog1.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog2.o&nbsp;prog2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog2&nbsp;prog2.o<br>
&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-HELP"
></A
>Providing Build Help</H1
><P
>&#13;   It's often very useful to be able to give
   users some help that describes the
   specific targets, build options, etc.,
   that can be used for your build.
   <TT
CLASS="APPLICATION"
>SCons</TT
> provides the <TT
CLASS="FUNCTION"
>Help</TT
> function
   to allow you to specify this help text:

   </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      Help("""
      Type: 'scons program' to build the production program,
            'scons debug' to build the debug version.
      """)
   </PRE
></TD
></TR
></TABLE
><P
>&#13;   (Note the above use of the Python triple-quote syntax,
   which comes in very handy for
   specifying multi-line strings like help text.)

   </P
><P
>&#13;   When the <TT
CLASS="FILENAME"
>SConstruct</TT
> or <TT
CLASS="FILENAME"
>SConscript</TT
> files
   contain such a call to the <TT
CLASS="FUNCTION"
>Help</TT
> function,
   the specified help text will be displayed in response to
   the <TT
CLASS="APPLICATION"
>SCons</TT
> <TT
CLASS="LITERAL"
>-h</TT
> option:

   </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -h</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;Reading&nbsp;SConscript&nbsp;files&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;done&nbsp;reading&nbsp;SConscript&nbsp;files.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type:&nbsp;'scons&nbsp;program'&nbsp;to&nbsp;build&nbsp;the&nbsp;production&nbsp;program,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'scons&nbsp;debug'&nbsp;to&nbsp;build&nbsp;the&nbsp;debug&nbsp;version.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use&nbsp;scons&nbsp;-H&nbsp;for&nbsp;help&nbsp;about&nbsp;command-line&nbsp;options.<br>
&nbsp;&nbsp;&nbsp;</P
><P
>&#13;   If there is no <TT
CLASS="FUNCTION"
>Help</TT
> text in the <TT
CLASS="FILENAME"
>SConstruct</TT
> or
   <TT
CLASS="FILENAME"
>SConscript</TT
> files,
   <TT
CLASS="APPLICATION"
>SCons</TT
> will revert to displaying its
   standard list that describes the <TT
CLASS="APPLICATION"
>SCons</TT
> command-line
   options.
   This list is also always displayed whenever
   the <TT
CLASS="LITERAL"
>-H</TT
> option is used.

   </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-INSTALL"
></A
>Installing Files in Other Directories</H1
><P
>&#13;  Once a program is built,
  it is often appropriate to install it in another
  directory for public use.
  You use the <TT
CLASS="FUNCTION"
>Install</TT
> method 
  to arrange for a program, or any other file,
  to be copied into a destination directory:

  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     env = Environment()
     hello = env.Program('hello.c')
     env.Install('/usr/bin', hello)
  </PRE
></TD
></TR
></TABLE
><P
>&#13;  Note, however, that installing a file is
  still considered a type of file "build."
  This is important when you remember that
  the default behavior of <TT
CLASS="APPLICATION"
>SCons</TT
> is
  to build files in or below the current directory.
  If, as in the example above,
  you are installing files in a directory
  outside of the top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> file's directory tree,
  you must specify that directory
  (or a higher directory, such as <TT
CLASS="LITERAL"
>/</TT
>)
  for it to install anything there:

  </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q /usr/bin</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"hello"&nbsp;as&nbsp;"/usr/bin/hello"<br>
&nbsp;&nbsp;</P
><P
>&#13;  It can, however, be cumbersome to remember
  (and type) the specific destination directory
  in which the program (or any other file)
  should be installed.
  This is an area where the <TT
CLASS="FUNCTION"
>Alias</TT
>
  function comes in handy,
  allowing you, for example,
  to create a pseudo-target named <TT
CLASS="LITERAL"
>install</TT
>
  that can expand to the specified destination directory:

  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     env = Environment()
     hello = env.Program('hello.c')
     env.Install('/usr/bin', hello)
     env.Alias('install', '/usr/bin')
  </PRE
></TD
></TR
></TABLE
><P
>&#13;  This then yields the more natural
  ability to install the program
  in its destination as follows:

  </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q install</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"hello"&nbsp;as&nbsp;"/usr/bin/hello"<br>
&nbsp;&nbsp;</P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN758"
></A
>Installing Multiple Files in a Directory</H1
><P
>&#13;    You can install multiple files into a directory
    simply by calling the <TT
CLASS="FUNCTION"
>Install</TT
> function multiple times:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       hello = env.Program('hello.c')
       goodbye = env.Program('goodbye.c')
       env.Install('/usr/bin', hello)
       env.Install('/usr/bin', goodbye)
       env.Alias('install', '/usr/bin')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Or, more succinctly, listing the multiple input
    files in a list
    (just like you can do with any other builder):

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       hello = env.Program('hello.c')
       goodbye = env.Program('goodbye.c')
       env.Install('/usr/bin', [hello, goodbye])
       env.Alias('install', '/usr/bin')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Either of these two examples yields:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q install</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;goodbye.o&nbsp;goodbye.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;goodbye&nbsp;goodbye.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"goodbye"&nbsp;as&nbsp;"/usr/bin/goodbye"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"hello"&nbsp;as&nbsp;"/usr/bin/hello"<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN768"
></A
>Installing a File Under a Different Name</H1
><P
>&#13;    The <TT
CLASS="FUNCTION"
>Install</TT
> method preserves the name
    of the file when it is copied into the
    destination directory.
    If you need to change the name of the file
    when you copy it, use the <TT
CLASS="FUNCTION"
>InstallAs</TT
> function:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       hello = env.Program('hello.c')
       env.InstallAs('/usr/bin/hello-new', hello)
       env.Alias('install', '/usr/bin')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    This installs the <TT
CLASS="LITERAL"
>hello</TT
>
    program with the name <TT
CLASS="LITERAL"
>hello-new</TT
>
    as follows:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q install</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"hello"&nbsp;as&nbsp;"/usr/bin/hello-new"<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN779"
></A
>Installing Multiple Files Under Different Names</H1
><P
>&#13;    Lastly, if you have multiple files that all
    need to be installed with different file names,
    you can either call the <TT
CLASS="FUNCTION"
>InstallAs</TT
> function
    multiple times, or as a shorthand,
    you can supply same-length lists
    for the both the target and source arguments:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       hello = env.Program('hello.c')
       goodbye = env.Program('goodbye.c')
       env.InstallAs(['/usr/bin/hello-new',
                      '/usr/bin/goodbye-new'],
                     [hello, goodbye])
       env.Alias('install', '/usr/bin')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    In this case, the <TT
CLASS="FUNCTION"
>InstallAs</TT
> function
    loops through both lists simultaneously,
    and copies each source file into its corresponding
    target file name:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q install</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;goodbye.o&nbsp;goodbye.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;goodbye&nbsp;goodbye.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"goodbye"&nbsp;as&nbsp;"/usr/bin/goodbye-new"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"hello"&nbsp;as&nbsp;"/usr/bin/hello-new"<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-PRECIOUS"
></A
>Preventing Removal of Targets</H1
><P
>&#13; By default, <TT
CLASS="APPLICATION"
>SCons</TT
> removes targets before building them.
 Sometimes, however, this is not what you want.
 For example, you may want to update a library incrementally,
 not by having it deleted and then rebuilt from all
 of the constituent object files.
 In such cases, you can use the
 <TT
CLASS="FUNCTION"
>Precious</TT
> method to prevent
 <TT
CLASS="APPLICATION"
>SCons</TT
> from removing the target before it is built:

 </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    env = Environment()
    lib = env.Library('foo', ['f1.c', 'f2.c', 'f3.c'])
    env.Precious(lib)
 </PRE
></TD
></TR
></TABLE
><P
>&#13; Although the output doesn't look any different,
 <TT
CLASS="APPLICATION"
>SCons</TT
> does not, in fact,
 delete the target library before rebuilding it:

 </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f1.o&nbsp;f1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f2.o&nbsp;f2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;f3.o&nbsp;f3.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;ar&nbsp;r&nbsp;libfoo.a&nbsp;f1.o&nbsp;f2.o&nbsp;f3.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;ranlib&nbsp;libfoo.a<br>
&nbsp;</P
><P
>&#13; <TT
CLASS="APPLICATION"
>SCons</TT
> will, however, still delete files marked as <TT
CLASS="FUNCTION"
>Precious</TT
>
 when the <TT
CLASS="LITERAL"
>-c</TT
> option is used.

 </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-HIERARCHICAL"
></A
>Hierarchical Builds</H1
><P
>&#13;  The source code for large software projects
  rarely stays in a single directory,
  but is nearly always divided into a
  hierarchy of directories.
  Organizing a large software build using <TT
CLASS="APPLICATION"
>SCons</TT
>
  involves creating a hierarchy of build scripts
  using the <TT
CLASS="FILENAME"
>SConscript</TT
> function.

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN808"
></A
><TT
CLASS="FILENAME"
>SConscript</TT
> Files</H1
><P
>&#13;    As we've already seen,
    the build script at the top of the tree is called <TT
CLASS="FILENAME"
>SConstruct</TT
>.
    The top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> file can
    use the <TT
CLASS="FILENAME"
>SConscript</TT
> function to
    include other subsidiary scripts in the build.
    These subsidiary scripts can, in turn,
    use the <TT
CLASS="FILENAME"
>SConscript</TT
> function
    to include still other scripts in the build.
    By convention, these subsidiary scripts are usually
    named <TT
CLASS="FILENAME"
>SConscript</TT
>.
    For example, a top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> file might
    arrange for four subsidiary scripts to be included
    in the build as follows:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      SConscript(['drivers/display/SConscript',
                  'drivers/mouse/SConscript',
                  'parser/SConscript',
                  'utilities/SConscript'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    In this case, the <TT
CLASS="FILENAME"
>SConstruct</TT
> file
    lists all of the <TT
CLASS="FILENAME"
>SConscript</TT
> files in the build explicitly.
    (Note, however, that not every directory in the tree
    necessarily has an <TT
CLASS="FILENAME"
>SConscript</TT
> file.)
    Alternatively, the <TT
CLASS="LITERAL"
>drivers</TT
>
    subdirectory might contain an intermediate
    <TT
CLASS="FILENAME"
>SConscript</TT
> file,
    in which case the <TT
CLASS="FILENAME"
>SConscript</TT
> call in
    the top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> file
    would look like:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      SConscript(['drivers/SConscript',
                  'parser/SConscript',
                  'utilities/SConscript'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    And the subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> file in the
    <TT
CLASS="LITERAL"
>drivers</TT
> subdirectory
    would look like:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      SConscript(['display/SConscript',
                  'mouse/SConscript'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Whether you list all of the <TT
CLASS="FILENAME"
>SConscript</TT
> files in the
    top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> file,
    or place a subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> file in
    intervening directories,
    or use some mix of the two schemes,
    is up to you and the needs of your software.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN836"
></A
>Path Names Are Relative to the <TT
CLASS="FILENAME"
>SConscript</TT
> Directory</H1
><P
>&#13;    Subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> files make it easy to create a build
    hierarchy because all of the file and directory names
    in a subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> files are interpreted
    relative to the directory in which the <TT
CLASS="FILENAME"
>SConscript</TT
> file lives.
    Typically, this allows the <TT
CLASS="FILENAME"
>SConscript</TT
> file containing the
    instructions to build a target file
    to live in the same directory as the source files
    from which the target will be built,
    making it easy to update how the software is built
    whenever files are added or deleted
    (or other changes are made).

    </P
><P
>&#13;    For example, suppose we want to build two programs
    <TT
CLASS="FILENAME"
>prog1</TT
> and <TT
CLASS="FILENAME"
>prog2</TT
> in two separate directories
    with the same names as the programs.
    One typical way to do this would be
    with a top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> file like this:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      SConscript(['prog1/SConscript',
                  'prog2/SConscript'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    And subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> files that look like this:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment()
      env.Program('prog1', ['main.c', 'foo1.c', 'foo2.c'])
      </PRE
></TD
></TR
></TABLE
><P
>&#13;    And this:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment()
      env.Program('prog2', ['main.c', 'bar1.c', 'bar2.c'])
      </PRE
></TD
></TR
></TABLE
><P
>&#13;    Then, when we run <TT
CLASS="APPLICATION"
>SCons</TT
> in the top-level directory,
    our build looks like:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog1/foo1.o&nbsp;prog1/foo1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog1/foo2.o&nbsp;prog1/foo2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog1/main.o&nbsp;prog1/main.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog1/prog1&nbsp;prog1/main.o&nbsp;prog1/foo1.o&nbsp;prog1/foo2.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog2/bar1.o&nbsp;prog2/bar1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog2/bar2.o&nbsp;prog2/bar2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;prog2/main.o&nbsp;prog2/main.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;prog2/prog2&nbsp;prog2/main.o&nbsp;prog2/bar1.o&nbsp;prog2/bar2.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Notice the following:

    First, you can have files with the same names
    in multiple directories, like main.c in the above example.

    Second, unlike standard recursive use of <TT
CLASS="APPLICATION"
>Make</TT
>,
    <TT
CLASS="APPLICATION"
>SCons</TT
> stays in the top-level directory
    (where the <TT
CLASS="FILENAME"
>SConstruct</TT
> file lives)
    and issues commands that use the path names
    from the top-level directory to the
    target and source files within the hierarchy.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN862"
></A
>Top-Level Path Names in Subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> Files</H1
><P
>&#13;    If you need to use a file from another directory,
    it's sometimes more convenient to specify
    the path to a file in another directory
    from the top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> directory,
    even when you're using that file in
    a subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> file in a subdirectory.
    You can tell <TT
CLASS="APPLICATION"
>SCons</TT
> to interpret a path name
    as relative to the top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> directory,
    not the local directory of the <TT
CLASS="FILENAME"
>SConscript</TT
> file,
    by appending a <TT
CLASS="LITERAL"
>#</TT
> (hash mark)
    to the beginning of the path name:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       env.Program('prog', ['main.c', '#lib/foo1.c', 'foo2.c'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    In this example,
    the <TT
CLASS="LITERAL"
>lib</TT
> directory is
    directly underneath the top-level <TT
CLASS="FILENAME"
>SConstruct</TT
> directory.
    If the above <TT
CLASS="FILENAME"
>SConscript</TT
> file is in a subdirectory
    named <TT
CLASS="LITERAL"
>src/prog</TT
>,
    the output would look like:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;lib/foo1.o&nbsp;lib/foo1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;src/prog/foo2.o&nbsp;src/prog/foo2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;src/prog/main.o&nbsp;src/prog/main.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;src/prog/prog&nbsp;src/prog/main.o&nbsp;lib/foo1.o&nbsp;src/prog/foo2.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    (Notice that the <TT
CLASS="LITERAL"
>lib/foo1.o</TT
> object file
    is built in the same directory as its source file.
    See section XXX, below,
    for information about 
    how to build the object file in a different subdirectory.)

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN882"
></A
>Absolute Path Names</H1
><P
>&#13;    Of course, you can always specify
    an absolute path name for a file--for example:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       env.Program('prog', ['main.c', '/usr/joe/lib/foo1.c', 'foo2.c'])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Which, when executed, would yield:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;src/prog/foo2.o&nbsp;src/prog/foo2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;src/prog/main.o&nbsp;src/prog/main.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;/usr/joe/lib/foo1.o&nbsp;/usr/joe/lib/foo1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;src/prog/prog&nbsp;src/prog/main.o&nbsp;/usr/joe/lib/foo1.o&nbsp;src/prog/foo2.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    (As was the case with top-relative path names,
    notice that the <TT
CLASS="LITERAL"
>/usr/joe/lib/foo1.o</TT
> object file
    is built in the same directory as its source file.
    See section XXX, below,
    for information about 
    how to build the object file in a different subdirectory.)

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN891"
></A
>Sharing Environments (and Other Variables) Between <TT
CLASS="FILENAME"
>SConscript</TT
> Files</H1
><P
>&#13;    In the previous example,
    each of the subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> files
    created its own construction environment
    by calling <TT
CLASS="FUNCTION"
>Environment</TT
> separately.
    This obviously works fine,
    but if each program must be built
    with the same construction variables,
    it's cumbersome and error-prone to initialize
    separate construction environments
    in the same way over and over in each subsidiary
    <TT
CLASS="FILENAME"
>SConscript</TT
> file.

    </P
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> supports the ability to <I
CLASS="EMPHASIS"
>export</I
> variables
    from a parent <TT
CLASS="FILENAME"
>SConscript</TT
> file
    to its subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> files,
    which allows you to share common initialized
    values throughout your build hierarchy.

    </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN903"
></A
>Exporting Variables</H2
><P
>&#13;      There are two ways to export a variable,
      such as a construction environment,
      from an <TT
CLASS="FILENAME"
>SConscript</TT
> file,
      so that it may be used by other <TT
CLASS="FILENAME"
>SConscript</TT
> files.
      First, you can call the <TT
CLASS="FUNCTION"
>Export</TT
>
      function with a list of variables,
      or a string white-space separated variable names.
      Each call to <TT
CLASS="FUNCTION"
>Export</TT
> adds one
      or more variables to a global list
      of variables that are available for import
      by other <TT
CLASS="FILENAME"
>SConscript</TT
> files.

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        env = Environment()
        Export('env')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      You may export more than one variable name at a time:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        env = Environment()
        debug = ARGUMENTS['debug']
        Export('env', 'debug')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Because white space is not legal in Python variable names,
      the <TT
CLASS="FUNCTION"
>Export</TT
> function will even automatically split
      a string into separate names for you:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Export('env debug')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Second, you can specify a list of
      variables to export as a second argument
      to the <TT
CLASS="FILENAME"
>SConscript</TT
> function call:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        SConscript('src/SConscript', 'env')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Or as the <TT
CLASS="VARNAME"
>exports</TT
> keyword argument:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        SConscript('src/SConscript', exports='env')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      These calls export the specified variables
      to only the listed <TT
CLASS="FILENAME"
>SConscript</TT
> files.
      You may, however, specify more than one
      <TT
CLASS="FILENAME"
>SConscript</TT
> file in a list:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        SConscript(['src1/SConscript',
                    'src2/SConscript'], exports='env')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      This is functionally equivalent to
      calling the <TT
CLASS="FILENAME"
>SConscript</TT
> function
      multiple times with the same <TT
CLASS="VARNAME"
>exports</TT
> argument,
      one per <TT
CLASS="FILENAME"
>SConscript</TT
> file.

      </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN931"
></A
>Importing Variables</H2
><P
>&#13;      Once a variable has been exported from a calling
      <TT
CLASS="FILENAME"
>SConscript</TT
> file,
      it may be used in other <TT
CLASS="FILENAME"
>SConscript</TT
> files
      by calling the <TT
CLASS="FUNCTION"
>Import</TT
> function:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Import('env')
        env.Program('prog', ['prog.c'])
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      The <TT
CLASS="FUNCTION"
>Import</TT
> call makes the <TT
CLASS="LITERAL"
>env</TT
> construction
      environment available to the <TT
CLASS="FILENAME"
>SConscript</TT
> file,
      after which the variable can be used to build
      programs, libraries, etc.

      </P
><P
>&#13;      Like the <TT
CLASS="FUNCTION"
>Export</TT
> function,
      the <TT
CLASS="FUNCTION"
>Import</TT
> function can be used
      with multiple variable names:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Import('env', 'debug')
        env = env.Copy(DEBUG = debug)
        env.Program('prog', ['prog.c'])
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      And the <TT
CLASS="FUNCTION"
>Import</TT
> function will similarly
      split a string along white-space
      into separate variable names:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Import('env debug')
        env = env.Copy(DEBUG = debug)
        env.Program('prog', ['prog.c'])
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      Lastly, as a special case,
      you may import all of the variables that
      have been exported by supplying an asterisk
      to the <TT
CLASS="FUNCTION"
>Import</TT
> function:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        Import('*')
        env = env.Copy(DEBUG = debug)
        env.Program('prog', ['prog.c'])
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      If you're dealing with a lot of <TT
CLASS="FILENAME"
>SConscript</TT
> files,
      this can be a lot simpler than keeping
      arbitrary lists of imported variables in each file.

      </P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="AEN954"
></A
>Returning Values From an <TT
CLASS="FILENAME"
>SConscript</TT
> File</H2
><P
>&#13;      Sometimes, you would like to be able to
      use information from a subsidiary
      <TT
CLASS="FILENAME"
>SConscript</TT
> file in some way.
      For example,
      suppose that you want to create one
      library from source files
      scattered throughout a number
      of subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> files.
      You can do this by using the <TT
CLASS="FUNCTION"
>Return</TT
>
      function to return values
      from the subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> files
      to the calling file.

      </P
><P
>&#13;      If, for example, we have two subdirectories
      <TT
CLASS="APPLICATION"
>foo</TT
> and <TT
CLASS="APPLICATION"
>bar</TT
>
      that should each contribute a source
      file to a Library,
      what we'd like to be able to do is
      collect the object files
      from the subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> calls
      like this:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>          env = Environment()
          Export('env')
          objs = []
          for subdir in ['foo', 'bar']:
              o = SConscript('%s/SConscript' % subdir)
              objs.append(o)
          env.Library('prog', objs)
      </PRE
></TD
></TR
></TABLE
><P
>&#13;      We can do this by using the <TT
CLASS="FUNCTION"
>Return</TT
>
      function in the
      <TT
CLASS="LITERAL"
>foo/SConscript</TT
> file like this:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>          Import('env')
          obj = env.Object('foo.c')
          Return('obj')
        </PRE
></TD
></TR
></TABLE
><P
>&#13;      (The corresponding
      <TT
CLASS="LITERAL"
>bar/SConscript</TT
>
      file should be pretty obvious.)
      Then when we run <TT
CLASS="APPLICATION"
>SCons</TT
>,
      the object files from the subsidiary subdirectories
      are all correctly archived in the desired library:

      </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;bar/bar.o&nbsp;bar/bar.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;foo/foo.o&nbsp;foo/foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ar&nbsp;r&nbsp;libprog.a&nbsp;foo/foo.o&nbsp;bar/bar.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ranlib&nbsp;libprog.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-SEPARATE"
></A
>Separating Source and Build Directories</H1
><P
>&#13;  It's often useful to keep any built files completely
  separate from the source files.
  This is usually done by creating one or more separate
  <I
CLASS="EMPHASIS"
>build directories</I
>
  that are used to hold the built objects files, libraries,
  and executable programs, etc.
  for a specific flavor of build.
  <TT
CLASS="APPLICATION"
>SCons</TT
> provides two ways to do this,
  one through the <TT
CLASS="FILENAME"
>SConscript</TT
> function that we've already seen,
  and the second through a more flexible <TT
CLASS="FUNCTION"
>BuildDir</TT
> function.

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN983"
></A
>Specifying a Build Directory as Part of an <TT
CLASS="FILENAME"
>SConscript</TT
> Call</H1
><P
>&#13;    The most straightforward way to establish a build directory
    uses the fact that the usual way to
    set up a build hierarchy is to have an
    <TT
CLASS="FILENAME"
>SConscript</TT
> file in the source subdirectory.
    If you then pass a <TT
CLASS="VARNAME"
>build_dir</TT
> argument to the
    <TT
CLASS="FILENAME"
>SConscript</TT
> function call:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      SConscript('src/SConscript', build_dir='build')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> will then build all of the files in
    the <TT
CLASS="FILENAME"
>build</TT
> subdirectory:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls src</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SConscript&nbsp;&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;build/hello.o&nbsp;build/hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;build/hello&nbsp;build/hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls build</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SConscript&nbsp;&nbsp;hello&nbsp;&nbsp;hello.c&nbsp;&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    But wait a minute--what's going on here?
    <TT
CLASS="APPLICATION"
>SCons</TT
> created the object file
    <TT
CLASS="FILENAME"
>build/hello.o</TT
>
    in the <TT
CLASS="FILENAME"
>build</TT
> subdirectory,
    as expected.
    But even though our <TT
CLASS="FILENAME"
>hello.c</TT
> file lives in the <TT
CLASS="FILENAME"
>src</TT
> subdirectory,
    <TT
CLASS="APPLICATION"
>SCons</TT
> has actually compiled a
    <TT
CLASS="FILENAME"
>build/hello.c</TT
> file
    to create the object file.

    </P
><P
>&#13;    What's happened is that <TT
CLASS="APPLICATION"
>SCons</TT
> has <I
CLASS="EMPHASIS"
>duplicated</I
>
    the <TT
CLASS="FILENAME"
>hello.c</TT
> file from the <TT
CLASS="FILENAME"
>src</TT
> subdirectory
    to the <TT
CLASS="FILENAME"
>build</TT
> subdirectory,
    and built the program from there.
    The next section explains why <TT
CLASS="APPLICATION"
>SCons</TT
> does this.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1013"
></A
>Why <TT
CLASS="APPLICATION"
>SCons</TT
> Duplicates Source Files in a Build Directory</H1
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> duplicates source files in build directories
    because it's the most straightforward way to guarantee a correct build
    <I
CLASS="EMPHASIS"
>regardless of include-file directory paths,
    relative references between files,
    or tool support for putting files in different locations</I
>,
    and the <TT
CLASS="APPLICATION"
>SCons</TT
> philosophy is to, by default,
    guarantee a correct build in all cases.

    </P
><P
>&#13;    The most direct reason to duplicate source files
    in build directories
    is simply that some tools (mostly older vesions)
    are written to only build their output files
    in the same directory as the source files.
    In this case, the choices are either
    to build the output file in the source directory
    and move it to the build directory,
    or to duplicate the source files in the build directory.

    </P
><P
>&#13;    Additionally,
    relative references between files
    can cause problems if we don't
    just duplicate the hierarchy of source files
    in the build directory.
    You can see this at work in
    use of the C preprocessor <TT
CLASS="LITERAL"
>#include</TT
>
    mechanism with double quotes, not angle brackets:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      #include "file.h"
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    The <I
CLASS="EMPHASIS"
>de facto</I
> standard behavior
    for most C compilers in this case
    is to first look in the same directory
    as the source file that contains the <TT
CLASS="LITERAL"
>#include</TT
> line,
    then to look in the directories in the preprocessor search path.
    Add to this that the <TT
CLASS="APPLICATION"
>SCons</TT
> implementation of
    support for code repositories
    (described below)
    means not all of the files
    will be found in the same directory hierarchy,
    and the simplest way to make sure
    that the right include file is found
    is to duplicate the source files into the build directory,
    which provides a correct build
    regardless of the original location(s) of the source files.

    </P
><P
>&#13;    Although source-file duplication guarantees a correct build
    even in these end-cases,
    it <I
CLASS="EMPHASIS"
>can</I
> usually be safely disabled.
    The next section describes
    how you can disable the duplication of source files
    in the build directory.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1030"
></A
>Telling <TT
CLASS="APPLICATION"
>SCons</TT
> to Not Duplicate Source Files in the Build Directory</H1
><P
>&#13;    In most cases and with most tool sets,
    <TT
CLASS="APPLICATION"
>SCons</TT
> can place its target files in a build subdirectory
    <I
CLASS="EMPHASIS"
>without</I
>
    duplicating the source files
    and everything will work just fine.
    You can disable the default <TT
CLASS="APPLICATION"
>SCons</TT
> behavior
    by specifying <TT
CLASS="LITERAL"
>duplicate=0</TT
>
    when you call the <TT
CLASS="FILENAME"
>SConscript</TT
> function:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      SConscript('src/SConscript', build_dir='build', duplicate=0)
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    When this flag is specified,
    <TT
CLASS="APPLICATION"
>SCons</TT
> uses the build directory
    like most people expect--that is,
    the output files are placed in the build directory
    while the source files stay in the source directory:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls src</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SConscript<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;src/hello.c&nbsp;-o&nbsp;build/hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;build/hello&nbsp;build/hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls build</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1046"
></A
>The <TT
CLASS="FUNCTION"
>BuildDir</TT
> Function</H1
><P
>&#13;    Use the <TT
CLASS="FUNCTION"
>BuildDir</TT
> function to establish that target
    files should be built in a separate directory
    from the source files:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      BuildDir('build', 'src')
      env = Environment()
      env.Program('build/hello.c')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Note that when you're not using
    an <TT
CLASS="FILENAME"
>SConscript</TT
> file in the <TT
CLASS="FILENAME"
>src</TT
> subdirectory,
    you must actually specify that
    the program must be built from
    the <TT
CLASS="FILENAME"
>build/hello.c</TT
>
    file that <TT
CLASS="APPLICATION"
>SCons</TT
> will duplicate in the
    <TT
CLASS="FILENAME"
>build</TT
> subdirectory.

    </P
><P
>&#13;    When using the <TT
CLASS="FUNCTION"
>BuildDir</TT
> function directly,
    <TT
CLASS="APPLICATION"
>SCons</TT
> still duplicates the source files
    in the build directory by default:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls src</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;build/hello.o&nbsp;build/hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;build/hello&nbsp;build/hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls build</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;&nbsp;hello.c&nbsp;&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    You can specify the same <TT
CLASS="LITERAL"
>duplicate=0</TT
> argument
    that you can specify for an <TT
CLASS="FILENAME"
>SConscript</TT
> call:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      BuildDir('build', 'src', duplicate=0)
      env = Environment()
      env.Program('build/hello.c')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    In which case <TT
CLASS="APPLICATION"
>SCons</TT
>
    will disable duplication of the source files:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls src</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;build/hello.o&nbsp;src/hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;build/hello&nbsp;build/hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls build</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1075"
></A
>Using <TT
CLASS="FUNCTION"
>BuildDir</TT
> With an <TT
CLASS="FILENAME"
>SConscript</TT
> File</H1
><P
>&#13;    Even when using the <TT
CLASS="FUNCTION"
>BuildDir</TT
> function,
    it's much more natural to use it with
    a subsidiary <TT
CLASS="FILENAME"
>SConscript</TT
> file.
    For example, if the
    <TT
CLASS="FILENAME"
>src/SConscript</TT
>
    looks like this:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      env = Environment()
      env.Program('hello.c')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Then our <TT
CLASS="FILENAME"
>SConstruct</TT
> file could look like:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      BuildDir('build', 'src')
      SConscript('build/SConscript')
      </PRE
></TD
></TR
></TABLE
><P
>&#13;    Yielding the following output:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls src</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SConscript&nbsp;&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;build/hello.o&nbsp;build/hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;build/hello&nbsp;build/hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>ls build</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SConscript&nbsp;&nbsp;hello&nbsp;&nbsp;hello.c&nbsp;&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Notice that this is completely equivalent
    to the use of <TT
CLASS="FILENAME"
>SConscript</TT
> that we
    learned about in the previous section.

    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-VARIANTS"
></A
>Variant Builds</H1
><P
>&#13;  The <TT
CLASS="FUNCTION"
>BuildDir</TT
> function now gives us everything
  we need to show how easy it is to create
  variant builds using <TT
CLASS="APPLICATION"
>SCons</TT
>.
  Suppose, for example, that we want to
  build a program for both Windows and Linux platforms,
  but that we want to build it in a shared directory
  with separate side-by-side build directories
  for the Windows and Linux versions of the program.

  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    platform = ARGUMENTS.get('OS', Platform())

    include = "#export/$PLATFORM/include"
    lib = "#export/$PLATFORM/lib"
    bin = "#export/$PLATFORM/bin"

    env = Environment(PLATFORM = platform,
                      BINDIR = bin,
                      INCDIR = include,
                      LIBDIR = lib,
                      CPPPATH = [include],
                      LIBPATH = [lib],
                      LIBS = 'world')

    Export('env')

    env.SConscript('src/SConscript', build_dir='build/$PLATFORM')

    #
    #BuildDir("#build/$PLATFORM", 'src')
    #SConscript("build/$PLATFORM/hello/SConscript")
    #SConscript("build/$PLATFORM/world/SConscript")
  </PRE
></TD
></TR
></TABLE
><P
>&#13;  This SConstruct file,
  when run on a Linux system, yields:

  </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q OS=linux</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"build/linux/world/world.h"&nbsp;as&nbsp;"export/linux/include/world.h"<br>
&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-Iexport/linux/include&nbsp;-c&nbsp;-o&nbsp;build/linux/hello/hello.o&nbsp;build/linux/hello/hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-Iexport/linux/include&nbsp;-c&nbsp;-o&nbsp;build/linux/world/world.o&nbsp;build/linux/world/world.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;ar&nbsp;r&nbsp;build/linux/world/libworld.a&nbsp;build/linux/world/world.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;ranlib&nbsp;build/linux/world/libworld.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"build/linux/world/libworld.a"&nbsp;as&nbsp;"export/linux/lib/libworld.a"<br>
&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;build/linux/hello/hello&nbsp;build/linux/hello/hello.o&nbsp;-Lexport/linux/lib&nbsp;-lworld<br>
&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"build/linux/hello/hello"&nbsp;as&nbsp;"export/linux/bin/hello"<br>
&nbsp;&nbsp;</P
><P
>&#13;  The same SConstruct file on Windows would build:

  </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;C:\&#62;<TT
CLASS="USERINPUT"
><B
>scons -Q OS=windows</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"build/windows/world/world.h"&nbsp;as&nbsp;"export/windows/include/world.h"<br>
&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/Iexport\windows\include&nbsp;/c&nbsp;build\windows\hello\hello.c&nbsp;/Fobuild\windows\hello\hello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;/nologo&nbsp;/Iexport\windows\include&nbsp;/c&nbsp;build\windows\world\world.c&nbsp;/Fobuild\windows\world\world.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;lib&nbsp;/nologo&nbsp;/OUT:build\windows\world\world.lib&nbsp;build\windows\world\world.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"build/windows/world/world.lib"&nbsp;as&nbsp;"export/windows/lib/world.lib"<br>
&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;/nologo&nbsp;/OUT:build\windows\hello\hello.exe&nbsp;/LIBPATH:export\windows\lib&nbsp;world.lib&nbsp;build\windows\hello\hello.obj<br>
&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"build/windows/hello/hello.exe"&nbsp;as&nbsp;"export/windows/bin/hello.exe"<br>
&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-BUILDERS-WRITING"
></A
>Writing Your Own Builders</H1
><P
>&#13;  Although <TT
CLASS="APPLICATION"
>SCons</TT
> provides many useful methods
  for building common software products:
  programs, libraries, documents.
  you frequently want to be
  able to build some other type of file
  not supported directly by <TT
CLASS="APPLICATION"
>SCons</TT
>
  Fortunately, <TT
CLASS="APPLICATION"
>SCons</TT
> makes it very easy
  to define your own <TT
CLASS="CLASSNAME"
>Builder</TT
> objects
  for any custom file types you want to build.
  (In fact, the <TT
CLASS="APPLICATION"
>SCons</TT
> interfaces for creating
  <TT
CLASS="CLASSNAME"
>Builder</TT
> objects are flexible enough and easy enough to use
  that all of the the <TT
CLASS="APPLICATION"
>SCons</TT
> built-in <TT
CLASS="CLASSNAME"
>Builder</TT
> objects
  are created the mechanisms described in this section.)

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1117"
></A
>Writing Builders That Execute External Commands</H1
><P
>&#13;    The simplest <TT
CLASS="CLASSNAME"
>Builder</TT
> to create is
    one that executes an external command.
    For example, if we want to build
    an output file by running the contents
    of the input file through a command named
    <TT
CLASS="LITERAL"
>foobuild</TT
>,
    creating that <TT
CLASS="CLASSNAME"
>Builder</TT
> might look like:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       bld = Builder(action = 'foobuild &#60; $SOURCE &#62; $TARGET')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    All the above line does is create a free-standing
    <TT
CLASS="CLASSNAME"
>Builder</TT
> object.
    The next section will show us how to actually use it.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1126"
></A
>Attaching a Builder to a <TT
CLASS="LITERAL"
>Construction Environment</TT
></H1
><P
>&#13;    A <TT
CLASS="CLASSNAME"
>Builder</TT
> object isn't useful
    until it's attached to a <TT
CLASS="LITERAL"
>construction environment</TT
>
    so that we can call it to arrange
    for files to be built.
    This is done through the <TT
CLASS="VARNAME"
>BUILDERS</TT
>
    <TT
CLASS="LITERAL"
>construction variable</TT
> in an environment.
    The <TT
CLASS="VARNAME"
>BUILDERS</TT
> variable is a Python dictionary
    that maps the names by which you want to call
    various <TT
CLASS="CLASSNAME"
>Builder</TT
> objects to the objects themselves.
    For example, if we want to call the
    <TT
CLASS="CLASSNAME"
>Builder</TT
> we just defined by the name
    <TT
CLASS="FUNCTION"
>Foo</TT
>,
    our <TT
CLASS="FILENAME"
>SConstruct</TT
> file might look like:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       bld = Builder(action = 'foobuild &#60; $SOURCE &#62; $TARGET')
       env = Environment(BUILDERS = {'Foo' : bld})
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    With the <TT
CLASS="CLASSNAME"
>Builder</TT
> so attached to our <TT
CLASS="LITERAL"
>construction environment</TT
>
    we can now actually call it like so:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env.Foo('file.foo', 'file.input')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Then when we run <TT
CLASS="APPLICATION"
>SCons</TT
> it looks like:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foobuild&nbsp;&#60;&nbsp;file.input&nbsp;&#62;&nbsp;file.foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Note, however, that the default <TT
CLASS="VARNAME"
>BUILDERS</TT
>
    variable in a <TT
CLASS="LITERAL"
>construction environment</TT
>
    comes with a default set of <TT
CLASS="CLASSNAME"
>Builder</TT
> objects
    already defined:
    <TT
CLASS="FUNCTION"
>Program</TT
>, <TT
CLASS="FUNCTION"
>Library</TT
>, etc.
    And when we explicitly set the <TT
CLASS="VARNAME"
>BUILDERS</TT
> variable
    when we create the <TT
CLASS="LITERAL"
>construction environment</TT
>,
    the default <TT
CLASS="CLASSNAME"
>Builder</TT
>s are no longer part of
    the environment:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       bld = Builder(action = 'foobuild &#60; $SOURCE &#62; $TARGET')
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file.foo', 'file.input')
       env.Program('hello.c')
    </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AttributeError:&nbsp;SConsEnvironment&nbsp;instance&nbsp;has&nbsp;no&nbsp;attribute&nbsp;'Program':<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    To be able use both our own defined <TT
CLASS="CLASSNAME"
>Builder</TT
> objects
    and the default <TT
CLASS="CLASSNAME"
>Builder</TT
> objects in the same <TT
CLASS="LITERAL"
>construction environment</TT
>,
    you can either add to the <TT
CLASS="VARNAME"
>BUILDERS</TT
> variable
    using the <TT
CLASS="FUNCTION"
>Append</TT
> function:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       bld = Builder(action = 'foobuild &#60; $SOURCE &#62; $TARGET')
       env.Append(BUILDERS = {'Foo' : bld})
       env.Foo('file.foo', 'file.input')
       env.Program('hello.c')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Or you can explicitly set the appropriately-named
    key in the <TT
CLASS="VARNAME"
>BUILDERS</TT
> dictionary:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       bld = Builder(action = 'foobuild &#60; $SOURCE &#62; $TARGET')
       env['BUILDERS']['Foo'] = bld
       env.Foo('file.foo', 'file.input')
       env.Program('hello.c')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Either way, the same <TT
CLASS="LITERAL"
>construction environment</TT
>
    can then use both the newly-defined
    <TT
CLASS="FUNCTION"
>Foo</TT
> <TT
CLASS="CLASSNAME"
>Builder</TT
>
    and the default <TT
CLASS="FUNCTION"
>Program</TT
> <TT
CLASS="CLASSNAME"
>Builder</TT
>:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foobuild&nbsp;&#60;&nbsp;file.input&nbsp;&#62;&nbsp;file.foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1178"
></A
>Letting <TT
CLASS="APPLICATION"
>SCons</TT
> Handle The File Suffixes</H1
><P
>&#13;    By supplying additional information
    when you create a <TT
CLASS="CLASSNAME"
>Builder</TT
>,
    you can let <TT
CLASS="APPLICATION"
>SCons</TT
> add appropriate file
    suffixes to the target and/or the source file.
    For example, rather than having to specify
    explicitly that you want the <TT
CLASS="LITERAL"
>Foo</TT
>
    <TT
CLASS="CLASSNAME"
>Builder</TT
> to build the <TT
CLASS="LITERAL"
>file.foo</TT
>
    target file from the <TT
CLASS="LITERAL"
>file.input</TT
> source file,
    you can give the <TT
CLASS="LITERAL"
>.foo</TT
>
    and <TT
CLASS="LITERAL"
>.input</TT
> suffixes to the <TT
CLASS="CLASSNAME"
>Builder</TT
>,
    making for more compact and readable calls to
    the <TT
CLASS="LITERAL"
>Foo</TT
> <TT
CLASS="CLASSNAME"
>Builder</TT
>:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       bld = Builder(action = 'foobuild &#60; $SOURCE &#62; $TARGET',
                     suffix = '.foo',
                     src_suffix = '.input')
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file1')
       env.Foo('file2')
    </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foobuild&nbsp;&#60;&nbsp;file1.input&nbsp;&#62;&nbsp;file1.foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foobuild&nbsp;&#60;&nbsp;file2.input&nbsp;&#62;&nbsp;file2.foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    You can also supply a <TT
CLASS="LITERAL"
>prefix</TT
> keyword argument
    if it's appropriate to have <TT
CLASS="APPLICATION"
>SCons</TT
> append a prefix
    to the beginning of target file names.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1199"
></A
>Builders That Execute Python Functions</H1
><P
>&#13;    In <TT
CLASS="APPLICATION"
>SCons</TT
>, you don't have to call an external command
    to build a file.
    You can, instead, define a Python function
    that a <TT
CLASS="CLASSNAME"
>Builder</TT
> object can invoke
    to build your target file (or files).
    Such a <TT
CLASS="LITERAL"
>builder function</TT
> definition looks like:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       def build_function(target, source, env):
           # Code to build "target" from "source"
           return None
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    The arguments of a <TT
CLASS="LITERAL"
>builder function</TT
> are:

    </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>target</DT
><DD
><P
>&#13;      A list of Node objects representing
      the target or targets to be
      built by this builder function.
      The file names of these target(s)
      may be extracted using the Python <TT
CLASS="FUNCTION"
>str</TT
> funcion.

      </P
></DD
><DT
>source</DT
><DD
><P
>&#13;      A list of Node objects representing
      the sources to be
      used by this builder function to build the targets.
      The file names of these source(s)
      may be extracted using the Python <TT
CLASS="FUNCTION"
>str</TT
> funcion.

      </P
></DD
><DT
>env</DT
><DD
><P
>&#13;      The <TT
CLASS="LITERAL"
>construction environment</TT
> used for building the target(s).
      The builder function may use any of the
      environment's construction variables
      in any way to affect how it builds the targets.

      </P
></DD
></DL
></DIV
><P
>&#13;    The builder function must
    return a <TT
CLASS="LITERAL"
>0</TT
> or <TT
CLASS="LITERAL"
>None</TT
> value
    if the target(s) are built successfully.
    The builder function
    may raise an exception
    or return any non-zero value
    to indicate that the build is unsuccessful,

    </P
><P
>&#13;    Once you've defined the Python function
    that will build your target file,
    defining a <TT
CLASS="CLASSNAME"
>Builder</TT
> object for it is as
    simple as specifying the name of the function,
    instead of an external command,
    as the <TT
CLASS="CLASSNAME"
>Builder</TT
>'s
    <TT
CLASS="LITERAL"
>action</TT
>
    argument:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       def build_function(target, source, env):
           # Code to build "target" from "source"
           return None
       bld = Builder(action = build_function,
                     suffix = '.foo',
                     src_suffix = '.input')
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    And notice that the output changes slightly,
    reflecting the fact that a Python function,
    not an external command,
    is now called to build the target file:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;build_function("file.foo",&nbsp;"file.input")<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1235"
></A
>Builders That Create Actions Using a <TT
CLASS="LITERAL"
>Generator</TT
></H1
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> Builder objects can create an action "on the fly"
    by using a function called a <TT
CLASS="LITERAL"
>generator</TT
>.
    This provides a great deal of flexibility to
    construct just the right list of commands
    to build your target.
    A <TT
CLASS="LITERAL"
>generator</TT
> looks like:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       def generate_actions(source, target, env, for_signature):
           return 'foobuild &#60; %s &#62; %s' % (target[0], source[0])
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    The arguments of a <TT
CLASS="LITERAL"
>generator</TT
> are:

    </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>source</DT
><DD
><P
>&#13;      A list of Node objects representing
      the sources to be built
      by the command or other action
      generated by this function.
      The file names of these source(s)
      may be extracted using the Python <TT
CLASS="FUNCTION"
>str</TT
> funcion.

      </P
></DD
><DT
>target</DT
><DD
><P
>&#13;      A list of Node objects representing
      the target or targets to be built
      by the command or other action
      generated by this function.
      The file names of these target(s)
      may be extracted using the Python <TT
CLASS="FUNCTION"
>str</TT
> funcion.

      </P
></DD
><DT
>env</DT
><DD
><P
>&#13;      The <TT
CLASS="LITERAL"
>construction environment</TT
> used for building the target(s).
      The generator may use any of the
      environment's construction variables
      in any way to determine what command
      or other action to return.

      </P
></DD
><DT
>for_signature</DT
><DD
><P
>&#13;      A flag that specifies whether the
      generator is being called to contribute to a build signature,
      as opposed to actually executing the command.

      

      </P
></DD
></DL
></DIV
><P
>&#13;    The <TT
CLASS="LITERAL"
>generator</TT
> must return a
    command string or other action that will be used to
    build the specified target(s) from the specified source(s).

    </P
><P
>&#13;    Once you've defined a <TT
CLASS="LITERAL"
>generator</TT
>,
    you create a <TT
CLASS="CLASSNAME"
>Builder</TT
> to use it
    by specifying the generator keyword argument
    instead of <TT
CLASS="LITERAL"
>action</TT
>.

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       def generate_actions(source, target, env, for_signature):
           return 'foobuild &#60; %s &#62; %s' % (source[0], target[0])
       bld = Builder(generator = generate_actions,
                     suffix = '.foo',
                     src_suffix = '.input')
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file')
    </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foobuild&nbsp;&#60;&nbsp;file.input&nbsp;&#62;&nbsp;file.foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Note that it's illegal to specify both an
    <TT
CLASS="LITERAL"
>action</TT
>
    and a
    <TT
CLASS="LITERAL"
>generator</TT
>
    for a <TT
CLASS="CLASSNAME"
>Builder</TT
>.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1278"
></A
>Builders That Modify the Target or Source Lists Using an <TT
CLASS="LITERAL"
>Emitter</TT
></H1
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> supports the ability for a Builder to modify the
    lists of target(s) from the specified source(s).

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       def modify_targets(target, source, env):
           target.append('new_target')
           source.append('new_source')
           return target, source
       bld = Builder(action = 'foobuild $TARGETS - $SOURCES',
                     suffix = '.foo',
                     src_suffix = '.input',
                     emitter = modify_targets)
       env = Environment(BUILDERS = {'Foo' : bld})
       env.Foo('file')
    </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foobuild&nbsp;file.foo&nbsp;new_target&nbsp;-&nbsp;file.input&nbsp;new_source<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       bld = Builder(action = 'XXX',
                     suffix = '.foo',
                     src_suffix = '.input',
                     emitter = 'MY_EMITTER')
       def modify1(target, source, env):
           return target, source
       def modify2(target, source, env):
           return target, source
       env1 = Environment(BUILDERS = {'Foo' : bld},
                          MY_EMITTER = modify1)
       env2 = Environment(BUILDERS = {'Foo' : bld},
                          MY_EMITTER = modify2)
       env1.Foo('file1')
       env2.Foo('file2')
    </PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-BUILDERS-COMMANDS"
></A
>Not Writing a Builder:  The <TT
CLASS="FUNCTION"
>Command</TT
> Builder</H1
><P
>&#13;  Creating a <TT
CLASS="CLASSNAME"
>Builder</TT
> and attaching it to a <TT
CLASS="LITERAL"
>construction environment</TT
>
  allows for a lot of flexibility when you
  want to re-use actions
  to build multiple files of the same type.
  This can, however, be cumbersome
  if you only need to execute one specific command
  to build a single file (or group of files).
  For these situations, <TT
CLASS="APPLICATION"
>SCons</TT
> supports a
  <TT
CLASS="FUNCTION"
>Command</TT
> <TT
CLASS="CLASSNAME"
>Builder</TT
> that arranges
  for a specific action to be executed
  to build a specific file or files.
  This looks a lot like the other builders
  (like <TT
CLASS="FUNCTION"
>Program</TT
>, <TT
CLASS="FUNCTION"
>Object</TT
>, etc.),
  but takes as an additional argument
  the command to be executed to build the file:

  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     env = Environment()
     env.Command('foo.out', 'foo.in', "sed 's/x/y/' &#60; $SOURCE &#62; $TARGET")
  </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;sed&nbsp;'s/x/y/'&nbsp;&#60;&nbsp;foo.in&nbsp;&#62;&nbsp;foo.out<br>
&nbsp;&nbsp;</P
><P
>&#13;  This is often more convenient than
  creating a <TT
CLASS="CLASSNAME"
>Builder</TT
> object
  and adding it to the <TT
CLASS="VARNAME"
>BUILDERS</TT
> variable
  of a <TT
CLASS="LITERAL"
>construction environment</TT
>

  </P
><P
>&#13;  Note that the action you 

  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     env = Environment()
     def build(target, source, env):
         # Whatever it takes to build
         return None
     env.Command('foo.out', 'foo.in', build)
  </PRE
></TD
></TR
></TABLE
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;build("foo.out",&nbsp;"foo.in")<br>
&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-SCANNERS"
></A
>Writing Scanners</H1
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> has built-in scanners that know how to look in
    C, Fortran and IDL source files for information about
    other files that targets built from those files depend on--for example,
    in the case of files that use the C preprocessor,
    the <TT
CLASS="FILENAME"
>.h</TT
> files that are specified
    using <TT
CLASS="LITERAL"
>#include</TT
> lines in the source.
    You can use the same mechanisms that <TT
CLASS="APPLICATION"
>SCons</TT
> uses to create
    its built-in scanners to write scanners of your own for file types
    that <TT
CLASS="APPLICATION"
>SCons</TT
> does not know how to scan "out of the box."

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1317"
></A
>A Simple Scanner Example</H1
><P
>&#13;      Suppose, for example, that we want to create a simple scanner
      for <TT
CLASS="FILENAME"
>.foo</TT
> files.
      A <TT
CLASS="FILENAME"
>.foo</TT
> file contains some text that
      will be processed,
      and can include other files on lines that begin
      with <TT
CLASS="LITERAL"
>include</TT
>
      followed by a file name:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      include filename.foo
    </PRE
></TD
></TR
></TABLE
><P
>&#13;      Scanning a file will be handled by a Python function
      that you must supply.
      Here is a function that will use the Python
      <TT
CLASS="FILENAME"
>re</TT
> module
      to scan for the <TT
CLASS="LITERAL"
>include</TT
> lines in our example:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>      import re
      
      include_re = re.compile(r'^include\\s+(\\S+)$', re.M)
      
      def kfile_scan(node, env, path, arg):
          contents = node.get_contents()
          return include_re.findall(contents)
    </PRE
></TD
></TR
></TABLE
><P
>&#13;      The scanner function must
      accept the four specified arguments
      and return a list of implicit dependencies.
      Presumably, these would be dependencies found
      from examining the contents of the file,
      although the function can perform any
      manipulation at all to generate the list of
      dependencies.

    </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>node</DT
><DD
><P
>&#13;      An <TT
CLASS="APPLICATION"
>SCons</TT
> node object representing the file being scanned.
      The path name to the file can be
      used by converting the node to a string
      using the <TT
CLASS="LITERAL"
>str()</TT
> function,
      or an internal <TT
CLASS="APPLICATION"
>SCons</TT
> <TT
CLASS="LITERAL"
>get_contents()</TT
>
      object method can be used to fetch the contents.

      </P
></DD
><DT
>env</DT
><DD
><P
>&#13;      The construction environment in effect for this scan.
      The scanner function may choose to use construction
      variables from this environment to affect its behavior.

      </P
></DD
><DT
>path</DT
><DD
><P
>&#13;      A list of directories that form the search path for included files
      for this scanner.
      This is how <TT
CLASS="APPLICATION"
>SCons</TT
> handles the <TT
CLASS="LITERAL"
>CPPPATH</TT
> and <TT
CLASS="VARNAME"
>LIBPATH</TT
>
      variables.

      </P
></DD
><DT
>arg</DT
><DD
><P
>&#13;      An optional argument that you can choose to
      have passed to this scanner function by
      various scanner instances.

      </P
></DD
></DL
></DIV
><P
>&#13;    A Scanner object is created using the <TT
CLASS="CLASSNAME"
>Scanner</TT
> function,
    which typically takes an <TT
CLASS="LITERAL"
>skeys</TT
> argument
    to associate the type of file suffix with this scanner.
    The Scanner object must then be associated with the
    <TT
CLASS="VARNAME"
>SCANNERS</TT
> construction variable of a construction environment,
    typically by using the <TT
CLASS="FUNCTION"
>Append</TT
> method:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       kscan = Scanner(function = kfile_scan,
                       skeys = ['.k'])
       env.Append(SCANNERS = kscan)
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    When we put it all together, it looks like:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        import re

        include_re = re.compile(r'^include\\s+(\\S+)$', re.M)

        def kfile_scan(node, env, path):
            contents = node.get_contents()
            includes = include_re.findall(contents)
            return includes

        kscan = Scanner(function = kfile_scan,
                        skeys = ['.k'])

        env = Environment(ENV = {'PATH' : '/usr/local/bin'})
        env.Append(SCANNERS = kscan)

        env.Command('foo', 'foo.k', 'kprocess &#60; $SOURCES &#62; $TARGET')
    </PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-REPOSITORIES"
></A
>Building From Code Repositories</H1
><P
>&#13;  Often, a software project will have
  one or more central repositories,
  directory trees that contain
  source code, or derived files, or both.
  You can eliminate additional unnecessary
  rebuilds of files by having <TT
CLASS="APPLICATION"
>SCons</TT
>
  use files from one or more code repositories
  to build files in your local build tree.

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1365"
></A
>The <TT
CLASS="FUNCTION"
>Repository</TT
> Method</H1
><P
>&#13;    It's often useful to allow multiple programmers working
    on a project to build software from
    source files and/or derived files that
    are stored in a centrally-accessible repository,
    a directory copy of the source code tree.
    (Note that this is not the sort of repository
    maintained by a source code management system
    like BitKeeper, CVS, or Subversion.
    For information about using <TT
CLASS="APPLICATION"
>SCons</TT
>
    with these systems, see the section,
    "Fetching Files From Source Code Management Systems,"
    below.)
    You use the <TT
CLASS="FUNCTION"
>Repository</TT
> method
    to tell <TT
CLASS="APPLICATION"
>SCons</TT
> to search one or more
    central code repositories (in order)
    for any source files and derived files
    that are not present in the local build tree:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       env.Program('hello.c')
       Repository('/usr/repository1', '/usr/repository2')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Multiple calls to the <TT
CLASS="FUNCTION"
>Repository</TT
> method
    will simply add repositories to the global list
    that <TT
CLASS="APPLICATION"
>SCons</TT
> maintains,
    with the exception that <TT
CLASS="APPLICATION"
>SCons</TT
> will automatically eliminate
    the current directory and any non-existent
    directories from the list.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1377"
></A
>Finding source files in repositories</H1
><P
>&#13;    The above example
    specifies that <TT
CLASS="APPLICATION"
>SCons</TT
>
    will first search for files under
    the <TT
CLASS="FILENAME"
>/usr/repository1</TT
> tree
    and next under the <TT
CLASS="FILENAME"
>/usr/repository2</TT
> tree.
    <TT
CLASS="APPLICATION"
>SCons</TT
> expects that any files it searches
    for will be found in the same position
    relative to the top-level directory.
    In the above example, if the <TT
CLASS="FILENAME"
>hello.c</TT
> file is not
    found in the local build tree,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will search first for
    a <TT
CLASS="FILENAME"
>/usr/repository1/hello.c</TT
> file
    and then for a <TT
CLASS="FILENAME"
>/usr/repository1/hello.c</TT
> file
    to use in its place.

    </P
><P
>&#13;    So given the <TT
CLASS="FILENAME"
>SConstruct</TT
> file above,
    if the <TT
CLASS="FILENAME"
>hello.c</TT
> file exists in the local
    build directory,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will rebuild the <TT
CLASS="APPLICATION"
>hello</TT
> program
    as normal:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    If, however, there is no local <TT
CLASS="FILENAME"
>hello.c</TT
> file,
    but one exists in <TT
CLASS="FILENAME"
>/usr/repository1</TT
>,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will recompile the <TT
CLASS="APPLICATION"
>hello</TT
> program
    from the source file it finds in the repository:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-c&nbsp;/usr/repository1/hello.c&nbsp;-o&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    And similarly, if there is no local <TT
CLASS="FILENAME"
>hello.c</TT
> file
    and no <TT
CLASS="FILENAME"
>/usr/repository1/hello.c</TT
>,
    but one exists in <TT
CLASS="FILENAME"
>/usr/repository2</TT
>:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1409"
></A
>Finding the <TT
CLASS="FILENAME"
>SConstruct</TT
> file in repositories</H1
><P
>&#13;    <TT
CLASS="APPLICATION"
>SCons</TT
> will also search in repositories
    for the <TT
CLASS="FILENAME"
>SConstruct</TT
> file and any specified <TT
CLASS="FILENAME"
>SConscript</TT
> files.
    This poses a problem, though:  how can <TT
CLASS="APPLICATION"
>SCons</TT
> search a
    repository tree for an <TT
CLASS="FILENAME"
>SConstruct</TT
> file
    if the <TT
CLASS="FILENAME"
>SConstruct</TT
> file itself contains the information
    about the pathname of the repository?
    To solve this problem, <TT
CLASS="APPLICATION"
>SCons</TT
> allows you
    to specify repository directories
    on the command line using the <TT
CLASS="LITERAL"
>-Y</TT
> option:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -Y /usr/repository1 -Y /usr/repository2</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    When looking for source or derived files,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will first search the repositories
    specified on the command line,
    and then search the repositories
    specified in the <TT
CLASS="FILENAME"
>SConstruct</TT
> or <TT
CLASS="FILENAME"
>SConscript</TT
> files.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1427"
></A
>Finding derived files in repositories</H1
><P
>&#13;    If a repository contains not only source files,
    but also derived files (such as object files,
    libraries, or executables), <TT
CLASS="APPLICATION"
>SCons</TT
> will perform
    its normal MD5 signature calculation to
    decide if a derived file in a repository is up-to-date,
    or the derived file must be rebuilt in the local build directory.
    For the <TT
CLASS="APPLICATION"
>SCons</TT
> signature calculation to work correctly,
    a repository tree must contain the <TT
CLASS="FILENAME"
>.sconsign</TT
> files
    that <TT
CLASS="APPLICATION"
>SCons</TT
> uses to keep track of signature information.

    </P
><P
>&#13;    Usually, this would be done by a build integrator
    who would run <TT
CLASS="APPLICATION"
>SCons</TT
> in the repository
    to create all of its derived files and <TT
CLASS="FILENAME"
>.sconsign</TT
> files,
    or who would <TT
CLASS="APPLICATION"
>SCons</TT
> in a separate build directory
    and copying the resulting tree to the desired repository:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>cd /usr/repository1</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;file1.o&nbsp;file1.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;file2.o&nbsp;file2.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o&nbsp;file1.o&nbsp;file2.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>    
    (Note that this is safe even if the <TT
CLASS="FILENAME"
>SConstruct</TT
> file
    lists <TT
CLASS="FILENAME"
>/usr/repository1</TT
> as a repository,
    because <TT
CLASS="APPLICATION"
>SCons</TT
> will remove the current build directory
    from its repository list for that invocation.)

    </P
><P
>&#13;    Now, with the repository populated,
    we only need to create the one local source file
    we're interested in working with at the moment,
    and use the <TT
CLASS="LITERAL"
>-Y</TT
> option to
    tell <TT
CLASS="APPLICATION"
>SCons</TT
> to fetch any other files it needs
    from the repository:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>cd $HOME/build</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>edit hello.c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -Y /usr/repository1</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o&nbsp;/usr/repository1/file1.o&nbsp;/usr/repository1/file2.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Notice that <TT
CLASS="APPLICATION"
>SCons</TT
> realizes that it does not need to
    rebuild local copies file1.o and file2.o files,
    but instead uses the already-compiled files
    from the repository.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1454"
></A
>Guaranteeing local copies of files</H1
><P
>&#13;    If the repository tree contains the complete results of a build,
    and we try to build from the repository
    without any files in our local tree,
    something moderately surprising happens:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>mkdir $HOME/build2</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>cd $HOME/build2</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -Y /usr/all/repository hello</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up-to-date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Why does <TT
CLASS="APPLICATION"
>SCons</TT
> say that the <TT
CLASS="APPLICATION"
>hello</TT
> program
    is up-to-date when there is no <TT
CLASS="APPLICATION"
>hello</TT
> program
    in the local build directory?
    Because the repository (not the local directory)
    contains the up-to-date <TT
CLASS="APPLICATION"
>hello</TT
> program,
    and <TT
CLASS="APPLICATION"
>SCons</TT
> correctly determines that nothing
    needs to be done to rebuild that
    up-to-date copy of the file.

    </P
><P
>&#13;    There are, however, many times when you want to ensure that a
    local copy of a file always exists.
    A packaging or testing script, for example,
    may assume that certain generated files exist locally.
    To tell <TT
CLASS="APPLICATION"
>SCons</TT
> to make a copy of any up-to-date repository
    file in the local build directory,
    use the <TT
CLASS="FUNCTION"
>Local</TT
> function:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       env = Environment()
       hello = env.Program('hello.c')
       Local(hello)
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    If we then run the same command,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will make a local copy of the program
    from the repository copy,
    and tell you that it is doing so:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;scons&nbsp;-Y&nbsp;/usr/all/repository&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Local&nbsp;copy&nbsp;of&nbsp;hello&nbsp;from&nbsp;/usr/all/repository/hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`hello'&nbsp;is&nbsp;up-to-date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    (Notice that, because the act of making the local copy
    is not considered a "build" of the <TT
CLASS="APPLICATION"
>hello</TT
> file,
    <TT
CLASS="APPLICATION"
>SCons</TT
> still reports that it is up-to-date.)

    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-CACHING"
></A
>Caching Built Files</H1
><P
>&#13;  On multi-developer software projects,
  you can sometimes speed up every developer's builds a lot by
  allowing them to share the derived files that they build.
  <TT
CLASS="APPLICATION"
>SCons</TT
> makes this easy, as well as reliable.

  </P
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1481"
></A
>Specifying the Shared Cache Directory</H1
><P
>&#13;    To enable sharing of derived files,
    use the <TT
CLASS="FUNCTION"
>CacheDir</TT
> function
    in any <TT
CLASS="FILENAME"
>SConscript</TT
> file:

    </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>       CacheDir('/usr/local/build_cache')
    </PRE
></TD
></TR
></TABLE
><P
>&#13;    Note that the directory you specify must already exist
    and be readable and writable by all developers
    who will be sharing derived files.
    It should also be in some central location
    that all builds will be able to access.
    In environments where developers are using separate systems
    (like individual workstations) for builds,
    this directory would typically be
    on a shared or NFS-mounted file system.

    </P
><P
>&#13;    Here's what happens:
    When a build has a <TT
CLASS="FUNCTION"
>CacheDir</TT
> specified,
    every time a file is built,
    it is stored in the shared cache directory
    along with its MD5 build signature.
    On subsequent builds,
    before an action is invoked to build a file,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will check the shared cache directory
    to see if a file with the exact same build
    signature already exists.
    If so, the derived file will not be built locally,
    but will be copied into the local build directory
    from the shared cache directory,
    like so:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieved&nbsp;`hello.o'&nbsp;from&nbsp;cache<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieved&nbsp;`hello'&nbsp;from&nbsp;cache<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1495"
></A
>Keeping Build Output Consistent</H1
><P
>&#13;    One potential drawback to using a shared cache
    is that your build output can be inconsistent
    from invocation to invocation,
    because any given file may be rebuilt one time
    and retrieved from the shared cache the next time.
    This can make analyzing build output more difficult,
    especially for automated scripts that
    expect consistent output each time.

    </P
><P
>&#13;    If, however, you use the <TT
CLASS="LITERAL"
>--cache-show</TT
> option,
    <TT
CLASS="APPLICATION"
>SCons</TT
> will print the command line that it
    <I
CLASS="EMPHASIS"
>would</I
> have executed
    to build the file,
    even when it is retrieving the file from the shared cache.
    This makes the build output consistent
    every time the build is run:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q --cache-show</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    The trade-off, of course, is that you no longer
    know whether or not <TT
CLASS="APPLICATION"
>SCons</TT
>
    has retrieved a derived file from cache
    or has rebuilt it locally.

    </P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1508"
></A
>Not Retrieving Files From a Shared Cache</H1
><P
>&#13;    Retrieving an already-built file
    from the shared cache
    is usually a significant time-savings
    over rebuilding the file,
    but how much of a savings
    (or even whether it saves time at all)
    can depend a great deal on your
    system or network configuration.
    For example, retrieving cached files
    from a busy server over a busy network
    might end up being slower than
    rebuilding the files locally.

    </P
><P
>&#13;    In these cases, you can specify
    the <TT
CLASS="LITERAL"
>--cache-disable</TT
>
    command-line option to tell <TT
CLASS="APPLICATION"
>SCons</TT
>
    to not retrieve already-built files from the
    shared cache directory:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieved&nbsp;`hello.o'&nbsp;from&nbsp;cache<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieved&nbsp;`hello'&nbsp;from&nbsp;cache<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q --cache-disable</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="AEN1520"
></A
>Populating a Shared Cache With Already-Built Files</H1
><P
>&#13;    Sometimes, you may have one or more derived files
    already built in your local build tree
    that you wish to make available to other people doing builds.
    For example, you may find it more effective to perform
    integration builds with the cache disabled
    (per the previous section)
    and only populate the shared cache directory
    with the built files after the integration build
    has completed successfully.
    This way, the cache will only get filled up
    with derived files that are part of a complete, successful build
    not with files that might be later overwritten
    while you debug integration problems.

    </P
><P
>&#13;    In this case, you can use the
    the <TT
CLASS="LITERAL"
>--cache-force</TT
> option
    to tell <TT
CLASS="APPLICATION"
>SCons</TT
> to put all derived files in the cache,
    even if the files had already been built
    by a previous invocation:

    </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q --cache-disable</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q --cache-disable</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q --cache-force</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scons:&nbsp;`.'&nbsp;is&nbsp;up&nbsp;to&nbsp;date.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -c</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieved&nbsp;`hello.o'&nbsp;from&nbsp;cache<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieved&nbsp;`hello'&nbsp;from&nbsp;cache<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;    Notice how the above sample run
    demonstrates that the <TT
CLASS="LITERAL"
>--cache-disable</TT
>
    option avoids putting the built
    <TT
CLASS="FILENAME"
>hello.o</TT
>
    and 
    <TT
CLASS="FILENAME"
>hello</TT
> files in the cache,
    but after using the <TT
CLASS="LITERAL"
>--cache-force</TT
> option,
    the files have been put in the cache
    for the next invocation to retrieve.

    </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAP-ALIAS"
></A
>Alias Targets</H1
><P
>&#13;  We've already seen how you can use the <TT
CLASS="FUNCTION"
>Alias</TT
>
  function to create a target named <TT
CLASS="LITERAL"
>install</TT
>:

  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     env = Environment()
     hello = env.Program('hello.c')
     env.Install('/usr/bin', hello)
     env.Alias('install', '/usr/bin')
  </PRE
></TD
></TR
></TABLE
><P
>&#13;  You can then use this alias on the command line
  to tell <TT
CLASS="APPLICATION"
>SCons</TT
> more naturally that you want to install files:

  </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q install</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;hello.o&nbsp;hello.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;hello&nbsp;hello.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"hello"&nbsp;as&nbsp;"/usr/bin/hello"<br>
&nbsp;&nbsp;</P
><P
>&#13;  Like other <TT
CLASS="CLASSNAME"
>Builder</TT
> methods, though,
  the <TT
CLASS="FUNCTION"
>Alias</TT
> method returns an object
  representing the alias being built.
  You can then use this object as input to anothother <TT
CLASS="CLASSNAME"
>Builder</TT
>.
  This is especially useful if you use such an object
  as input to another call to the <TT
CLASS="FUNCTION"
>Alias</TT
> <TT
CLASS="CLASSNAME"
>Builder</TT
>,
  allowing you to create a hierarchy
  of nested aliases:

  </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     env = Environment()
     p = env.Program('foo.c')
     l = env.Library('bar.c')
     env.Install('/usr/bin', p)
     env.Install('/usr/lib', l)
     ib = env.Alias('install-bin', '/usr/bin')
     il = env.Alias('install-lib', '/usr/lib')
     env.Alias('install', [ib, il])
  </PRE
></TD
></TR
></TABLE
><P
>&#13;  This example defines separate <TT
CLASS="LITERAL"
>install</TT
>,
  <TT
CLASS="LITERAL"
>install-bin</TT
>,
  and <TT
CLASS="LITERAL"
>install-lib</TT
> aliases,
  allowing you finer control over what gets installed:

  </P
><P
CLASS="LITERALLAYOUT"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q install-bin</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"foo"&nbsp;as&nbsp;"/usr/bin/foo"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q install-lib</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;bar.o&nbsp;bar.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ar&nbsp;r&nbsp;libbar.a&nbsp;bar.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ranlib&nbsp;libbar.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"libbar.a"&nbsp;as&nbsp;"/usr/lib/libbar.a"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q -c /</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;/usr/bin/foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;bar.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;libbar.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed&nbsp;/usr/lib/libbar.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<TT
CLASS="USERINPUT"
><B
>scons -Q install</B
></TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;foo.o&nbsp;foo.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-o&nbsp;foo&nbsp;foo.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"foo"&nbsp;as&nbsp;"/usr/bin/foo"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cc&nbsp;-c&nbsp;-o&nbsp;bar.o&nbsp;bar.c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ar&nbsp;r&nbsp;libbar.a&nbsp;bar.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ranlib&nbsp;libbar.a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install&nbsp;file:&nbsp;"libbar.a"&nbsp;as&nbsp;"/usr/lib/libbar.a"<br>
&nbsp;&nbsp;</P
></DIV
></DIV
></BODY
></HTML
>