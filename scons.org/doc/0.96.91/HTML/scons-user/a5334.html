<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Builders</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="SCons User Guide 0.96.91"
HREF="book1.html"><LINK
REL="PREVIOUS"
TITLE="Construction Variables"
HREF="a3061.html"><LINK
REL="NEXT"
TITLE="Tools"
HREF="a5747.html"></HEAD
><BODY
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>SCons User Guide 0.96.91</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="a3061.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="a5747.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
><A
NAME="APP-BUILDERS"
></A
>Builders</H1
><P
>&#13;This appendix contains descriptions of all of the
Builders that are <I
CLASS="EMPHASIS"
>potentially</I
>
available "out of the box" in this version of SCons.&#13;</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="B-CFILE"
></A
><TT
CLASS="FUNCTION"
>CFile()</TT
>, <TT
CLASS="FUNCTION"
>env.CFile()</TT
></DT
><DD
><P
>Builds a C source file given a lex (<TT
CLASS="FILENAME"
>.l</TT
>)
or yacc (<TT
CLASS="FILENAME"
>.y</TT
>) input file.
The suffix specified by the <VAR
CLASS="ENVAR"
>$CFILESUFFIX</VAR
> construction variable
(<TT
CLASS="FILENAME"
>.c</TT
> by default)
is automatically added to the target
if it is not already present. Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># builds foo.c
env.CFile(target = 'foo.c', source = 'foo.l')
# builds bar.c
env.CFile(target = 'bar', source = 'bar.y')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-CXXFILE"
></A
><TT
CLASS="FUNCTION"
>CXXFile()</TT
>, <TT
CLASS="FUNCTION"
>env.CXXFile()</TT
></DT
><DD
><P
>Builds a C++ source file given a lex (<TT
CLASS="FILENAME"
>.ll</TT
>)
or yacc (<TT
CLASS="FILENAME"
>.yy</TT
>)
input file.
The suffix specified by the <VAR
CLASS="ENVAR"
>$CXXFILESUFFIX</VAR
> construction variable
(<TT
CLASS="FILENAME"
>.cc</TT
> by default)
is automatically added to the target
if it is not already present. Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># builds foo.cc
env.CXXFile(target = 'foo.cc', source = 'foo.ll')
# builds bar.cc
env.CXXFile(target = 'bar', source = 'bar.yy')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-DVI"
></A
><TT
CLASS="FUNCTION"
>DVI()</TT
>, <TT
CLASS="FUNCTION"
>env.DVI()</TT
></DT
><DD
><P
>Builds a <TT
CLASS="FILENAME"
>.dvi</TT
> file
from a <TT
CLASS="FILENAME"
>.tex</TT
>,
<TT
CLASS="FILENAME"
>.ltx</TT
> or <TT
CLASS="FILENAME"
>.latex</TT
> input file.
If the source file suffix is <TT
CLASS="FILENAME"
>.tex</TT
>,
<TT
CLASS="APPLICATION"
>scons</TT
>
will examine the contents of the file;
if the string
<TT
CLASS="LITERAL"
>\documentclass</TT
>
or
<TT
CLASS="LITERAL"
>\documentstyle</TT
>
is found, the file is assumed to be a LaTeX file and
the target is built by invoking the <VAR
CLASS="ENVAR"
>$LATEXCOM</VAR
> command line;
otherwise, the <VAR
CLASS="ENVAR"
>$TEXCOM</VAR
> command line is used.
If the file is a LaTeX file,
the
<TT
CLASS="FUNCTION"
>DVI</TT
>
builder method will also examine the contents
of the
<TT
CLASS="FILENAME"
>.aux</TT
>
file
and invoke the <VAR
CLASS="ENVAR"
>$BIBTEX</VAR
> command line
if the string
<TT
CLASS="LITERAL"
>bibdata</TT
>
is found,
and will examine the contents
<TT
CLASS="FILENAME"
>.log</TT
>
file and re-run the <VAR
CLASS="ENVAR"
>$LATEXCOM</VAR
> command
if the log file says it is necessary.</P
><P
>The suffix <TT
CLASS="FILENAME"
>.dvi</TT
>
(hard-coded within TeX itself)
is automatically added to the target
if it is not already present.
Examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># builds from aaa.tex
env.DVI(target = 'aaa.dvi', source = 'aaa.tex')
# builds bbb.dvi
env.DVI(target = 'bbb', source = 'bbb.ltx')
# builds from ccc.latex
env.DVI(target = 'ccc.dvi', source = 'ccc.latex')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-JAR"
></A
><TT
CLASS="FUNCTION"
>Jar()</TT
>, <TT
CLASS="FUNCTION"
>env.Jar()</TT
></DT
><DD
><P
>Builds a Java archive (<TT
CLASS="FILENAME"
>.jar</TT
>) file
from a source tree of <TT
CLASS="FILENAME"
>.class</TT
> files.
If the <VAR
CLASS="ENVAR"
>$JARCHDIR</VAR
> value is set, the
<TT
CLASS="APPLICATION"
>jar</TT
>
command will change to the specified directory using the
<VAR
CLASS="OPTION"
>-C</VAR
>
option.
If the contents any of the source files begin with the string
<TT
CLASS="LITERAL"
>Manifest-Version</TT
>,
the file is assumed to be a manifest
and is passed to the
<TT
CLASS="APPLICATION"
>jar</TT
>
command with the
<VAR
CLASS="OPTION"
>m</VAR
>
option set.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.Jar(target = 'foo.jar', source = 'classes')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-JAVA"
></A
><TT
CLASS="FUNCTION"
>Java()</TT
>, <TT
CLASS="FUNCTION"
>env.Java()</TT
></DT
><DD
><P
>Builds one or more Java class files
from one or more source trees of <TT
CLASS="FILENAME"
>.java</TT
> files.
The class files will be placed underneath
the specified target directory.
SCons will parse each source <TT
CLASS="FILENAME"
>.java</TT
> file
to find the classes
(including inner classes)
defined within that file,
and from that figure out the
target <TT
CLASS="FILENAME"
>.class</TT
> files that will be created.
SCons will also search each Java file
for the Java package name,
which it assumes can be found on a line
beginning with the string
<TT
CLASS="LITERAL"
>package</TT
>
in the first column;
the resulting <TT
CLASS="FILENAME"
>.class</TT
> files
will be placed in a directory reflecting
the specified package name.
For example,
the file
<TT
CLASS="FILENAME"
>Foo.java</TT
>
defining a single public
<CODE
CLASS="CLASSNAME"
>Foo</CODE
>
class and
containing a package name of
<CODE
CLASS="CLASSNAME"
>sub.dir</CODE
>
will generate a corresponding
<TT
CLASS="FILENAME"
>sub/dir/Foo.class</TT
>
class file.</P
><P
>Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.Java(target = 'classes', source = 'src')
env.Java(target = 'classes', source = ['src1', 'src2'])</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-JAVAH"
></A
><TT
CLASS="FUNCTION"
>JavaH()</TT
>, <TT
CLASS="FUNCTION"
>env.JavaH()</TT
></DT
><DD
><P
>Builds C header and source files for
implementing Java native methods.
The target can be either a directory
in which the header files will be written,
or a header file name which
will contain all of the definitions.
The source can be either the names of <TT
CLASS="FILENAME"
>.class</TT
> files,
or the objects returned from the
<TT
CLASS="FUNCTION"
>Java</TT
>
builder method.</P
><P
>If the construction variable
<VAR
CLASS="ENVAR"
>$JAVACLASSDIR</VAR
>
is set, either in the environment
or in the call to the
<TT
CLASS="FUNCTION"
>JavaH</TT
>
builder method itself,
then the value of the variable
will be stripped from the
beginning of any <TT
CLASS="FILENAME"
>.class</TT
> file names.</P
><P
>Examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># builds java_native.h
classes = env.Java(target = 'classdir', source = 'src')
env.JavaH(target = 'java_native.h', source = classes)

# builds include/package_foo.h and include/package_bar.h
env.JavaH(target = 'include',
          source = ['package/foo.class', 'package/bar.class'])

# builds export/foo.h and export/bar.h
env.JavaH(target = 'export',
          source = ['classes/foo.class', 'classes/bar.class'],
          JAVACLASSDIR = 'classes')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-LIBRARY"
></A
><TT
CLASS="FUNCTION"
>Library()</TT
>, <TT
CLASS="FUNCTION"
>env.Library()</TT
></DT
><DD
><P
>A synonym for the
<TT
CLASS="FUNCTION"
>StaticLibrary</TT
>
builder method.</P
></DD
><DT
><A
NAME="B-M4"
></A
><TT
CLASS="FUNCTION"
>M4()</TT
>, <TT
CLASS="FUNCTION"
>env.M4()</TT
></DT
><DD
><P
>Builds an output file from an M4 input file.
This uses a default <VAR
CLASS="ENVAR"
>$M4FLAGS</VAR
> value of
<VAR
CLASS="OPTION"
>-E</VAR
>,
which considers all warnings to be fatal
and stops on the first warning
when using the GNU version of m4.
Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.M4(target = 'foo.c', source = 'foo.c.m4')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-MOC"
></A
><TT
CLASS="FUNCTION"
>Moc()</TT
>, <TT
CLASS="FUNCTION"
>env.Moc()</TT
></DT
><DD
><P
>Builds an output file from a moc input file. Moc input files are either 
header files or cxx files. This builder is only available after using the 
tool 'qt'. See the <VAR
CLASS="ENVAR"
>$QTDIR</VAR
> variable for more information.
Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.Moc('foo.h') # generates moc_foo.cc
env.Moc('foo.cpp') # generates foo.moc</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-MSVSPROJECT"
></A
><TT
CLASS="FUNCTION"
>MSVSProject()</TT
>, <TT
CLASS="FUNCTION"
>env.MSVSProject()</TT
></DT
><DD
><P
>Builds Microsoft Visual Studio project files.
This builds a Visual Studio project file, based on the version of
Visual Studio that is configured (either the latest installed version,
or the version set by 
<VAR
CLASS="ENVAR"
>$MSVS_VERSION</VAR
>
in the Environment constructor).
For VS 6, it will generate 
<TT
CLASS="FILENAME"
>.dsp</TT
>
and
<TT
CLASS="FILENAME"
>.dsw</TT
>
files, for VS 7, it will
generate
<TT
CLASS="FILENAME"
>.vcproj</TT
>
and
<TT
CLASS="FILENAME"
>.sln</TT
>
files.</P
><P
>It takes several lists of filenames to be placed into the project
file, currently these are limited to 
<TT
CLASS="LITERAL"
>srcs</TT
>,
<TT
CLASS="LITERAL"
>incs</TT
>,
<TT
CLASS="LITERAL"
>localincs</TT
>,
<TT
CLASS="LITERAL"
>resources</TT
>,
and
<TT
CLASS="LITERAL"
>misc</TT
>.
These are pretty self explanatory, but it
should be noted that the <TT
CLASS="LITERAL"
>srcs</TT
> list
is NOT added to the <VAR
CLASS="ENVAR"
>$SOURCES</VAR
>
construction variable.  This is because it represents a list of files
to be added to the project file, not the source used to build the
project file (in this case, the "source" is the <TT
CLASS="FILENAME"
>SConscript</TT
> file used
to call MSVSProject).</P
><P
>In addition to these values (which are all optional, although not
specifying any of them results in an empty project file), the
following values must be specified:</P
><P
>target: The name of the target
<TT
CLASS="FILENAME"
>.dsp</TT
>
or
<TT
CLASS="FILENAME"
>.vcproj</TT
>
file.  The correct
suffix for the version of Visual Studio must be used, but the
<VAR
CLASS="ENVAR"
>$MSVSPROJECTSUFFIX</VAR
>
construction value
will be defined to the correct value (see example below).</P
><P
>variant: The name of this particular variant.  These are typically
things like "Debug" or "Release", but really can be anything you want.
Multiple calls to MSVSProject with different variants are allowed: all
variants will be added to the project file with their appropriate
build targets and sources.</P
><P
>buildtarget: A list of SCons.Node.FS objects which is returned from
the command which builds the target.  This is used to tell SCons what
to build when the 'build' button is pressed inside of the IDE.</P
><P
>Example usage:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>barsrcs = ['bar.cpp'],
barincs = ['bar.h'],
barlocalincs = ['StdAfx.h']
barresources = ['bar.rc','resource.h']
barmisc = ['bar_readme.txt']

dll = local.SharedLibrary(target = 'bar.dll',
                          source = barsrcs)

local.MSVSProject(target = 'Bar' + env['MSVSPROJECTSUFFIX'],
                  srcs = barsrcs,
                  incs = barincs,
                  localincs = barlocalincs,
                  resources = barresources,
                  misc = barmisc,
                  buildtarget = dll,
                  variant = 'Release')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-OBJECT"
></A
><TT
CLASS="FUNCTION"
>Object()</TT
>, <TT
CLASS="FUNCTION"
>env.Object()</TT
></DT
><DD
><P
>A synonym for the
<TT
CLASS="FUNCTION"
>StaticObject</TT
>
builder method.</P
></DD
><DT
><A
NAME="B-PCH"
></A
><TT
CLASS="FUNCTION"
>PCH()</TT
>, <TT
CLASS="FUNCTION"
>env.PCH()</TT
></DT
><DD
><P
>Builds a Microsoft Visual C++ precompiled header.
Calling this builder method
returns a list of two targets: the PCH as the first element, and the object
file as the second element. Normally the object file is ignored.
This builder method is only
provided when Microsoft Visual C++ is being used as the compiler. 
The PCH builder method is generally used in
conjuction with the PCH construction variable to force object files to use
the precompiled header:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env['PCH'] = env.PCH('StdAfx.cpp')[0]</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-PDF"
></A
><TT
CLASS="FUNCTION"
>PDF()</TT
>, <TT
CLASS="FUNCTION"
>env.PDF()</TT
></DT
><DD
><P
>Builds a <TT
CLASS="FILENAME"
>.pdf</TT
> file
from a <TT
CLASS="FILENAME"
>.dvi</TT
> input file
(or, by extension, a <TT
CLASS="FILENAME"
>.tex</TT
>,
<TT
CLASS="FILENAME"
>.ltx</TT
>,
or
<TT
CLASS="FILENAME"
>.latex</TT
> input file).
The suffix specified by the <VAR
CLASS="ENVAR"
>$PDFSUFFIX</VAR
> construction variable
(<TT
CLASS="FILENAME"
>.pdf</TT
> by default)
is added automatically to the target
if it is not already present.  Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># builds from aaa.tex
env.PDF(target = 'aaa.pdf', source = 'aaa.tex')
# builds bbb.pdf from bbb.dvi
env.PDF(target = 'bbb', source = 'bbb.dvi')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-POSTSCRIPT"
></A
><TT
CLASS="FUNCTION"
>PostScript()</TT
>, <TT
CLASS="FUNCTION"
>env.PostScript()</TT
></DT
><DD
><P
>Builds a <TT
CLASS="FILENAME"
>.ps</TT
> file
from a <TT
CLASS="FILENAME"
>.dvi</TT
> input file
(or, by extension, a <TT
CLASS="FILENAME"
>.tex</TT
>,
<TT
CLASS="FILENAME"
>.ltx</TT
>,
or
<TT
CLASS="FILENAME"
>.latex</TT
> input file).
The suffix specified by the <VAR
CLASS="ENVAR"
>$PSSUFFIX</VAR
> construction variable
(<TT
CLASS="FILENAME"
>.ps</TT
> by default)
is added automatically to the target
if it is not already present.  Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># builds from aaa.tex
env.PostScript(target = 'aaa.ps', source = 'aaa.tex')
# builds bbb.ps from bbb.dvi
env.PostScript(target = 'bbb', source = 'bbb.dvi')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-PROGRAM"
></A
><TT
CLASS="FUNCTION"
>Program()</TT
>, <TT
CLASS="FUNCTION"
>env.Program()</TT
></DT
><DD
><P
>Builds an executable given one or more object files
or C, C++, D, or Fortran source files.
If any C, C++, D or Fortran source files are specified,
then they will be automatically
compiled to object files using the
<TT
CLASS="FUNCTION"
>Object</TT
>
builder method;
see that builder method's description for
a list of legal source file suffixes
and how they are interpreted.
The target executable file prefix
(specified by the <VAR
CLASS="ENVAR"
>$PROGPREFIX</VAR
> construction variable; nothing by default)
and suffix
(specified by the <VAR
CLASS="ENVAR"
>$PROGSUFFIX</VAR
> construction variable;
by default, <TT
CLASS="FILENAME"
>.exe</TT
> on Windows systems,
nothing on POSIX systems)
are automatically added to the target if not already present.
Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.Program(target = 'foo', source = ['foo.o', 'bar.c', 'baz.f'])</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-RES"
></A
><TT
CLASS="FUNCTION"
>RES()</TT
>, <TT
CLASS="FUNCTION"
>env.RES()</TT
></DT
><DD
><P
>Builds a Microsoft Visual C++ resource file.
This builder method is only provided
when Microsoft Visual C++ or MinGW is being used as the compiler. The
<TT
CLASS="FILENAME"
>.res</TT
>
(or 
<TT
CLASS="FILENAME"
>.o</TT
>
for MinGW) suffix is added to the target name if no other suffix is given.
The source
file is scanned for implicit dependencies as though it were a C file. Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.RES('resource.rc')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-RMIC"
></A
><TT
CLASS="FUNCTION"
>RMIC()</TT
>, <TT
CLASS="FUNCTION"
>env.RMIC()</TT
></DT
><DD
><P
>Builds stub and skeleton class files
for remote objects
from Java <TT
CLASS="FILENAME"
>.class</TT
> files.
The target is a directory
relative to which the stub
and skeleton class files will be written.
The source can be the names of <TT
CLASS="FILENAME"
>.class</TT
> files,
or the objects return from the
<TT
CLASS="FUNCTION"
>Java</TT
>
builder method.</P
><P
>If the construction variable
<VAR
CLASS="ENVAR"
>$JAVACLASSDIR</VAR
>
is set, either in the environment
or in the call to the
<TT
CLASS="FUNCTION"
>RMIC</TT
>
builder method itself,
then the value of the variable
will be stripped from the
beginning of any <TT
CLASS="FILENAME"
>.class </TT
>
file names.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>classes = env.Java(target = 'classdir', source = 'src')
env.RMIC(target = 'outdir1', source = classes)

env.RMIC(target = 'outdir2',
         source = ['package/foo.class', 'package/bar.class'])

env.RMIC(target = 'outdir3',
         source = ['classes/foo.class', 'classes/bar.class'],
         JAVACLASSDIR = 'classes')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-RPCGENCLIENT"
></A
><TT
CLASS="FUNCTION"
>RPCGenClient()</TT
>, <TT
CLASS="FUNCTION"
>env.RPCGenClient()</TT
></DT
><DD
><P
>Generates an RPC client stub (<TT
CLASS="FILENAME"
>_clnt.c</TT
>) file
from a specified RPC (<TT
CLASS="FILENAME"
>.x</TT
>) source file.
Because rpcgen only builds output files
in the local directory,
the command will be executed
in the source file's directory by default.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># Builds src/rpcif_clnt.c
env.RPCGenClient('src/rpcif.x')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-RPCGENHEADER"
></A
><TT
CLASS="FUNCTION"
>RPCGenHeader()</TT
>, <TT
CLASS="FUNCTION"
>env.RPCGenHeader()</TT
></DT
><DD
><P
>Generates an RPC header (<TT
CLASS="FILENAME"
>.h</TT
>) file
from a specified RPC (<TT
CLASS="FILENAME"
>.x</TT
>) source file.
Because rpcgen only builds output files
in the local directory,
the command will be executed
in the source file's directory by default.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># Builds src/rpcif.h
env.RPCGenHeader('src/rpcif.x')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-RPCGENSERVICE"
></A
><TT
CLASS="FUNCTION"
>RPCGenService()</TT
>, <TT
CLASS="FUNCTION"
>env.RPCGenService()</TT
></DT
><DD
><P
>Generates an RPC server-skeleton (<TT
CLASS="FILENAME"
>_svc.c</TT
>) file
from a specified RPC (<TT
CLASS="FILENAME"
>.x</TT
>) source file.
Because rpcgen only builds output files
in the local directory,
the command will be executed
in the source file's directory by default.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># Builds src/rpcif_svc.c
env.RPCGenClient('src/rpcif.x')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-RPCGENXDR"
></A
><TT
CLASS="FUNCTION"
>RPCGenXDR()</TT
>, <TT
CLASS="FUNCTION"
>env.RPCGenXDR()</TT
></DT
><DD
><P
>Generates an RPC XDR routine (<TT
CLASS="FILENAME"
>_xdr.c</TT
>) file
from a specified RPC (<TT
CLASS="FILENAME"
>.x</TT
>) source file.
Because rpcgen only builds output files
in the local directory,
the command will be executed
in the source file's directory by default.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
># Builds src/rpcif_xdr.c
env.RPCGenClient('src/rpcif.x')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-SHAREDLIBRARY"
></A
><TT
CLASS="FUNCTION"
>SharedLibrary()</TT
>, <TT
CLASS="FUNCTION"
>env.SharedLibrary()</TT
></DT
><DD
><P
>Builds a shared library
(<TT
CLASS="FILENAME"
>.so</TT
> on a POSIX system,
<TT
CLASS="FILENAME"
>.dll</TT
> on WIN32)
given one or more object files
or C, C++, D or Fortran source files.
If any source files are given,
then they will be automatically
compiled to object files.
The static library prefix and suffix (if any)
are automatically added to the target.
The target library file prefix
(specified by the <VAR
CLASS="ENVAR"
>$SHLIBPREFIX</VAR
> construction variable;
by default, <TT
CLASS="FILENAME"
>lib</TT
> on POSIX systems,
nothing on Windows systems)
and suffix
(specified by the <VAR
CLASS="ENVAR"
>$SHLIBSUFFIX</VAR
> construction variable;
by default, <TT
CLASS="FILENAME"
>.dll</TT
> on Windows systems,
<TT
CLASS="FILENAME"
>.so</TT
> on POSIX systems)
are automatically added to the target if not already present.
Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.SharedLibrary(target = 'bar', source = ['bar.c', 'foo.o'])</PRE
></TD
></TR
></TABLE
><P
>On WIN32 systems, the
<TT
CLASS="FUNCTION"
>SharedLibrary</TT
>
builder method will always build an import
(<TT
CLASS="FILENAME"
>.lib</TT
>) library
in addition to the shared (<TT
CLASS="FILENAME"
>.dll</TT
>) library,
adding a <TT
CLASS="FILENAME"
>.lib</TT
> library with the same basename
if there is not already a <TT
CLASS="FILENAME"
>.lib</TT
> file explicitly
listed in the targets.</P
><P
>Any object files listed in the
<TT
CLASS="LITERAL"
>source</TT
>
must have been built for a shared library
(that is, using the
<TT
CLASS="FUNCTION"
>SharedObject</TT
>
builder method).
<TT
CLASS="APPLICATION"
>scons</TT
>
will raise an error if there is any mismatch.</P
><P
>On WIN32 systems, specifying
<TT
CLASS="LITERAL"
>register=1</TT
>
will cause the <TT
CLASS="FILENAME"
>.dll</TT
> to be
registered after it is built using REGSVR32.
The command that is run
("regsvr32" by default) is determined by <VAR
CLASS="ENVAR"
>$REGSVR</VAR
> construction
variable, and the flags passed are determined by <VAR
CLASS="ENVAR"
>$REGSVRFLAGS</VAR
>.  By
default, <VAR
CLASS="ENVAR"
>$REGSVRFLAGS</VAR
> includes the <VAR
CLASS="OPTION"
>/s</VAR
> option,
to prevent dialogs from popping
up and requiring user attention when it is run.  If you change
<VAR
CLASS="ENVAR"
>$REGSVRFLAGS</VAR
>, be sure to include the <VAR
CLASS="OPTION"
>/s</VAR
> option.
For example,</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.SharedLibrary(target = 'bar',
                  source = ['bar.cxx', 'foo.obj'],
                  register=1)</PRE
></TD
></TR
></TABLE
><P
>will register <TT
CLASS="FILENAME"
>bar.dll</TT
> as a COM object
when it is done linking it.</P
></DD
><DT
><A
NAME="B-SHAREDOBJECT"
></A
><TT
CLASS="FUNCTION"
>SharedObject()</TT
>, <TT
CLASS="FUNCTION"
>env.SharedObject()</TT
></DT
><DD
><P
>Builds an object file for
inclusion in a shared library.
Source files must have one of the same set of extensions
specified above for the
<TT
CLASS="FUNCTION"
>StaticObject</TT
>
builder method.
On some platforms building a shared object requires additional
compiler option
(e.g. <VAR
CLASS="OPTION"
>-fPIC</VAR
> for gcc)
in addition to those needed to build a
normal (static) object, but on some platforms there is no difference between a
shared object and a normal (static) one. When there is a difference, SCons
will only allow shared objects to be linked into a shared library, and will
use a different suffix for shared objects. On platforms where there is no
difference, SCons will allow both normal (static)
and shared objects to be linked into a
shared library, and will use the same suffix for shared and normal
(static) objects.
The target object file prefix
(specified by the <VAR
CLASS="ENVAR"
>$SHOBJPREFIX</VAR
> construction variable;
by default, the same as <VAR
CLASS="ENVAR"
>$OBJPREFIX</VAR
>)
and suffix
(specified by the <VAR
CLASS="ENVAR"
>$SHOBJSUFFIX</VAR
> construction variable)
are automatically added to the target if not already present. 
Examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.SharedObject(target = 'ddd', source = 'ddd.c')
env.SharedObject(target = 'eee.o', source = 'eee.cpp')
env.SharedObject(target = 'fff.obj', source = 'fff.for')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-STATICLIBRARY"
></A
><TT
CLASS="FUNCTION"
>StaticLibrary()</TT
>, <TT
CLASS="FUNCTION"
>env.StaticLibrary()</TT
></DT
><DD
><P
>Builds a static library given one or more object files
or C, C++, D or Fortran source files.
If any source files are given,
then they will be automatically
compiled to object files.
The static library prefix and suffix (if any)
are automatically added to the target.
The target library file prefix
(specified by the <VAR
CLASS="ENVAR"
>$LIBPREFIX</VAR
> construction variable;
by default, <TT
CLASS="FILENAME"
>lib</TT
> on POSIX systems,
nothing on Windows systems)
and suffix
(specified by the <VAR
CLASS="ENVAR"
>$LIBSUFFIX</VAR
> construction variable;
by default, <TT
CLASS="FILENAME"
>.lib</TT
> on Windows systems,
<TT
CLASS="FILENAME"
>.a</TT
> on POSIX systems)
are automatically added to the target if not already present.
Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.StaticLibrary(target = 'bar', source = ['bar.c', 'foo.o'])</PRE
></TD
></TR
></TABLE
><P
>Any object files listed in the
<TT
CLASS="LITERAL"
>source</TT
>
must have been built for a static library
(that is, using the
<TT
CLASS="FUNCTION"
>StaticObject</TT
>
builder method).
<TT
CLASS="APPLICATION"
>scons</TT
>
will raise an error if there is any mismatch.</P
></DD
><DT
><A
NAME="B-STATICOBJECT"
></A
><TT
CLASS="FUNCTION"
>StaticObject()</TT
>, <TT
CLASS="FUNCTION"
>env.StaticObject()</TT
></DT
><DD
><P
>Builds a static object file
from one or more C, C++, D, or Fortran source files.
Source files must have one of the following extensions:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  .asm    assembly language file
  .ASM    assembly language file
  .c      C file
  .C      WIN32:  C file
          POSIX:  C++ file
  .cc     C++ file
  .cpp    C++ file
  .cxx    C++ file
  .cxx    C++ file
  .c++    C++ file
  .C++    C++ file
  .d      D file
  .f      Fortran file
  .F      WIN32:  Fortran file
          POSIX:  Fortran file + C pre-processor
  .for    Fortran file
  .FOR    Fortran file
  .fpp    Fortran file + C pre-processor
  .FPP    Fortran file + C pre-processor
  .s      assembly language file
  .S      WIN32:  assembly language file
          POSIX:  assembly language file + C pre-processor
  .spp    assembly language file + C pre-processor
  .SPP    assembly language file + C pre-processor</PRE
></TD
></TR
></TABLE
><P
>The target object file prefix
(specified by the <VAR
CLASS="ENVAR"
>$OBJPREFIX</VAR
> construction variable; nothing by default)
and suffix
(specified by the <VAR
CLASS="ENVAR"
>$OBJSUFFIX</VAR
> construction variable;
<TT
CLASS="FILENAME"
>.obj</TT
> on Windows systems,
<TT
CLASS="FILENAME"
>.o</TT
> on POSIX systems)
are automatically added to the target if not already present.
Examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.StaticObject(target = 'aaa', source = 'aaa.c')
env.StaticObject(target = 'bbb.o', source = 'bbb.c++')
env.StaticObject(target = 'ccc.obj', source = 'ccc.f')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-TAR"
></A
><TT
CLASS="FUNCTION"
>Tar()</TT
>, <TT
CLASS="FUNCTION"
>env.Tar()</TT
></DT
><DD
><P
>Builds a tar archive of the specified files
and/or directories.
Unlike most builder methods,
the
<TT
CLASS="FUNCTION"
>Tar</TT
>
builder method may be called multiple times
for a given target;
each additional call
adds to the list of entries
that will be built into the archive.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.Tar('src.tar', 'src')

# Create the stuff.tar file.
env.Tar('stuff', ['subdir1', 'subdir2'])
# Also add "another" to the stuff.tar file.
env.Tar('stuff', 'another')

# Set TARFLAGS to create a gzip-filtered archive.
env = Environment(TARFLAGS = '-c -z')
env.Tar('foo.tar.gz', 'foo')

# Also set the suffix to .tgz.
env = Environment(TARFLAGS = '-c -z',
                  TARSUFFIX = '.tgz')
env.Tar('foo')</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-TYPELIBRARY"
></A
><TT
CLASS="FUNCTION"
>TypeLibrary()</TT
>, <TT
CLASS="FUNCTION"
>env.TypeLibrary()</TT
></DT
><DD
><P
>Builds a Windows type library (<TT
CLASS="FILENAME"
>.tlb</TT
>)
file from an input IDL file (<TT
CLASS="FILENAME"
>.idl</TT
>).
In addition, it will build the associated inteface stub and
proxy source files,
naming them according to the base name of the <TT
CLASS="FILENAME"
>.idl</TT
> file.
For example,</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.TypeLibrary(source="foo.idl")</PRE
></TD
></TR
></TABLE
><P
>Will create <TT
CLASS="FILENAME"
>foo.tlb</TT
>,
<TT
CLASS="FILENAME"
>foo.h</TT
>,
<TT
CLASS="FILENAME"
>foo_i.c</TT
>,
<TT
CLASS="FILENAME"
>foo_p.c</TT
>
and
<TT
CLASS="FILENAME"
>foo_data.c</TT
>
files.</P
></DD
><DT
><A
NAME="B-UIC"
></A
><TT
CLASS="FUNCTION"
>Uic()</TT
>, <TT
CLASS="FUNCTION"
>env.Uic()</TT
></DT
><DD
><P
>Builds a header file, an implementation file and a moc file from an ui file.
and returns the corresponding nodes in the above order.
This builder is only available after using the tool 'qt'. Note: you can 
specify <TT
CLASS="FILENAME"
>.ui</TT
> files directly as source
files to the <TT
CLASS="FUNCTION"
>Program</TT
>,
<TT
CLASS="FUNCTION"
>Library</TT
> and <TT
CLASS="FUNCTION"
>SharedLibrary</TT
> builders
without using this builder. Using this builder lets you override the standard
naming conventions (be careful: prefixes are always prepended to names of
built files; if you don't want prefixes, you may set them to ``).
See the <VAR
CLASS="ENVAR"
>$QTDIR</VAR
> variable for more information.
Example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.Uic('foo.ui') # -&#62; ['foo.h', 'uic_foo.cc', 'moc_foo.cc']
env.Uic(target = Split('include/foo.h gen/uicfoo.cc gen/mocfoo.cc'),
        source = 'foo.ui') # -&#62; ['include/foo.h', 'gen/uicfoo.cc', 'gen/mocfoo.cc']</PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="B-ZIP"
></A
><TT
CLASS="FUNCTION"
>Zip()</TT
>, <TT
CLASS="FUNCTION"
>env.Zip()</TT
></DT
><DD
><P
>Builds a zip archive of the specified files
and/or directories.
Unlike most builder methods,
the
<TT
CLASS="FUNCTION"
>Zip</TT
>
builder method may be called multiple times
for a given target;
each additional call
adds to the list of entries
that will be built into the archive.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>env.Zip('src.zip', 'src')

# Create the stuff.zip file.
env.Zip('stuff', ['subdir1', 'subdir2'])
# Also add "another" to the stuff.tar file.
env.Zip('stuff', 'another')</PRE
></TD
></TR
></TABLE
></DD
></DL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="a3061.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="a5747.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Construction Variables</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Tools</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>