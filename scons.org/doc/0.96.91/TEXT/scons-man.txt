SCONS(1)                                                              SCONS(1)



NNAAMMEE
       scons - a software construction tool

SSYYNNOOPPSSIISS
       ssccoonnss [ _o_p_t_i_o_n_s...  ] [ _n_a_m_e=_v_a_l...  ] [ _t_a_r_g_e_t_s...  ]

DDEESSCCRRIIPPTTIIOONN
       The ssccoonnss utility builds software (or other files) by determining which
       component pieces must be rebuilt and executing the  necessary  commands
       to rebuild them.

       By  default, ssccoonnss searches for a file named _S_C_o_n_s_t_r_u_c_t, _S_c_o_n_s_t_r_u_c_t, or
       _s_c_o_n_s_t_r_u_c_t (in that order) in the current directory and reads its  con-
       figuration  from  the  first file found.  An alternate file name may be
       specified via the --ff option.

       The _S_C_o_n_s_t_r_u_c_t file can specify subsidiary  configuration  files  using
       the  SSCCoonnssccrriipptt(())  function.  By convention, these subsidiary files are
       named _S_C_o_n_s_c_r_i_p_t, although any name may be used.  (Because of this nam-
       ing  convention, the term "SConscript files" is sometimes used to refer
       generically to all ssccoonnss configuration files, regardless of actual file
       name.)

       The  configuration  files  specify  the  target  files to be built, and
       (optionally) the rules to  build  those  targets.   Reasonable  default
       rules  exist  for  building common software components (executable pro-
       grams, object files, libraries), so that for  most  software  projects,
       only the target and input files need be specified.

       ssccoonnss reads and executes the SConscript files as Python scripts, so you
       may use normal Python scripting capabilities  (such  as  flow  control,
       data manipulation, and imported Python libraries) to handle complicated
       build situations.  ssccoonnss, however, reads and executes all of the  SCon-
       script files _b_e_f_o_r_e it begins building any targets.  To make this obvi-
       ous, ssccoonnss prints the following messages about what it is doing:

              $ scons foo.out
              scons: Reading SConscript files ...
              scons: done reading SConscript files.
              scons: Building targets  ...
              cp foo.in foo.out
              scons: done building targets.
              $

       The status messages (everything except the line that reads  "cp  foo.in
       foo.out") may be suppressed using the --QQ option.

       ssccoonnss does not automatically propagate the external environment used to
       execute ssccoonnss to the commands used to build target files.  This  is  so
       that builds will be guaranteed repeatable regardless of the environment
       variables set at the time ssccoonnss is invoked.  This also  means  that  if
       the  compiler or other commands that you want to use to build your tar-
       get files are not in standard system locations,  ssccoonnss  will  not  find
       them  unless  you  explicitly  set the PATH to include those locations.
       Whenever you create an ssccoonnss construction environment, you  can  propa-
       gate the value of PATH from your external environment as follows:

              import os
              env = Environment(ENV = {'PATH' : os.environ['PATH']})

       Similarly,  if  the  commands  use  external environment variables like
       $PATH, $HOME, $JAVA_HOME, $LANG, $SHELL, $TERM, etc.,  these  variables
       can also be explicitly propagated:

              import os
              env = Environment(ENV = {'PATH' : os.environ['PATH'],
                                       'HOME' : os.environ['HOME']})

       Or  you  may explicitly propagate the invoking user's complete external
       environment:

              import os
              env = Environment(ENV = os.environ['PATH'])

       This comes at the expense of making your build dependent on the  user's
       environment being set correctly, but it may be more convenient for many
       configurations.

       ssccoonnss can scan known input files automatically for dependency  informa-
       tion  (for  example,  #include  statements  in C or C++ files) and will
       rebuild dependent files appropriately  whenever  any  "included"  input
       file  changes.   ssccoonnss  supports the ability to define new scanners for
       unknown input file types.

       ssccoonnss knows how to fetch files automatically from SCCS or RCS subdirec-
       tories using SCCS, RCS or BitKeeper.

       ssccoonnss  is normally executed in a top-level directory containing a _S_C_o_n_-
       _s_t_r_u_c_t file, optionally specifying as command-line arguments the target
       file or files to be built.

       By default, the command

              scons

       will  build  all  target  files  in  or  below  the  current directory.
       Explicit default targets (to be built when no targets are specified  on
       the  command  line)  may  be  defined  the SConscript file(s) using the
       DDeeffaauulltt(()) function, described below.

       Even when DDeeffaauulltt(()) targets are specified in  the  SConscript  file(s),
       all  target  files  in  or  below the current directory may be built by
       explicitly specifying the current directory (.)  as a command-line tar-
       get:

              scons .

       Building  all  target files, including any files outside of the current
       directory, may be specified by supplying a command-line target  of  the
       root directory (on POSIX systems):

              scons /

       or the path name(s) of the volume(s) in which all the targets should be
       built (on Windows systems):

              scons C:\ D:\

       To build only specific targets, supply them as command-line arguments:

              scons foo bar

       in which case only the specified targets will be built (along with  any
       derived files on which they depend).

       Specifying "cleanup" targets in SConscript files is not necessary.  The
       --cc flag removes all files necessary to build the specified target:

              scons -c .

       to remove all target files, or:

              scons -c build export

       to remove target files under build and  export.   Additional  files  or
       directories to remove can be specified using the Clean() function.

       A  subset  of a hierarchical tree may be built by remaining at the top-
       level directory (where the _S_C_o_n_s_t_r_u_c_t file lives)  and  specifying  the
       subdirectory as the target to be built:

              scons src/subdir

       or  by  changing directory and invoking scons with the --uu option, which
       traverses up the directory hierarchy  until  it  finds  the  _S_C_o_n_s_t_r_u_c_t
       file, and then builds targets relatively to the current subdirectory:

              cd src/subdir
              scons -u .

       ssccoonnss  supports  building  multiple targets in parallel via a --jj option
       that takes, as its argument, the number of simultaneous tasks that  may
       be spawned:

              scons -j 4

       builds four targets in parallel, for example.

       ssccoonnss can maintain a cache of target (derived) files that can be shared
       between multiple builds.  When caching is enabled in a SConscript file,
       any target files built by ssccoonnss will be copied to the cache.  If an up-
       to-date target file is found in the cache, it will  be  retrieved  from
       the  cache  instead  of being rebuilt locally.  Caching behavior may be
       disabled and controlled in other ways by  the  ----ccaacchhee--ffoorrccee,  ----ccaacchhee--
       ddiissaabbllee, and ----ccaacchhee--sshhooww command-line options.  The ----rraannddoomm option is
       useful to prevent multiple builds  from  trying  to  update  the  cache
       simultaneously.

       Values of variables to be passed to the SConscript file(s) may be spec-
       ified on the command line:

              scons debug=1 .

       These variables are available in SConscript files through the ARGUMENTS
       dictionary,  and  can  be  used in the SConscript file(s) to modify the
       build in any way:

              if ARGUMENTS.get('debug', 0):
                  env = Environment(CCFLAGS = '-g')
              else:
                  env = Environment()

       The command-line variable arguments are also available in  the  ARGLIST
       list,  indexed  by their order on the command line.  This allows you to
       process them in order rather than by name,  if  necessary.   ARGLIST[0]
       returns  a tuple containing (argname, argvalue).  A Python exception is
       thrown if you try to access a list member that does not exist.

       ssccoonnss requires Python version 1.5.2 or later.  There should be no other
       dependencies or requirements to run ssccoonnss..

       By  default,  ssccoonnss knows how to search for available programming tools
       on various systems.  On WIN32 systems, ssccoonnss searches in order for  the
       Microsoft  Visual  C++  tools, the MinGW tool chain, the Intel compiler
       tools, and the PharLap ETS compiler.  On OS/2 systems,  ssccoonnss  searches
       in  order  for the OS/2 compiler, the GCC tool chain, and the Microsoft
       Visual C++ tools, On SGI IRIX, IBM AIX, Hewlett Packard HP-UX, and  Sun
       Solaris systems, ssccoonnss searches for the native compiler tools (MIPSpro,
       Visual Age, aCC, and Forte tools respectively) and the GCC tool  chain.
       On  all  other  platforms,  including POSIX (Linux and UNIX) platforms,
       ssccoonnss searches in order for the GCC tool chain,  the  Microsoft  Visual
       C++  tools, and the Intel compiler tools.  You may, of course, override
       these default values by appropriate configuration of  Environment  con-
       struction variables.


OOPPTTIIOONNSS
       In  general,  ssccoonnss supports the same command-line options as GNU mmaakkee,
       and many of those supported by ccoonnss.


       -b     Ignored for compatibility with non-GNU versions of mmaakkee..


       -c, --clean, --remove
              Clean up by removing all target files for which  a  construction
              command  is  specified.   Also  remove  any files or directories
              associated to the construction command using the  Clean()  func-
              tion.


       --cache-disable, --no-cache
              Disable the derived-file caching specified by CCaacchheeDDiirr().  ssccoonnss
              will neither retrieve files from the cache nor copy files to the
              cache.


       --cache-force, --cache-populate
              When  using CCaacchheeDDiirr(), populate a cache by copying any already-
              existing, up-to-date derived files to the cache, in addition  to
              files  built  by  this invocation.  This is useful to populate a
              new cache with all the current derived files, or to add  to  the
              cache any derived files recently built with caching disabled via
              the ----ccaacchhee--ddiissaabbllee option.


       --cache-show
              When using CCaacchheeDDiirr() and retrieving a  derived  file  from  the
              cache,  show  the command that would have been executed to build
              the file, instead of the usual report,  "Retrieved  `file'  from
              cache."   This  will  produce  consistent output for build logs,
              regardless of whether a target file  was  rebuilt  or  retrieved
              from the cache.


       --config=_m_o_d_e
              This specifies how the CCoonnffiigguurree call should use or generate the
              results of configuration tests.  The option should be  specified
              from among the following choices:


       --config=auto
              scons  will  use its normal dependency mechanisms to decide if a
              test must be rebuilt or not.  This saves time by not running the
              same  configuration  tests every time you invoke scons, but will
              overlook changes in system header  files  or  external  commands
              (such  as  compilers)  if  you  don't  specify those dependecies
              explicitly.  This is the default behavior.


       --config=force
              If this option is specified, all configuration tests will be re-
              run  regardless  of  whether the cached results are out of date.
              This can be used to explicitly force the configuration tests  to
              be  updated in response to an otherwise unconfigured change in a
              system header file or compiler.


       --config=cache
              If this option is specified,  no  configuration  tests  will  be
              rerun and all results will be taken from cache.  Note that scons
              will still consider it an error if --config=cache  is  specified
              and a necessary test does not yet have any results in the cache.


       -C _d_i_r_e_c_t_o_r_y,  --directory=_d_i_r_e_c_t_o_r_y
              Change to the specified _d_i_r_e_c_t_o_r_y before searching for the _S_C_o_n_-
              _s_t_r_u_c_t,  _S_c_o_n_s_t_r_u_c_t, or _s_c_o_n_s_t_r_u_c_t file, or doing anything else.
              Multiple --CC options are interpreted  relative  to  the  previous
              one,  and  the right-most --CC option wins. (This option is nearly
              equivalent to  --ff  ddiirreeccttoorryy//SSCCoonnssttrruucctt,  except  that  it  will
              search  for  _S_C_o_n_s_t_r_u_c_t, _S_c_o_n_s_t_r_u_c_t, or _s_c_o_n_s_t_r_u_c_t in the speci-
              fied directory.)



       -D     Works exactly the same way as the --uu option except for  the  way
              default  targets  are  handled.  When this option is used and no
              targets are specified on the command line, all  default  targets
              are  built, whether or not they are below the current directory.


       --debug=_t_y_p_e
              Debug the build process.  _t_y_p_e specifies what type of debugging:


       --debug=count
              Print  how  many objects are created of the various classes used
              internally by SCons before  and  after  reading  the  SConscript
              files  and  before  and after building targets.  This only works
              when run under Python 2.1 or later.


       --debug=dtree
              Print the dependency tree after each top-level target is  built.
              This prints out only derived files.


       --debug=findlibs
              Instruct the scanner that searches for libraries to print a mes-
              sage about each potential library name it is searching for,  and
              about the actual libraries it finds.


       --debug=includes
              Print  the  include  tree  after each top-level target is built.
              This is generally used to find out what files  are  included  by
              the sources of a given derived file:

              $ scons --debug=includes foo.o


       --debug=memoizer
              Prints  a summary of hits and misses in the Memoizer, the inter-
              nal SCons subsystem for caching various values in memory instead
              of recomputing them each time they're needed.


       --debug=memory
              Prints  how  much memory SCons uses before and after reading the
              SConscript files and before and after building targets.


       --debug=nomemoizer
              Disables use of the Memoizer, the internal SCons  subsystem  for
              caching  various  values  in  memory instead of recomputing them
              each time they're needed.  This provides more accurate counts of
              the underlying function calls in the Python profiler output when
              using the --profile= option.  (When the Memoizer  is  used,  the
              profiler  counts all memoized functions as being executed by the
              Memoizer's wrapper calls.)


       --debug=objects
              Prints a list of the various objects of the various classes used
              internally  by SCons.  This only works when run under Python 2.1
              or later.


       --debug=pdb
              Re-run SCons under the control of the pdb Python debugger.


       --debug=presub
              Print the raw command line used to build each target before  the
              construction  environment variables are substituted.  Also shows
              which targets are being built by  this  command.   Output  looks
              something like this:
              $ scons --debug=presub
              Building myprog.o with action(s):
                $SHCC $SHCCFLAGS $CPPFLAGS $_CPPINCFLAGS -c -o $TARGET $SOURCES


       --debug=stacktrace
              Prints  an internal Python stack trace when encountering an oth-
              erwise unexplained error.


       --debug=stree
              Print the dependency tree along with status  information.   This
              is  the  same  as  the  debug=tree option, but additional status
              information is provided for each node in the tree.


       --debug=time
              Prints various time profiling information: the time  spent  exe-
              cuting  each build command, the total build time, the total time
              spent executing build commands, the total time  spent  executing
              SConstruct  and  SConscript files, and the total time spent exe-
              cuting SCons itself.


       --debug=tree
              Print the dependency tree after each top-level target is  built.
              This  prints out the complete dependency tree including implicit
              dependencies and ignored dependencies.


       --diskcheck=_t_y_p_e_s
              Enable specific checks for whether or not there  is  a  file  on
              disk  where the SCons configuration expects a directory (or vice
              versa), and whether or  not  RCS  or  SCCS  sources  exist  when
              searching  for source and include files.  The _t_y_p_e_s argument can
              be set to: aallll, to enable all  checks  explicitly  (the  default
              behavior);  nnoonnee,  to  disable  all such checks; mmaattcchh, to check
              that files and directories on disk match SCons' expected config-
              uration;  rrccss,  to  check for the existence of an RCS source for
              any missing source or include files;  ssccccss,  to  check  for  the
              existence  of  an  SCCS source for any missing source or include
              files.  Multiple checks can be specified  separated  by  commas;
              for example, ----ddiisskkcchheecckk==ssccccss,,rrccss would still check for SCCS and
              RCS sources, but disable the check for on-disk matches of  files
              and directories.  Disabling some or all of these checks can pro-
              vide a performance boost for large configurations, or  when  the
              configuration  will  check  for  files and/or directories across
              networked or shared file systems, at the slight  increased  risk
              of  an  incorrect build or of not handling errors gracefully (if
              include files really should be found in SCCS or RCS,  for  exam-
              ple,  or  if a file really does exist where the SCons configura-
              tion expects a directory).



       -f _f_i_l_e, --file=_f_i_l_e, --makefile=_f_i_l_e, --sconstruct=_f_i_l_e
              Use _f_i_l_e as the initial SConscript file.


       -h, --help
              Print a local help message for this build, if one is defined  in
              the SConscript file(s), plus a line that describes the --HH option
              for command-line option help.   If  no  local  help  message  is
              defined,  prints  the  standard  help message about command-line
              options.  Exits after displaying the appropriate message.


       -H, --help-options
              Print the standard help message about command-line  options  and
              exit.


       -i, --ignore-errors
              Ignore all errors from commands executed to rebuild files.


       -I _d_i_r_e_c_t_o_r_y, --include-dir=_d_i_r_e_c_t_o_r_y
              Specifies a _d_i_r_e_c_t_o_r_y to search for imported Python modules.  If
              several --II options are used, the directories are searched in the
              order specified.


       --implicit-cache
              Cache  implicit  dependencies.  This  can  cause  ssccoonnss  to miss
              changes in the  implicit  dependencies  in  cases  where  a  new
              implicit  dependency is added earlier in the implicit dependency
              search path (e.g. CPPPATH) than a  current  implicit  dependency
              with the same name.


       --implicit-deps-changed
              Force  SCons  to  ignore  the cached implicit dependencies. This
              causes the implicit dependencies to be rescanned  and  recached.
              This implies ----iimmpplliicciitt--ccaacchhee.


       --implicit-deps-unchanged
              Force  SCons  to  ignore  changes  in the implicit dependencies.
              This causes cached implicit  dependencies  to  always  be  used.
              This implies ----iimmpplliicciitt--ccaacchhee.


       -j _N, --jobs=_N
              Specifies  the  number of jobs (commands) to run simultaneously.
              If there is more than one --jj option, the last one is  effective.


       -k, --keep-going
              Continue  as  much  as possible after an error.  The target that
              failed and those that depend on it will not be remade, but other
              targets specified on the command line will still be processed.



       --duplicate=_O_R_D_E_R
              There  are  three  ways to duplicate files in a build tree: hard
              links, soft (symbolic) links and copies. The  default  behaviour
              of  SCons  is  to prefer hard links to soft links to copies. You
              can specify different behaviours with this option.   _O_R_D_E_R  must
              be  one  of  _h_a_r_d_-_s_o_f_t_-_c_o_p_y (the default), _s_o_f_t_-_h_a_r_d_-_c_o_p_y, _h_a_r_d_-
              _c_o_p_y, _s_o_f_t_-_c_o_p_y or _c_o_p_y.  SCons will attempt to duplicate  files
              using the mechanisms in the specified order.



       -m     Ignored for compatibility with non-GNU versions of mmaakkee.


       --max-drift=_S_E_C_O_N_D_S
              Set the maximum expected drift in the modification time of files
              to _S_E_C_O_N_D_S.  This value determines  how  long  a  file  must  be
              unmodified  before  its  cached  content  signature will be used
              instead of calculating a new content signature (MD5 checksum) of
              the file's contents.  The default value is 2 days, which means a
              file must have a modification time of at least two days  ago  in
              order  to  have  its  cached content signature used.  A negative
              value means to never cache the content signature and  to  ignore
              the  cached value if there already is one. A value of 0 means to
              always use the cached signature, no matter how old the file  is.


       -n, --just-print, --dry-run, --recon
              No  execute.  Print the commands that would be executed to build
              any out-of-date target files, but do not execute the commands.



       --profile=_f_i_l_e
              Run SCons under the Python profiler and save the results in  the
              specified  _f_i_l_e.   The  results may be analyzed using the Python
              pstats module.

       -q, --question
              Do not run any commands, or print anything.  Just return an exit
              status  that  is zero if the specified targets are already up to
              date, non-zero otherwise.

       -Q     Quiets SCons status messages  about  reading  SConscript  files,
              building  targets  and  entering directories.  Commands that are
              executed to rebuild target files are still printed.



       --random
              Build dependencies in a  random  order.   This  is  useful  when
              building  multiple trees simultaneously with caching enabled, to
              prevent multiple builds from simultaneously trying to  build  or
              retrieve the same target files.


       -s, --silent, --quiet
              Silent.  Do not print commands that are executed to rebuild tar-
              get files.  Also suppresses SCons status messages.


       -S, --no-keep-going, --stop
              Ignored for compatibility with GNU mmaakkee.


       -t, --touch
              Ignored for compatibility with GNU mmaakkee.  (Touching  a  file  to
              make it appear up-to-date is unnecessary when using ssccoonnss.)


       -u, --up, --search-up
              Walks  up  the  directory  structure until an _S_C_o_n_s_t_r_u_c_t _, _S_c_o_n_-
              _s_t_r_u_c_t or _s_c_o_n_s_t_r_u_c_t file is found, and uses that as the top  of
              the  directory tree.  If no targets are specified on the command
              line, only targets at or below the  current  directory  will  be
              built.


       -U     Works  exactly  the same way as the --uu option except for the way
              default targets are handled.  When this option is  used  and  no
              targets  are  specified on the command line, all default targets
              that are defined in the SConscript(s) in the  current  directory
              are  built,  regardless  of what directory the resultant targets
              end up in.


       -v, --version
              Print the ssccoonnss version, copyright information, list of authors,
              and any other relevant information.  Then exit.


       -w, --print-directory
              Print  a  message  containing  the  working directory before and
              after other processing.


       --warn=_t_y_p_e, --warn=no-_t_y_p_e
              Enable or disable warnings.  _t_y_p_e specifies the type of warnings
              to be enabled or disabled:


       --warn=all, --warn=no-all
              Enables or disables all warnings.


       --warn=dependency, --warn=no-dependency
              Enables or disables warnings about dependencies.  These warnings
              are disabled by default.


       --warn=deprecated, --warn=no-deprecated
              Enables or disables warnings about use of  deprecated  features.
              These warnings are enabled by default.


       --warn=missing-sconscript, --warn=no-missing-sconscript
              Enables  or  disables  warnings  about missing SConscript files.
              These warnings are enabled by default.


       --no-print-directory
              Turn off -w, even if it was turned on implicitly.



       -Y _r_e_p_o_s_i_t_o_r_y, --repository=_r_e_p_o_s_i_t_o_r_y
              Search the specified repository for any input and  target  files
              not found in the local directory hierarchy.  Multiple --YY options
              may specified, in which case the repositories  are  searched  in
              the order specified.


CCOONNFFIIGGUURRAATTIIOONN FFIILLEE RREEFFEERREENNCCEE
   CCoonnssttrruuccttiioonn EEnnvviirroonnmmeennttss
       A  construction  environment is the basic means by which the SConscript
       files communicate build information to ssccoonnss.  A new construction envi-
       ronment is created using the EEnnvviirroonnmmeenntt function:

              env = Environment()

       By default, a new construction environment is initialized with a set of
       builder methods and construction variables that are appropriate for the
       current platform.  An optional platform keyword argument may be used to
       specify that an environment should be initialized for a different plat-
       form:

              env = Environment(platform = 'cygwin')
              env = Environment(platform = 'os2')
              env = Environment(platform = 'posix')
              env = Environment(platform = 'win32')

       Specifying  a  platform  initializes the appropriate construction vari-
       ables in the environment to use and generate file names  with  prefixes
       and suffixes appropriate for the platform.

       Note  that the wwiinn3322 platform adds the SSYYSSTTEEMMDDRRIIVVEE and SSYYSSTTEEMMRROOOOTT vari-
       ables from the user's external environment to the construction environ-
       ment's  EENNVV dictionary.  This is so that any executed commands that use
       sockets to connect with other systems (such as  fetching  source  files
       from   external  CVS  repository  specifications  like  ::ppsseerrvveerr::aannoonnyy--
       mmoouuss@@ccvvss..ssoouurrcceeffoorrggee..nneett:://ccvvssrroooott//ssccoonnss) will work on Win32 systems.

       The platform argument may be function or callable object, in which case
       the Environment() method will call the specified argument to update the
       new construction environment:

              def my_platform(env):
                  env['VAR'] = 'xyzzy'

              env = Environment(platform = my_platform)

       Additionally, a specific set of tools  with  which  to  initialize  the
       environment may specified as an optional keyword argument:

              env = Environment(tools = ['msvc', 'lex'])

       Non-built-in tools may be specified using the toolpath argument:

              env = Environment(tools = ['default', 'foo'], toolpath = ['tools'])

       This  looks  for a tool specification in tools/foo.py (as well as using
       the ordinary default tools for the platform).  foo.py should  have  two
       functions:  generate(env,  **kw) and exists(env).  The ggeenneerraattee(()) func-
       tion modifies the passed-in environment to set up variables so that the
       tool  can  be  executed; it may use any keyword arguments that the user
       supplies (see below) to vary its initialization.  The eexxiissttss(()) function
       should  return  a  true  value  if the tool is available.  Tools in the
       toolpath are used before any of the built-in ones.  For example, adding
       gcc.py to the toolpath would override the built-in gcc tool.  Also note
       that the toolpath is stored in the environment for use by  later  calls
       to CCooppyy() and TTooooll() methods:

              base = Environment(toolpath=['custom_path'])
              derived = base.Copy(tools=['custom_tool'])
              derived.CustomBuilder()

       The  elements  of  the  tools  list  may  also be functions or callable
       objects, in which case the Environment() method will call the specified
       elements to update the new construction environment:

              def my_tool(env):
                  env['XYZZY'] = 'xyzzy'

              env = Environment(tools = [my_tool])

       The  individual  elements of the tools list may also themselves be two-
       element lists of the form (_t_o_o_l_n_a_m_e, _k_w___d_i_c_t).  SCons searches for  the
       _t_o_o_l_n_a_m_e  specification  file  as  described above, and passes _k_w___d_i_c_t,
       which must be a dictionary, as keyword arguments to the tool's ggeenneerraattee
       function.   The  ggeenneerraattee  function can use the arguments to modify the
       tool's behavior by setting up the environment in different ways or oth-
       erwise changing its initialization.

              # in tools/my_tool.py:
              def generate(env, **kw):
                # Sets MY_TOOL to the value of keyword argument 'arg1' or 1.
                env['MY_TOOL'] = kw.get('arg1', '1')
              def exists(env):
                return 1

              # in SConstruct:
              env = Environment(tools = ['default', ('my_tool', {'arg1': 'abc'})],
                                toolpath=['tools'])

       The tool definition (i.e. my_tool()) can use the PLATFORM variable from
       the environment it receives to customize the tool for  different  plat-
       forms.

       If no tool list is specified, then SCons will auto-detect the installed
       tools using the PATH variable in the ENV construction variable and  the
       platform  name  when  the Environment is constructed. Changing the PATH
       variable after the Environment is constructed will not cause the  tools
       to be redetected.

       SCons supports the following tool specifications out of the box:

              386asm
              aixc++
              aixcc
              aixf77
              aixlink
              ar
              as
              bcc32
              c++
              cc
              cvf
              dmd
              dvipdf
              dvips
              f77
              f90
              f95
              fortran
              g++
              g77
              gas
              gcc
              gnulink
              gs
              hpc++
              hpcc
              hplink
              icc
              icl
              ifl
              ifort
              ilink
              ilink32
              intelc
              jar
              javac
              javah
              latex
              lex
              link
              linkloc
              m4
              masm
              midl
              mingw
              mslib
              mslink
              msvc
              msvs
              mwcc
              mwld
              nasm
              pdflatex
              pdftex
              qt
              rmic
              rpcgen
              sgiar
              sgic++
              sgicc
              sgilink
              sunar
              sunc++
              suncc
              sunlink
              swig
              tar
              tex
              tlib
              yacc
              zip

       Additionally,  there  is  a  "tool"  named ddeeffaauulltt which configures the
       environment with a default set of tools for the current platform.

       On posix and cygwin platforms the GNU tools (e.g. gcc) are preferred by
       SCons,  on  win32 the Microsoft tools (e.g. msvc) followed by MinGW are
       preferred by SCons, and in OS/2 the IBM tools (e.g. icc) are  preferred
       by SCons.


   BBuuiillddeerr MMeetthhooddss
       Build  rules  are  specified  by  calling  a construction environment's
       builder methods.  The arguments to the builder methods  are  ttaarrggeett  (a
       list of target files) and ssoouurrccee (a list of source files).

       Because  long  lists  of file names can lead to a lot of quoting, ssccoonnss
       supplies a SSpplliitt(()) global function and a same-named environment  method
       that  split a single string into a list, separated on strings of white-
       space characters.  (These are similar to the string.split() method from
       the  standard  Python  library,  but  work  even  if  the input isn't a
       string.)

       Like all Python arguments, the target and source arguments to a builder
       method  can  be  specified  either  with  or  without  the "target" and
       "source" keywords.  When the keywords are omitted, the target is first,
       followed by the source.  The following are equivalent examples of call-
       ing the Program builder method:

              env.Program('bar', ['bar.c', 'foo.c'])
              env.Program('bar', Split('bar.c foo.c'))
              env.Program('bar', env.Split('bar.c foo.c'))
              env.Program(source =  ['bar.c', 'foo.c'], target = 'bar')
              env.Program(target = 'bar', Split('bar.c foo.c'))
              env.Program(target = 'bar', env.Split('bar.c foo.c'))
              env.Program('bar', source = string.split('bar.c foo.c'))

       When the target shares the same base name as the source  and  only  the
       suffix  varies,  and if the builder method has a suffix defined for the
       target file type, then the target argument may be  omitted  completely,
       and  ssccoonnss  will deduce the target file name from the source file name.
       The following examples all build the executable program bbaarr  (on  POSIX
       systems) or bbaarr..eexxee (on Windows systems) from the bar.c source file:

              env.Program(target = 'bar', source = 'bar.c')
              env.Program('bar', source = 'bar.c')
              env.Program(source = 'bar.c')
              env.Program('bar.c')

       It is possible to override or add construction variables when calling a
       builder method by passing additional keyword arguments.  These overrid-
       den or added variables will only be in effect when building the target,
       so they will not affect other parts of the build. For example,  if  you
       want to add additional libraries for just one program:

              env.Program('hello', 'hello.c', LIBS=['gl', 'glut'])

       or generate a shared library with a nonstandard suffix:

              env.SharedLibrary('word', 'word.cpp', SHLIBSUFFIX='.ocx')

       Although  the builder methods defined by ssccoonnss are, in fact, methods of
       a construction environment object, they may also be called  without  an
       explicit environment:

              Program('hello', 'hello.c')
              SharedLibrary('word', 'word.cpp')

       In  this  case,  the methods are called internally using a default con-
       struction environment that consists of the tools and values that  ssccoonnss
       has determined are appropriate for the local system.

       Builder  methods that can be called without an explicit environment may
       be called from custom Python modules that you import into an SConscript
       file by adding the following to the Python module:

              from SCons.Script import *

       All builder methods return a list of Nodes that represent the target or
       targets that will be built.  A _N_o_d_e is an internal SCons  object  which
       represents build targets or sources.

       The  returned  Node(s)  can  be  passed  to  other  builder  methods as
       source(s) or passed to any SCons function or method  where  a  filename
       would normally be accepted.  For example, if it were necessary to add a
       specific --DD flag when compiling one specific object file:

              bar_obj_list = env.StaticObject('bar.c', CPPDEFINES='-DBAR')
              env.Program(source = ['foo.c', bar_obj_list, 'main.c'])

       Using a Node in this way makes for a more portable  build  by  avoiding
       having  to  specify  a platform-specific object suffix when calling the
       Program() builder method.

       Note that Builder calls will automatically  "flatten"  the  source  and
       target file lists, so it's all right to have the bar_obj list return by
       the StaticObject() call in the middle of the source file list.  If  you
       need  to manipulate a list of lists returned by Builders directly using
       Python, you can either build the list by hand:

              foo = Object('foo.c')
              bar = Object('bar.c')
              objects = ['begin.o'] + foo + ['middle.o'] + bar + ['end.o']
              for object in objects:
                  print str(object)

       Or you can use the FFllaatttteenn() supplied by scons to create  a  list  con-
       taining just the Nodes, which may be more convenient:

              foo = Object('foo.c')
              bar = Object('bar.c')
              objects = Flatten(['begin.o', foo, 'middle.o', bar, 'end.o'])
              for object in objects:
                  print str(object)

       The  path name for a Node's file may be used by passing the Node to the
       Python-builtin ssttrr(()) function:

              bar_obj_list = env.StaticObject('bar.c', CPPDEFINES='-DBAR')
              print "The path to bar_obj is:", str(bar_obj_list[0])

       Note again that because the Builder call returns a  list,  we  have  to
       access  the  first  element in the list ((bbaarr__oobbjj__lliisstt[[00]])) to get at the
       Node that actually represents the object file.

       Builder calls support a cchhddiirr keyword argument that specifies that  the
       Builder's  action(s)  should  be executed after changing directory.  If
       the cchhddiirr argument is a string or a directory Node, scons  will  change
       to  the  specified directory.  If the cchhddiirr is not a string or Node and
       is non-zero, then scons will change to the target file's directory.

              # scons will change to the "sub" subdirectory
              # before executing the "cp" command.
              env.Command('sub/dir/foo.out', 'sub/dir/foo.in',
                          "cp dir/foo.in dir/foo.out",
                          chdir='sub')

              # Because chdir is not a string, scons will change to the
              # target's directory ("sub/dir") before executing the
              # "cp" command.
              env.Command('sub/dir/foo.out', 'sub/dir/foo.in',
                          "cp foo.in foo.out",
                          chdir=1)

       Note that scons will _n_o_t automatically modify  its  expansion  of  con-
       struction  variables like $$TTAARRGGEETT and $$SSOOUURRCCEE when using the chdir key-
       word argument--that is, the expanded file names will still be  relative
       to the top-level SConstruct directory, and consequently incorrect rela-
       tive to the chdir directory.  If you use the  chdir  keyword  argument,
       you will typically need to supply a different command line using expan-
       sions like $${{TTAARRGGEETT..ffiillee}} and $${{SSOOUURRCCEE..ffiillee}} to use just  the  filename
       portion of the targets and source.

       ssccoonnss provides the following builder methods:


       CFile()

       env.CFile()
              Builds a C source file given a lex (.l) or yacc (.y) input file.
              The suffix specified by the $CFILESUFFIX  construction  variable
              (.c  by  default)  is automatically added to the target if it is
              not already present. Example:

              # builds foo.c
              env.CFile(target = 'foo.c', source = 'foo.l')
              # builds bar.c
              env.CFile(target = 'bar', source = 'bar.y')


       CXXFile()

       env.CXXFile()
              Builds a C++ source file given a lex (.ll) or yacc  (.yy)  input
              file.   The  suffix specified by the $CXXFILESUFFIX construction
              variable (.cc by default) is automatically added to  the  target
              if it is not already present. Example:

              # builds foo.cc
              env.CXXFile(target = 'foo.cc', source = 'foo.ll')
              # builds bar.cc
              env.CXXFile(target = 'bar', source = 'bar.yy')


       DVI()

       env.DVI()
              Builds  a  .dvi file from a .tex, .ltx or .latex input file.  If
              the source file suffix is .tex, ssccoonnss will examine the  contents
              of  the  file;  if  the  string  ooccuummeennttccllaassss or ooccuummeennttssttyyllee is
              found, the file is assumed to be a LaTeX file and the target  is
              built  by  invoking  the  $LATEXCOM command line; otherwise, the
              $TEXCOM command line is used.  If the file is a LaTeX file,  the
              DDVVII  builder  method  will also examine the contents of the ..aauuxx
              ffiillee and invoke the $BIBTEX command line if the  string  bbiibbddaattaa
              is found, and will examine the contents ..lloogg file and re-run the
              $LATEXCOM command if the log file says it is necessary.

              The suffix .dvi (hard-coded within TeX itself) is  automatically
              added to the target if it is not already present. Examples:

              # builds from aaa.tex
              env.DVI(target = 'aaa.dvi', source = 'aaa.tex')
              # builds bbb.dvi
              env.DVI(target = 'bbb', source = 'bbb.ltx')
              # builds from ccc.latex
              env.DVI(target = 'ccc.dvi', source = 'ccc.latex')


       Jar()

       env.Jar()
              Builds  a  Java archive (.jar) file from a source tree of .class
              files.  If the $JARCHDIR value is  set,  the  jjaarr  command  will
              change  to  the specified directory using the --CC option.  If the
              contents any of the source files begin with the string MMaanniiffeesstt--
              VVeerrssiioonn,  the  file is assumed to be a manifest and is passed to
              the jjaarr command with the mm option set.

              env.Jar(target = 'foo.jar', source = 'classes')


       Java()

       env.Java()
              Builds one or more Java class files  from  one  or  more  source
              trees of .java files.  The class files will be placed underneath
              the specified target directory.  SCons will  parse  each  source
              .java file to find the classes (including inner classes) defined
              within that file, and from that figure  out  the  target  .class
              files  that  will  be created.  SCons will also search each Java
              file for the Java package name, which it assumes can be found on
              a  line  beginning  with the string ppaacckkaaggee in the first column;
              the resulting  .class  files  will  be  placed  in  a  directory
              reflecting  the  specified  package name.  For example, the file
              _F_o_o_._j_a_v_a defining a single public _F_o_o  class  and  containing  a
              package   name   of   _s_u_b_._d_i_r   will  generate  a  corresponding
              _s_u_b_/_d_i_r_/_F_o_o_._c_l_a_s_s class file.

              Example:

              env.Java(target = 'classes', source = 'src')
              env.Java(target = 'classes', source = ['src1', 'src2'])


       JavaH()

       env.JavaH()
              Builds C header and source files for  implementing  Java  native
              methods.   The  target  can  be  either a directory in which the
              header files will be written, or a header file name  which  will
              contain  all  of  the definitions.  The source can be either the
              names of .class files, or the objects  returned  from  the  JJaavvaa
              builder method.

              If  the construction variable JJAAVVAACCLLAASSSSDDIIRR is set, either in the
              environment or in the call to the JJaavvaaHH builder  method  itself,
              then  the value of the variable will be stripped from the begin-
              ning of any .class file names.

              Examples:

              # builds java_native.h
              classes = env.Java(target = 'classdir', source = 'src')
              env.JavaH(target = 'java_native.h', source = classes)

              # builds include/package_foo.h and include/package_bar.h
              env.JavaH(target = 'include',
                        source = ['package/foo.class', 'package/bar.class'])

              # builds export/foo.h and export/bar.h
              env.JavaH(target = 'export',
                        source = ['classes/foo.class', 'classes/bar.class'],
                        JAVACLASSDIR = 'classes')


       Library()

       env.Library()
              A synonym for the SSttaattiiccLLiibbrraarryy builder method.


       LoadableModule()

       env.LoadableModule()
              On most systems, this is the same as SShhaarreeddLLiibbrraarryy().  On Mac OS
              X (Darwin) platforms, this creates a loadable module bundle.



       M4()

       env.M4()
              Builds  an  output  file  from  an  M4  input file.  This uses a
              default $M4FLAGS value of --EE, which considers all warnings to be
              fatal  and stops on the first warning when using the GNU version
              of m4.  Example:

              env.M4(target = 'foo.c', source = 'foo.c.m4')


       Moc()

       env.Moc()
              Builds an output file from a moc input file. Moc input files are
              either header files or cxx files. This builder is only available
              after using the tool 'qt'.  See  the  QTDIR  variable  for  more
              information.  Example:

              env.Moc('foo.h') # generates moc_foo.cc
              env.Moc('foo.cpp') # generates foo.moc


       MSVSProject()

       env.MSVSProject()
              Builds  Microsoft  Visual  Studio  project files.  This builds a
              Visual Studio project file, based on the version of Visual  Stu-
              dio  that is configured (either the latest installed version, or
              the version set by MMSSVVSS__VVEERRSSIIOONN in the Environment constructor).
              For  VS  6,  it  will generate ..ddsspp and ..ddssww files, for VS 7, it
              will generate ..vvccpprroojj and ..ssllnn files.

              It takes several lists  of  filenames  to  be  placed  into  the
              project  file, currently these are limited to ssrrccss,, iinnccss,, llooccaall--
              iinnccss,, rreessoouurrcceess,, and mmiisscc..  These are pretty  self  explanatory,
              but  it should be noted that the 'srcs' list is NOT added to the
              $SOURCES environment variable.  This is because it represents  a
              list  of  files  to be added to the project file, not the source
              used to build the project file (in this case,  the  'source'  is
              the SConscript file used to call MSVSProject).

              In  addition  to  these values (which are all optional, although
              not specifying any of them results in an  empty  project  file),
              the following values must be specified:

              target:  The  name of the target .dsp or .vcproj file.  The cor-
              rect suffix for the version of Visual Studio must be  used,  but
              the value

              env['MSVSPROJECTSUFFIX']

              will be defined to the correct value (see example below).

              variant:  The  name of this particular variant.  These are typi-
              cally things like "Debug" or "Release", but really can  be  any-
              thing  you  want.   Multiple calls to MSVSProject with different
              variants are allowed: all variants will be added to the  project
              file with their appropriate build targets and sources.

              buildtarget:  A  list of SCons.Node.FS objects which is returned
              from the command which builds the target.  This is used to  tell
              SCons what to build when the 'build' button is pressed inside of
              the IDE.

              Example Usage:

                      barsrcs = ['bar.cpp'],
                      barincs = ['bar.h'],
                      barlocalincs = ['StdAfx.h']
                      barresources = ['bar.rc','resource.h']
                      barmisc = ['bar_readme.txt']

                      dll = local.SharedLibrary(target = 'bar.dll',
                                                source = barsrcs)

                      local.MSVSProject(target = 'Bar' + env['MSVSPROJECTSUFFIX'],
                                        srcs = barsrcs,
                                        incs = barincs,
                                        localincs = barlocalincs,
                                        resources = barresources,
                                        misc = barmisc,
                                        buildtarget = dll,
                                        variant = 'Release')


       Object()

       env.Object()
              A synonym for the SSttaattiiccOObbjjeecctt builder method.


       PCH()

       env.PCH()
              Builds a Microsoft Visual C++ precompiled header.  Calling  this
              builder  method  returns  a  list of two targets: the PCH as the
              first element, and the object file as the second  element.  Nor-
              mally  the  object file is ignored.  This builder method is only
              provided when Microsoft Visual C++ is being  used  as  the  com-
              piler.   The  PCH builder method is generally used in conjuction
              with the PCH construction variable to force object files to  use
              the precompiled header:

              env['PCH'] = env.PCH('StdAfx.cpp')[0]


       PDF()

       env.PDF()
              Builds  a  .pdf file from a .dvi input file (or, by extension, a
              .tex, .ltx, or .latex input file).  The suffix specified by  the
              $PDFSUFFIX  construction  variable  (.pdf  by  default) is added
              automatically to the target if it is not already present.  Exam-
              ple:

              # builds from aaa.tex
              env.PDF(target = 'aaa.pdf', source = 'aaa.tex')
              # builds bbb.pdf from bbb.dvi
              env.PDF(target = 'bbb', source = 'bbb.dvi')


       PostScript()

       env.PostScript()
              Builds  a  .ps  file from a .dvi input file (or, by extension, a
              .tex, .ltx, or .latex input file).  The suffix specified by  the
              $PSSUFFIX  construction variable (.ps by default) is added auto-
              matically to the target if it is not already present.  Example:

              # builds from aaa.tex
              env.PostScript(target = 'aaa.ps', source = 'aaa.tex')
              # builds bbb.ps from bbb.dvi
              env.PostScript(target = 'bbb', source = 'bbb.dvi')


       Program()

       env.Program()
              Builds an executable given one or more object files or  C,  C++,
              D,  or Fortran source files.  If any C, C++, D or Fortran source
              files are specified, then they will be automatically compiled to
              object  files  using the OObbjjeecctt builder method; see that builder
              method's description for a list of legal  source  file  suffixes
              and how they are interpreted.  The target executable file prefix
              (specified by the $PROGPREFIX construction variable; nothing  by
              default)  and  suffix (specified by the $PROGSUFFIX construction
              variable; by default, .exe on Windows systems, nothing on  POSIX
              systems)  are  automatically  added to the target if not already
              present.  Example:

              env.Program(target = 'foo', source = ['foo.o', 'bar.c', 'baz.f'])


       RES()

       env.RES()
              Builds a Microsoft  Visual  C++  resource  file.   This  builder
              method  is  only  provided when Microsoft Visual C++ or MinGW is
              being used as the compiler. The _._r_e_s (or _._o for MinGW) suffix is
              added to the target name if no other suffix is given. The source
              file is scanned for implicit dependencies as though it were a  C
              file. Example:

              env.RES('resource.rc')


       RMIC()

       env.RMIC()
              Builds  stub  and  skeleton  class files for remote objects from
              Java .class files.  The target is a directory relative to  which
              the  stub  and skeleton class files will be written.  The source
              can be the names of .class files, or the objects return from the
              JJaavvaa builder method.

              If  the construction variable JJAAVVAACCLLAASSSSDDIIRR is set, either in the
              environment or in the call to the RRMMIICC  builder  method  itself,
              then  the value of the variable will be stripped from the begin-
              ning of any .class file names.

              classes = env.Java(target = 'classdir', source = 'src')
              env.RMIC(target = 'outdir1', source = classes)

              env.RMIC(target = 'outdir2',
                       source = ['package/foo.class', 'package/bar.class'])

              env.RMIC(target = 'outdir3',
                       source = ['classes/foo.class', 'classes/bar.class'],
                       JAVACLASSDIR = 'classes')


       RPCGenClient()

       env.RPCGenClient()
              Generates an RPC client stub (_clnt.c) file from a specified RPC
              (.x)  source  file.   Because rpcgen only builds output files in
              the local directory, the command will be executed in the  source
              file's directory by default.

              # Builds src/rpcif_clnt.c
              env.RPCGenClient('src/rpcif.x')


       RPCGenHeader()

       env.RPCGenHeader()
              Generates  an  RPC  header  (.h)  file from a specified RPC (.x)
              source file.  Because rpcgen only builds  output  files  in  the
              local  directory,  the  command  will  be executed in the source
              file's directory by default.

              # Builds src/rpcif.h
              env.RPCGenHeader('src/rpcif.x')


       RPCGenService()

       env.RPCGenService()
              Generates an RPC server-skeleton (_svc.c) file from a  specified
              RPC  (.x)  source file.  Because rpcgen only builds output files
              in the local directory, the command  will  be  executed  in  the
              source file's directory by default.

              # Builds src/rpcif_svc.c
              env.RPCGenClient('src/rpcif.x')


       RPCGenXDR()

       env.RPCGenXDR()
              Generates  an RPC XDR routine (_xdr.c) file from a specified RPC
              (.x) source file.  Because rpcgen only builds  output  files  in
              the  local directory, the command will be executed in the source
              file's directory by default.

              # Builds src/rpcif_xdr.c
              env.RPCGenClient('src/rpcif.x')


       SharedLibrary()

       env.SharedLibrary()
              Builds a shared library (.so on a POSIX system, .dll  on  WIN32)
              given  one  or  more object files or C, C++, D or Fortran source
              files.  If any source files are given, then they will  be  auto-
              matically  compiled  to object files.  The static library prefix
              and suffix (if any) are automatically added to the target.   The
              target  library  file prefix (specified by the $SHLIBPREFIX con-
              struction variable; by default, lib on POSIX systems, nothing on
              Windows  systems) and suffix (specified by the $SHLIBSUFFIX con-
              struction variable; by default, .dll on Windows systems, .so  on
              POSIX  systems)  are  automatically  added  to the target if not
              already present.  Example:

              env.SharedLibrary(target = 'bar', source = ['bar.c', 'foo.o'])

              On WIN32 systems, the SShhaarreeddLLiibbrraarryy builder method  will  always
              build  an import (.lib) library in addition to the shared (.dll)
              library, adding a .lib library with the same basename  if  there
              is not already a .lib file explicitly listed in the targets.

              Any object files listed in the ssoouurrccee must have been built for a
              shared library (that is, using the SShhaarreeddOObbjjeecctt builder method).
              ssccoonnss will raise an error if there is any mismatch.

              On  WIN32 systems, specifying "register=1" will cause the dll to
              be registered after it is built  using  REGSVR32.   The  command
              that  is  run  ("regsvr32"  by default) is determined by $REGSVR
              construction variable, and the flags passed  are  determined  by
              $REGSVRFLAGS.   By  default, $REGSVRFLAGS includes "/s", to pre-
              vent dialogs from popping up and requiring user  attention  when
              it is run.  If you change $REGSVRFLAGS, be sure to include "/s".
              For example,

              env.SharedLibrary(target = 'bar',
                                source = ['bar.cxx', 'foo.obj'],
                                register=1)


              will register "bar.dll" as a COM object when it is done  linking
              it.


       SharedObject()

       env.SharedObject()
              Builds an object file for inclusion in a shared library.  Source
              files must have one of the  same  set  of  extensions  specified
              above  for  the  SSttaattiiccOObbjjeecctt builder method.  On some platforms
              building a shared object requires  additional  compiler  options
              (e.g. -fPIC for gcc) in addition to those needed to build a nor-
              mal (static) object, but on some platforms there is  no  differ-
              ence  between  a  shared  object and a normal (static) one. When
              there is a difference, SCons will only allow shared  objects  to
              be linked into a shared library, and will use a different suffix
              for shared objects. On platforms where there is  no  difference,
              SCons  will  allow both normal (static) and shared objects to be
              linked into a shared library, and will use the same  suffix  for
              shared and normal (static) objects.  The target object file pre-
              fix (specified by the  $SHOBJPREFIX  construction  variable;  by
              default,  the  same  as $OBJPREFIX) and suffix (specified by the
              $SHOBJSUFFIX construction variable) are automatically  added  to
              the target if not already present.  Examples:

              env.SharedObject(target = 'ddd', source = 'ddd.c')
              env.SharedObject(target = 'eee.o', source = 'eee.cpp')
              env.SharedObject(target = 'fff.obj', source = 'fff.for')

       Note that the source files will be scanned according to the suffix map-
       pings in SSoouurrcceeFFiilleeSSccaannnneerr object.  See the section "Scanner  Objects,"
       below, for a more information.


       StaticLibrary()

       env.StaticLibrary()
              Builds  a  static  library  given one or more object files or C,
              C++, D or Fortran source files.  If any source files are  given,
              then  they  will be automatically compiled to object files.  The
              static library prefix and  suffix  (if  any)  are  automatically
              added  to the target.  The target library file prefix (specified
              by the $LIBPREFIX construction  variable;  by  default,  lib  on
              POSIX systems, nothing on Windows systems) and suffix (specified
              by the $LIBSUFFIX construction variable;  by  default,  .lib  on
              Windows systems, .a on POSIX systems) are automatically added to
              the target if not already present.  Example:

              env.StaticLibrary(target = 'bar', source = ['bar.c', 'foo.o'])


              Any object files listed in the ssoouurrccee must have been built for a
              static library (that is, using the SSttaattiiccOObbjjeecctt builder method).
              ssccoonnss will raise an error if there is any mismatch.


       StaticObject()

       env.StaticObject()
              Builds a static object file from one or more C, C++, D, or  For-
              tran  source files.  Source files must have one of the following
              extensions:

                .asm    assembly language file
                .ASM    assembly language file
                .c      C file
                .C      WIN32:  C file
                        POSIX:  C++ file
                .cc     C++ file
                .cpp    C++ file
                .cxx    C++ file
                .cxx    C++ file
                .c++    C++ file
                .C++    C++ file
                .d      D file
                .f      Fortran file
                .F      WIN32:  Fortran file
                        POSIX:  Fortran file + C pre-processor
                .for    Fortran file
                .FOR    Fortran file
                .fpp    Fortran file + C pre-processor
                .FPP    Fortran file + C pre-processor
                .m      Objective C file
                .mm     Objective C++ file
                .s      assembly language file
                .S      WIN32:  assembly language file
                        POSIX:  assembly language file + C pre-processor
                .spp    assembly language file + C pre-processor
                .SPP    assembly language file + C pre-processor

              The target object file prefix (specified by the $OBJPREFIX  con-
              struction variable; nothing by default) and suffix (specified by
              the $OBJSUFFIX construction variable; are automatically added to
              the target if not already present.  Examples:

              env.StaticObject(target = 'aaa', source = 'aaa.c')
              env.StaticObject(target = 'bbb.o', source = 'bbb.c++')
              env.StaticObject(target = 'ccc.obj', source = 'ccc.f')

       Note  that  the  source  files  will be scanned according to the suffix
       mappings  in  SSoouurrcceeFFiilleeSSccaannnneerr  object.   See  the  section   "Scanner
       Objects," below, for a more information.


       Tar()

       env.Tar()
              Builds  a tar archive of the specified files and/or directories.
              Unlike most builder methods,  the  TTaarr  builder  method  may  be
              called  multiple  times for a given target; each additional call
              adds to the list of entries that will be built into the archive.
              Any  source  directories  will be scanned for changes to any on-
              disk files, regardless of whether or not ssccoonnss knows about  them
              from other Builder or function calls.

              env.Tar('src.tar', 'src')

              # Create the stuff.tar file.
              env.Tar('stuff', ['subdir1', 'subdir2'])
              # Also add "another" to the stuff.tar file.
              env.Tar('stuff', 'another')

              # Set TARFLAGS to create a gzip-filtered archive.
              env = Environment(TARFLAGS = '-c -z')
              env.Tar('foo.tar.gz', 'foo')

              # Also set the suffix to .tgz.
              env = Environment(TARFLAGS = '-c -z',
                                TARSUFFIX = '.tgz')
              env.Tar('foo')


       TypeLibrary()

       env.TypeLibrary()
              Builds  a  Windows  type  library (.tlb) file from and input IDL
              file (.idl).  In addition, it will build the associated inteface
              stub  and  proxy  source  files.  It names them according to the
              base name of the .idl file.

              For example,

              env.TypeLibrary(source="foo.idl")

              Will create foo.tlb, foo.h, foo_i.c, foo_p.c, and foo_data.c.


       Uic()

       env.Uic()
              Builds a header file, an implementation file and a moc file from
              an  ui  file.   and returns the corresponding nodes in the above
              order.  This builder is only  available  after  using  the  tool
              'qt'.  Note:  you  can  specify .ui files directly as inputs for
              Program, Library and SharedLibrary without using  this  builder.
              Using  the builder lets you override the standard naming conven-
              tions (be careful: prefixes are always  prepended  to  names  of
              built  files;  if  you  don't want prefixes, you may set them to
              ``).  See the QTDIR variable for more information.  Example:

              env.Uic('foo.ui') # -> ['foo.h', 'uic_foo.cc', 'moc_foo.cc']
              env.Uic(target = Split('include/foo.h gen/uicfoo.cc gen/mocfoo.cc'),
                      source = 'foo.ui') # -> ['include/foo.h', 'gen/uicfoo.cc', 'gen/mocfoo.cc']


       Zip()

       env.Zip()
              Builds a zip archive of the specified files and/or  directories.
              Unlike  most  builder  methods,  the  ZZiipp  builder method may be
              called multiple times for a given target; each  additional  call
              adds to the list of entries that will be built into the archive.
              Any source directories will be scanned for changes  to  any  on-
              disk  files, regardless of whether or not ssccoonnss knows about them
              from other Builder or function calls.

              env.Zip('src.zip', 'src')

              # Create the stuff.zip file.
              env.Zip('stuff', ['subdir1', 'subdir2'])
              # Also add "another" to the stuff.tar file.
              env.Zip('stuff', 'another')

       All targets of builder methods automatically depend on  their  sources.
       An  explicit  dependency can be specified using the DDeeppeennddss method of a
       construction environment (see below).

       In addition, ssccoonnss automatically scans source files  for  various  pro-
       gramming  languages,  so  the  dependencies do not need to be specified
       explicitly.  By default, SCons can C source files,  C++  source  files,
       Fortran  source  files with ..FF (POSIX systems only), ..ffpppp,, or ..FFPPPP file
       extensions, and assembly language files with ..SS (POSIX  systems  only),
       ..sspppp,,  or ..SSPPPP files extensions for C preprocessor dependencies.  SCons
       also has default support for scanning D  source  files,  You  can  also
       write  your  own  Scanners  to  add  support for additional source file
       types.  These can be added to the default Scanner object  used  by  the
       OObbjjeecctt()  SSttaattiiccOObbjjeecctt()  and SShhaarreeddOObbjjeecctt() Builders by adding them to
       the SSoouurrcceeFFiilleeSSccaannnneerr object as follows:

       See the section "Scanner Objects," below, for a more information  about
       defining your own Scanner objects.


   MMeetthhooddss aanndd FFuunnccttiioonnss ttoo DDoo TThhiinnggss
       In  addition  to Builder methods, ssccoonnss provides a number of other con-
       struction environment methods and global functions  to  manipulate  the
       build configuration.

       Usually, a construction environment method and global function with the
       same name both exist so that you don't have to remember  whether  to  a
       specific  bit  of  functionality  must be called with or without a con-
       struction environment.  In the following list, if you call something as
       a global function it looks like:
              Function(_a_r_g_u_m_e_n_t_s)
       and  if  you call something through a construction environment it looks
       like:
              env.Function(_a_r_g_u_m_e_n_t_s)
       If you can call the functionality in both ways,  then  both  forms  are
       listed.

       Global  functions  may  be  called  from custom Python modules that you
       import into an SConscript file by adding the following  to  the  Python
       module:

              from SCons.Script import *

       Except  where  otherwise noted, the same-named construction environment
       method and global function provide the exact same  functionality.   The
       only  difference  is that, where appropriate, calling the functionality
       through a construction environment will substitute  construction  vari-
       ables into any supplied strings.  For example:
              env = Environment(FOO = 'foo')
              Default('$FOO')
              env.Default('$FOO')
       the  first  call  to  the global DDeeffaauulltt(()) function will actually add a
       target named $$FFOOOO to the list of default targets, while the second call
       to  the  eennvv..DDeeffaauulltt(())  construction environment method will expand the
       value and add a target named ffoooo to the list of default  targets.   For
       more  on  construction variable expansion, see the next section on con-
       struction variables.

       Construction environment methods  and  global  functions  supported  by
       ssccoonnss include:


       Action(_a_c_t_i_o_n, [_s_t_r_f_u_n_c_t_i_o_n, _v_a_r_l_i_s_t])

       env.Action(_a_c_t_i_o_n, [_s_t_r_f_u_n_c_t_i_o_n, _v_a_r_l_i_s_t])
              Creates an Action object for the specified _a_c_t_i_o_n.  See the sec-
              tion "Action Objects," below, for a complete explanation of  the
              arguments and behavior.


       AddPostAction(_t_a_r_g_e_t, _a_c_t_i_o_n)

       env.AddPostAction(_t_a_r_g_e_t, _a_c_t_i_o_n)
              Arranges  for  the  specified  _a_c_t_i_o_n  to be performed after the
              specified _t_a_r_g_e_t has been built.  The specified action(s) may be
              an  Action  object,  or  anything  that can be converted into an
              Action object (see below).


       AddPreAction(_t_a_r_g_e_t, _a_c_t_i_o_n)

       env.AddPreAction(_t_a_r_g_e_t, _a_c_t_i_o_n)
              Arranges for the specified _a_c_t_i_o_n to  be  performed  before  the
              specified  _t_a_r_g_e_t  is  built.  The specified action(s) may be an
              Action object, or anything that can be converted into an  Action
              object (see below).


       Alias(_a_l_i_a_s, [_t_a_r_g_e_t_s, [_a_c_t_i_o_n]])

       env.Alias(_a_l_i_a_s, [_t_a_r_g_e_t_s, [_a_c_t_i_o_n]])
              Creates  one  or  more  phony targets that expand to one or more
              other targets.  An optional _a_c_t_i_o_n (command) or list of  actions
              can  be  specified that will be executed whenever the any of the
              alias targets are out-of-date.  Returns the Node  object  repre-
              senting  the  alias,  which  exists  outside of any file system.
              This Node object, or the alias name, may be used as a dependency
              of  any  other  target,  including  another alias.  AAlliiaass can be
              called multiple times for the same alias to add additional  tar-
              gets  to  the  alias, or additional actions to the list for this
              alias.

              Alias('install')
              Alias('install', '/usr/bin')
              Alias(['install', 'install-lib'], '/usr/local/lib')

              env.Alias('install', ['/usr/local/bin', '/usr/local/lib'])
              env.Alias('install', ['/usr/local/man'])

              env.Alias('update', ['file1', 'file2'], "update_database $SOURCES")


       AlwaysBuild(_t_a_r_g_e_t, ...)

       env.AlwaysBuild(_t_a_r_g_e_t, ...)
              Marks each given _t_a_r_g_e_t so that it is always assumed to  be  out
              of  date,  and will always be rebuilt if needed.  Note, however,
              that AAllwwaayyssBBuuiilldd() does not add its  target(s)  to  the  default
              target list, so the targets will only be built if they are spec-
              ified on the command line, or are a dependent of a target speci-
              fied  on  the  command line--but they will _a_l_w_a_y_s be built if so
              specified.  Multiple targets can be passed in to a  single  call
              to AAllwwaayyssBBuuiilldd().


       env.Append(_k_e_y=_v_a_l, [...])
              Appends  the specified keyword arguments to the end of construc-
              tion variables in the environment.  If the Environment does  not
              have  the specified construction variable, it is simply added to
              the environment.  If the values of the construction variable and
              the keyword argument are the same type, then the two values will
              be simply added together.  Otherwise, the construction  variable
              and the value of the keyword argument are both coerced to lists,
              and the lists are added together.  (See also the Prepend method,
              below.)

              env.Append(CCFLAGS = ' -g', FOO = ['foo.yyy'])


       env.AppendENVPath(_n_a_m_e, _n_e_w_p_a_t_h, [_e_n_v_n_a_m_e, _s_e_p])
              This  appends  new path elements to the given path in the speci-
              fied external environment (EENNVV by default).  This will only  add
              any particular path once (leaving the last one it encounters and
              ignoring the rest, to preserve path order), and to  help  assure
              this,  will  normalize  all  paths  (using  ooss..ppaatthh..nnoorrmmppaatthh and
              ooss..ppaatthh..nnoorrmmccaassee).  This can also  handle  the  case  where  the
              given  old path variable is a list instead of a string, in which
              case a list will be returned instead of a string.  Example:

              print 'before:',env['ENV']['INCLUDE']
              include_path = '/foo/bar:/foo'
              env.AppendENVPath('INCLUDE', include_path)
              print 'after:',env['ENV']['INCLUDE']

              yields:
              before: /foo:/biz
              after: /biz:/foo/bar:/foo


       env.AppendUnique(_k_e_y=_v_a_l, [...])
              Appends the specified keyword arguments to the end of  construc-
              tion  variables in the environment.  If the Environment does not
              have the specified construction variable, it is simply added  to
              the environment.  If the construction variable being appended to
              is a list, then any value(s) that already exist in the construc-
              tion variable will _n_o_t be added again to the list.

              env.AppendUnique(CCFLAGS = '-g', FOO = ['foo.yyy'])


       env.BitKeeper()
              A  factory  function that returns a Builder object to be used to
              fetch source files using BitKeeper.   The  returned  Builder  is
              intended to be passed to the SSoouurrcceeCCooddee function.

              env.SourceCode('.', env.BitKeeper())


       BuildDir(_b_u_i_l_d___d_i_r, _s_r_c___d_i_r, [_d_u_p_l_i_c_a_t_e])

       env.BuildDir(_b_u_i_l_d___d_i_r, _s_r_c___d_i_r, [_d_u_p_l_i_c_a_t_e])
              This specifies a build directory _b_u_i_l_d___d_i_r in which to build all
              derived files that would normally be built under _s_r_c___d_i_r.   Mul-
              tiple  build  directories can be set up for multiple build vari-
              ants, for example.  _s_r_c___d_i_r must be  underneath  the  SConstruct
              file's  directory,  and  _b_u_i_l_d___d_i_r  may  not  be  underneath the
              _s_r_c___d_i_r _.

              The default behavior is for ssccoonnss to duplicate all of the  files
              in  the  tree  underneath _s_r_c___d_i_r into _b_u_i_l_d___d_i_r, and then build
              the derived files within the copied tree.  (The  duplication  is
              performed  by linking or copying, depending on the platform; see
              also the _-_-_d_u_p_l_i_c_a_t_e option.)  This  guarantees  correct  builds
              regardless  of  whether  intermediate source files are generated
              during the build, where preprocessors or other  scanners  search
              for  included  files,  or  whether individual compilers or other
              invoked tools are hard-coded to put derived files  in  the  same
              directory as source files.

              This  behavior  of making a complete copy of the source tree may
              be disabled by setting _d_u_p_l_i_c_a_t_e to 0.  This will cause ssccoonnss to
              invoke  Builders using the path names of source files in _s_r_c___d_i_r
              and the path names of derived files within _b_u_i_l_d___d_i_r.   This  is
              always  more efficient than _d_u_p_l_i_c_a_t_e=1, and is usually safe for
              most builds.  Specifying _d_u_p_l_i_c_a_t_e=0, however, may  cause  build
              problems  if source files are generated during the build, if any
              invoked tools are hard-coded to put derived files  in  the  same
              directory as the source files.

              Note that specifying a BBuuiillddDDiirr works most naturally with a sub-
              sidiary SConscript file in the source directory.   However,  you
              would then call the subsidiary SConscript file not in the source
              directory, but in the _b_u_i_l_d___d_i_r _, as if ssccoonnss had made a virtual
              copy  of  the  source tree regardless of the value of _d_u_p_l_i_c_a_t_e.
              This is how you tell ssccoonnss which variant of  a  source  tree  to
              build.  For example:

              BuildDir('build-variant1', 'src')
              SConscript('build-variant1/SConscript')
              BuildDir('build-variant2', 'src')
              SConscript('build-variant2/SConscript')


              See also the SSCCoonnssccrriipptt() function, described below, for another
              way to specify a build directory in conjunction with  calling  a
              subsidiary SConscript file.)


       Builder(_a_c_t_i_o_n, [_a_r_g_u_m_e_n_t_s])

       env.Builder(_a_c_t_i_o_n, [_a_r_g_u_m_e_n_t_s])
              Creates a Builder object for the specified _a_c_t_i_o_n.  See the sec-
              tion "Builder Objects," below, for a complete explanation of the
              arguments and behavior.


       CacheDir(_c_a_c_h_e___d_i_r)

       env.CacheDir(_c_a_c_h_e___d_i_r)
              Specifies  that  ssccoonnss will maintain a cache of derived files in
              _c_a_c_h_e___d_i_r _.  The derived files in the cache will be shared among
              all the builds using the same CCaacchheeDDiirr() call.

              When  a  CCaacchheeDDiirr() is being used and ssccoonnss finds a derived file
              that needs to be rebuilt, it will first look in the cache to see
              if  a  derived  file has already been built from identical input
              files and an identical build action (as  incorporated  into  the
              MD5  build signature).  If so, ssccoonnss will retrieve the file from
              the cache.  If the derived file is not  present  in  the  cache,
              ssccoonnss will rebuild it and then place a copy of the built file in
              the cache (identified by its MD5 build signature),  so  that  it
              may  be  retrieved  by  other builds that need to build the same
              derived file from identical inputs.

              Use of a specified CCaacchheeDDiirr(()) may be disabled for any invocation
              by using the ----ccaacchhee--ddiissaabbllee option.

              If  the ----ccaacchhee--ffoorrccee option is used, ssccoonnss will place a copy of
              _a_l_l derived files in the cache, even if they already existed and
              were not built by this invocation.  This is useful to populate a
              cache the first time CCaacchheeDDiirr() is added to a  build,  or  after
              using the ----ccaacchhee--ddiissaabbllee option.

              When using CCaacchheeDDiirr(), ssccoonnss will report, "Retrieved `file' from
              cache," unless the ----ccaacchhee--sshhooww option is being used.  When  the
              ----ccaacchhee--sshhooww  option  is  used, ssccoonnss will print the action that
              _w_o_u_l_d have been used to build the file, without  any  indication
              that  the  file  was actually retrieved from the cache.  This is
              useful to generate build logs that are equivalent regardless  of
              whether  a  given  derived  file  has  been  built  in-place  or
              retrieved from the cache.


       Clean(_t_a_r_g_e_t_s, _f_i_l_e_s___o_r___d_i_r_s)

       env.Clean(_t_a_r_g_e_t_s, _f_i_l_e_s___o_r___d_i_r_s)
              This specifies a list of files or directories  which  should  be
              removed  whenever  the targets are specified with the --cc command
              line option.  The specified targets may be a list or an individ-
              ual target.  Multiple calls to CClleeaann() are legal, and create new
              targets or add files and directories to the clean list  for  the
              specified targets.

              Multiple files or directories should be specified either as sep-
              arate arguments to the CClleeaann() method, or as  a  list.   CClleeaann()
              will  also  accept  the  return value of any of the construction
              environment Builder methods.  Examples:

              Clean('foo', ['bar', 'baz'])
              Clean('dist', env.Program('hello', 'hello.c'))
              Clean(['foo', 'bar'], 'something_else_to_clean')


       Command(_t_a_r_g_e_t, _s_o_u_r_c_e, _a_c_t_i_o_n, [_k_e_y=_v_a_l, ...])

       env.Command(_t_a_r_g_e_t, _s_o_u_r_c_e, _a_c_t_i_o_n, [_k_e_y=_v_a_l, ...])
              Executes a specific action (or list of actions) to build a  tar-
              get file or files.  This is more convenient than defining a sep-
              arate Builder object for a single special-case build.

              As a special case, the ssoouurrccee__ssccaannnneerr keyword  argument  can  be
              used  to  specify a Scanner object that will be used to scan the
              sources.  (The global DDiirrSSccaannnneerr object can be used  if  any  of
              the sources will be directories that must be scanned on-disk for
              changes to files that aren't already specified in other  Builder
              of function calls.)

              Any  other  keyword  arguments specified override any same-named
              existing construction variables.

              An action can be an external command, specified as a string,  or
              a  callable Python object; see "Action Objects," below, for more
              complete information.  Also note that  a  string  specifying  an
              external  command  may be preceded by an @@ (at-sign) to suppress
              printing the command in question, or by a -- (hyphen)  to  ignore
              the exit status of the external command.  Examples:

              env.Command('foo.out', 'foo.in',
                          "$FOO_BUILD < $SOURCES > $TARGET")

              env.Command('bar.out', 'bar.in',
                          ["rm -f $TARGET",
                           "$BAR_BUILD < $SOURCES > $TARGET"],
                          ENV = {'PATH' : '/usr/local/bin/'})

              def rename(env, target, source):
                  import os
                  os.rename('.tmp', str(target[0]))

              env.Command('baz.out', 'baz.in',
                          ["$BAZ_BUILD < $SOURCES > .tmp",
                        rename ])


       Configure(_e_n_v, [_c_u_s_t_o_m___t_e_s_t_s, _c_o_n_f___d_i_r, _l_o_g___f_i_l_e, _c_o_n_f_i_g___h])

       env.Configure([_c_u_s_t_o_m___t_e_s_t_s, _c_o_n_f___d_i_r, _l_o_g___f_i_l_e, _c_o_n_f_i_g___h])
              Creates  a Configure object for integrated functionality similar
              to GNU autoconf.  See the section "Configure  Contexts,"  below,
              for a complete explanation of the arguments and behavior.


       env.Copy([_k_e_y=_v_a_l, ...])
              Return  a separate copy of a construction environment.  If there
              are any keyword arguments  specified,  they  are  added  to  the
              returned copy, overwriting any existing values for the keywords.

              env2 = env.Copy()
              env3 = env.Copy(CCFLAGS = '-g')

              Additionally, a list of tools and a toolpath may  be  specified,
              as in the Environment constructor:

              def MyTool(env): env['FOO'] = 'bar'
              env4 = env.Copy(tools = ['msvc', MyTool])


       env.CVS(_r_e_p_o_s_i_t_o_r_y, _m_o_d_u_l_e)
              A  factory  function that returns a Builder object to be used to
              fetch source files  from  the  specified  CVS  _r_e_p_o_s_i_t_o_r_y.   The
              returned  Builder  is  intended  to  be passed to the SSoouurrcceeCCooddee
              function.

              The optional specified _m_o_d_u_l_e will be added to the beginning  of
              all  repository  path  names;  this  can be used, in essence, to
              strip initial directory names from the repository path names, so
              that you only have to replicate part of the repository directory
              hierarchy in your local build directory:

              # Will fetch foo/bar/src.c
              # from /usr/local/CVSROOT/foo/bar/src.c.
              env.SourceCode('.', env.CVS('/usr/local/CVSROOT'))

              # Will fetch bar/src.c
              # from /usr/local/CVSROOT/foo/bar/src.c.
              env.SourceCode('.', env.CVS('/usr/local/CVSROOT', 'foo'))

              # Will fetch src.c
              # from /usr/local/CVSROOT/foo/bar/src.c.
              env.SourceCode('.', env.CVS('/usr/local/CVSROOT', 'foo/bar'))


       Default(_t_a_r_g_e_t_s)

       env.Default(_t_a_r_g_e_t_s)
              This specifies a list of default targets, which will be built by
              ssccoonnss  if  no  explicit  targets  are given on the command line.
              Multiple calls to DDeeffaauulltt() are legal, and add to  the  list  of
              default targets.

              Multiple  targets  should  be specified as separate arguments to
              the DDeeffaauulltt() method, or as a list.  DDeeffaauulltt() will also  accept
              the Node returned by any of a construction environment's builder
              methods.  Examples:

              Default('foo', 'bar', 'baz')
              env.Default(['a', 'b', 'c'])
              hello = env.Program('hello', 'hello.c')
              env.Default(hello)

              An argument to DDeeffaauulltt() of NNoonnee will clear all default targets.
              Later  calls  to  DDeeffaauulltt() will add to the (now empty) default-
              target list like normal.

              The current list of targets added using the  DDeeffaauulltt()  function
              or method is available in the DDEEFFAAUULLTT__TTAARRGGEETTSS list; see below.


       DefaultEnvironment([_a_r_g_s])
              Creates  and  returns a default construction environment object.
              This construction environment is used  internally  by  SCons  in
              order  to execute many of the global functions in this list, and
              to fetch source files transparently from source code  management
              systems.


       Depends(_t_a_r_g_e_t, _d_e_p_e_n_d_e_n_c_y)

       env.Depends(_t_a_r_g_e_t, _d_e_p_e_n_d_e_n_c_y)
              Specifies  an  explicit  dependency;  the target file(s) will be
              rebuilt whenever  the  dependency  file(s)  has  changed.   This
              should  only  be necessary for cases where the dependency is not
              caught by a Scanner for the file.

              env.Depends('foo', 'other-input-file-for-foo')


       env.Dictionary([_v_a_r_s])
              Returns a dictionary object containing copies of all of the con-
              struction  variables in the environment.  If there are any vari-
              able names specified, only the specified construction  variables
              are returned in the dictionary.

              dict = env.Dictionary()
              cc_dict = env.Dictionary('CC', 'CCFLAGS', 'CCCOM')


       Dir(_n_a_m_e, [_d_i_r_e_c_t_o_r_y])

       env.Dir(_n_a_m_e, [_d_i_r_e_c_t_o_r_y])
              This  returns  a  Directory  Node, an object that represents the
              specified directory _n_a_m_e.  _n_a_m_e can be a  relative  or  absolute
              path.   _d_i_r_e_c_t_o_r_y  is an optional directory that will be used as
              the parent directory.  If no _d_i_r_e_c_t_o_r_y is specified, the current
              script's directory is used as the parent.

              Directory  Nodes  can be used anywhere you would supply a string
              as a directory name to a Builder method or function.   Directory
              Nodes have attributes and methods that are useful in many situa-
              tions; see "File and Directory Nodes," below.


       env.Dump([_k_e_y])
              Returns a pretty printable representation  of  the  environment.
              _k_e_y,  if not _N_o_n_e, should be a string containing the name of the
              variable of interest.

              This SConstruct:
              env=Environment()
              print env.Dump('CCCOM')
       will print:

              env=Environment()
              print env.Dump()
       will print:
              { 'AR': 'ar',
                'ARCOM': '$AR $ARFLAGS $TARGET $SOURCES0RANLIB $RANLIBFLAGS $TARGET',
                'ARFLAGS': ['r'],
                'AS': 'as',
                'ASCOM': '$AS $ASFLAGS -o $TARGET $SOURCES',
                'ASFLAGS': [],
                ...


       EnsurePythonVersion(_m_a_j_o_r, _m_i_n_o_r)

       env.EnsurePythonVersion(_m_a_j_o_r, _m_i_n_o_r)
              Ensure that the Python version is at  least  _m_a_j_o_r._m_i_n_o_r.   This
              function  will  print out an error message and exit SCons with a
              non-zero exit code if the actual  Python  version  is  not  late
              enough.

              EnsurePythonVersion(2,2)


       EnsureSConsVersion(_m_a_j_o_r, _m_i_n_o_r, [_r_e_v_i_s_i_o_n])

       env.EnsureSConsVersion(_m_a_j_o_r, _m_i_n_o_r, [_r_e_v_i_s_i_o_n])
              Ensure  that  the  SCons  version  is  at  least _m_a_j_o_r_._m_i_n_o_r, or
              _m_a_j_o_r_._m_i_n_o_r_._r_e_v_i_s_i_o_n.  if _r_e_v_i_s_i_o_n is specified.  This  function
              will  print  out an error message and exit SCons with a non-zero
              exit code if the actual SCons version is not late enough.

              EnsureSConsVersion(0,14)

              EnsureSConsVersion(0,96,90)


       Environment([_k_e_y=_v_a_l_u_e, ...])

       env.Environment([_k_e_y=_v_a_l_u_e, ...])
              Return a new construction environment initialized with the spec-
              ified _k_e_y=_v_a_l_u_e pairs.


       Execute(_a_c_t_i_o_n, [_s_t_r_f_u_n_c_t_i_o_n, _v_a_r_l_i_s_t])

       env.Execute(_a_c_t_i_o_n, [_s_t_r_f_u_n_c_t_i_o_n, _v_a_r_l_i_s_t])
              Executes  an  Action  object.   The  specified  _a_c_t_i_o_n may be an
              Action object (see the section "Action Objects,"  below,  for  a
              complete  explanation  of the arguments and behavior), or it may
              be a command-line string, list of commands, or executable Python
              function,  each of which will be converted into an Action object
              and then executed.  The exit value  of  the  command  or  return
              value of the Python function will be returned.


       Exit([_v_a_l_u_e])

       env.Exit([_v_a_l_u_e])
              This  tells  ssccoonnss to exit immediately with the specified _v_a_l_u_e.
              A default exit value of 00 (zero) is used if no value  is  speci-
              fied.


       Export(_v_a_r_s)

       env.Export(_v_a_r_s)
              This  tells ssccoonnss to export a list of variables from the current
              SConscript file to all other  SConscript  files.   The  exported
              variables  are  kept in a global collection, so subsequent calls
              to EExxppoorrtt() will over-write previous exports that have the  same
              name.  Multiple variable names can be passed to EExxppoorrtt() as sep-
              arate arguments or as a list. A dictionary can be  used  to  map
              variables  to  a  different name when exported. Both local vari-
              ables and global variables can be exported.  Examples:

              env = Environment()
              # Make env available for all SConscript files to Import().
              Export("env")

              package = 'my_name'
              # Make env and package available for all SConscript files:.
              Export("env", "package")

              # Make env and package available for all SConscript files:
              Export(["env", "package"])

              # Make env available using the name debug:.
              Export({"debug":env})


              Note that the SSCCoonnssccrriipptt() function supports an _e_x_p_o_r_t_s argument
              that makes it easier to to export a variable or set of variables
              to a single SConscript file.  See the description of  the  SSCCoonn--
              ssccrriipptt() function, below.


       File(_n_a_m_e, [_d_i_r_e_c_t_o_r_y])

       env.File(_n_a_m_e, [_d_i_r_e_c_t_o_r_y])
              This  returns  a File Node, an object that represents the speci-
              fied file _n_a_m_e.  _n_a_m_e  can  be  a  relative  or  absolute  path.
              _d_i_r_e_c_t_o_r_y is an optional directory that will be used as the par-
              ent directory.

              File Nodes can be used anywhere you would supply a string  as  a
              file  name  to  a  Builder  method or function.  File Nodes have
              attributes and methods that are useful in many  situations;  see
              "File and Directory Nodes," below.


       FindFile(_f_i_l_e, _d_i_r_s)

       env.FindFile(_f_i_l_e, _d_i_r_s)
              Search  for  _f_i_l_e  in the path specified by _d_i_r_s.  _f_i_l_e may be a
              list of file names or a single file name. In addition to search-
              ing  for  files  that exist in the filesytem, this function also
              searches for derived files that have not yet been built.

              foo = env.FindFile('foo', ['dir1', 'dir2'])


       Flatten(_s_e_q_u_e_n_c_e)

       env.Flatten(_s_e_q_u_e_n_c_e)
              Takes a sequence (that is, a Python list or tuple) that may con-
              tain  nested  sequences  and returns a flattened list containing
              all of the individual elements in any  sequence.   This  can  be
              helpful  for collecting the lists returned by calls to Builders;
              other Builders will automatically  flatten  lists  specified  as
              input, but direct Python manipulation of these lists does not:

              foo = Object('foo.c')
              bar = Object('bar.c')

              # Because `foo' and `bar' are lists returned by the Object() Builder,
              # `objects' will be a list containing nested lists:
              objects = ['f1.o', foo, 'f2.o', bar, 'f3.o']

              # Passing such a list to another Builder is all right because
              # the Builder will flatten the list automatically:
              Program(source = objects)

              # If you need to manipulate the list directly using Python, you need to
              # call Flatten() yourself, or otherwise handle nested lists:
              for object in Flatten(objects):
                  print str(object)


       GetBuildPath(_f_i_l_e, [_._._.])

       env.GetBuildPath(_f_i_l_e, [_._._.])
              Returns  the  ssccoonnss  path name (or names) for the specified _f_i_l_e
              (or files).  The specified _f_i_l_e or files may be ssccoonnss  Nodes  or
              strings representing path names.


       GetLaunchDir()

       env.GetLaunchDir()
              Returns the absolute path name of the directory from which ssccoonnss
              was initially invoked.  This can be useful when using the --uu, --UU
              or --DD options, which internally change to the directory in which
              the SSCCoonnssttrruucctt file is found.


       GetOption(_n_a_m_e)

       env.GetOption(_n_a_m_e)
              This function provides a way to query a  select  subset  of  the
              scons  command  line  options from a SConscript file. See _S_e_t_O_p_-
              _t_i_o_n() for a description of the options available.



       Help(_t_e_x_t)

       env.Help(_t_e_x_t)
              This specifies help text to be printed if  the  --hh  argument  is
              given  to  ssccoonnss.  If HHeellpp is called multiple times, the text is
              appended together in the order that HHeellpp is called.


       Ignore(_t_a_r_g_e_t, _d_e_p_e_n_d_e_n_c_y)

       env.Ignore(_t_a_r_g_e_t, _d_e_p_e_n_d_e_n_c_y)
              The specified dependency file(s) will be ignored  when  deciding
              if the target file(s) need to be rebuilt.

              env.Ignore('foo', 'foo.c')
              env.Ignore('bar', ['bar1.h', 'bar2.h'])


       Import(_v_a_r_s)

       env.Import(_v_a_r_s)
              This  tells ssccoonnss to import a list of variables into the current
              SConscript file. This will import variables that  were  exported
              with EExxppoorrtt() or in the _e_x_p_o_r_t_s argument to SSCCoonnssccrriipptt().  Vari-
              ables exported by SSCCoonnssccrriipptt() have precedence.  Multiple  vari-
              able names can be passed to IImmppoorrtt() as separate arguments or as
              a list. The variable "*" can be used to  import  all  variables.
              Examples:

              Import("env")
              Import("env", "variable")
              Import(["env", "variable"])
              Import("*")


       Install(_d_i_r, _s_o_u_r_c_e)

       env.Install(_d_i_r, _s_o_u_r_c_e)
              Installs one or more files in a destination directory.  The file
              names remain the same.

              env.Install(dir = '/usr/local/bin', source = ['foo', 'bar'])


       InstallAs(_t_a_r_g_e_t, _s_o_u_r_c_e)

       env.InstallAs(_t_a_r_g_e_t, _s_o_u_r_c_e)
              Installs one or more files  as  specific  file  names,  allowing
              changing  a  file  name  as  part of the installation.  It is an
              error if the target and source list different numbers of  files.

              env.InstallAs(target = '/usr/local/bin/foo',
                            source = 'foo_debug')
              env.InstallAs(target = ['../lib/libfoo.a', '../lib/libbar.a'],
                            source = ['libFOO.a', 'libBAR.a'])


       Literal(_s_t_r_i_n_g)

       env.Literal(_s_t_r_i_n_g)
              The  specified  _s_t_r_i_n_g will be preserved as-is and not have con-
              struction variables expanded.


       Local(_t_a_r_g_e_t_s)

       env.Local(_t_a_r_g_e_t_s)
              The specified _t_a_r_g_e_t_s will have copies made in the  local  tree,
              even  if  an  already  up-to-date  copy  exists in a repository.
              Returns a list of the target Node or Nodes.


       env.ParseConfig(_c_o_m_m_a_n_d, [_f_u_n_c_t_i_o_n, _u_n_i_q_u_e])
              Calls the specified _f_u_n_c_t_i_o_n to modify the environment as speci-
              fied  by  the  output of _c_o_m_m_a_n_d _.  The default _f_u_n_c_t_i_o_n expects
              the output of a typical _*_-_c_o_n_f_i_g _c_o_m_m_a_n_d (for example,  ggttkk--ccoonn--
              ffiigg)  and adds the options to the appropriate construction vari-
              ables.  By default, duplicate values are not added to  any  con-
              struction variables; you can specify uunniiqquuee==00 to allow duplicate
              values to be added.

              By default, --LL, --ll, --WWaa, --WWll, --WWpp, --II and other options, are add
              to  the LLIIBBPPAATTHH, LLIIBBSS, AASSFFLLAAGGSS, LLIINNKKFFLLAAGGSS, CCPPPPFFLLAAGGSS, CCPPPPPPAATTHH and
              CCCCFFLLAAGGSS  construction  variables,  respectively.    A   returned
              --pptthhrreeaadd  option  gets  added  to both the CCCCFFLLAAGGSS and LLIINNKKFFLLAAGGSS
              variables.  A returned --ffrraammeewwoorrkk option gets added to the LLIINNKK--
              FFLLAAGGSS  variable.   Any other strings not associated with options
              are assumed to be the names of libraries and added to  the  LLIIBBSS
              construction variable.


       ParseDepends(_f_i_l_e_n_a_m_e, [_m_u_s_t___e_x_i_s_t])

       env.ParseDepends(_f_i_l_e_n_a_m_e, [_m_u_s_t___e_x_i_s_t _o_n_l_y___o_n_e])
              Parses  the  contents  of  the  specified  _f_i_l_e_n_a_m_e as a list of
              dependencies in the style  of  MMaakkee  or  mmkkddeepp,  and  explicitly
              establishes all of the listed dependencies.

              By  default,  it  is not an error if the specified _f_i_l_e_n_a_m_e does
              not exist.  The optional _m_u_s_t___e_x_i_t argument may be set to a non-
              zero  value  to  have  scons  throw an exception and generate an
              error if the file does not exist, or is otherwise  inaccessible.

              The optional _o_n_l_y___o_n_e argument may be set to a non-zero value to
              have scons thrown an exception and generate an error if the file
              contains  dependency information for more than one target.  This
              can provide a small sanity check for files intended to be gener-
              ated  by,  for  example, the ggcccc --MM flag, which should typically
              only write dependency information for one  output  file  into  a
              corresponding ..dd file.

              The  _f_i_l_e_n_a_m_e and all of the files listed therein will be inter-
              preted relative to the directory of the  _S_C_o_n_s_c_r_i_p_t  file  which
              calls the PPaarrsseeDDeeppeennddss function.


       env.Perforce()
              A  factory  function that returns a Builder object to be used to
              fetch source files from the Perforce source code management sys-
              tem.   The  returned  Builder  is  intended  to be passed to the
              SSoouurrcceeCCooddee function:

              env.SourceCode('.', env.Perforce())

              Perforce uses a number of external environment variables for its
              operation.  Consequently, this function adds the following vari-
              ables from the user's external environment to  the  construction
              environment's  ENV  dictionary: P4CHARSET, P4CLIENT, P4LANGUAGE,
              P4PASSWD, P4PORT, P4USER, SYSTEMROOT, USER, and USERNAME.


       Platform(_s_t_r_i_n_g)
              Returns a callable object that can be used to initialize a  con-
              struction environment using the platform keyword of the Environ-
              ment() method:

              env = Environment(platform = Platform('win32'))

       env.Platform(_s_t_r_i_n_g)
              Applies the callable object for the specified platform _s_t_r_i_n_g to
              the environment through which the method was called.

              env.Platform('posix')

              Note that the wwiinn3322 platform adds the SSYYSSTTEEMMDDRRIIVVEE and SSYYSSTTEEMMRROOOOTT
              variables from the user's external environment to the  construc-
              tion environment's EENNVV dictionary.  This is so that any executed
              commands that use sockets to connect with other systems (such as
              fetching  source  files  from external CVS repository specifica-
              tions     like      ::ppsseerrvveerr::aannoonnyymmoouuss@@ccvvss..ssoouurrcceeffoorrggee..nneett:://ccvvss--
              rroooott//ssccoonnss) will work on Win32 systems.


       Precious(_t_a_r_g_e_t, ...)

       env.Precious(_t_a_r_g_e_t, ...)
              Marks  each given _t_a_r_g_e_t as precious so it is not deleted before
              it is rebuilt. Normally ssccoonnss deletes a target  before  building
              it.   Multiple  targets  can  be  passed  in to a single call to
              PPrreecciioouuss().


       env.Prepend(_k_e_y=_v_a_l, [...])
              Appends the specified keyword arguments to the beginning of con-
              struction variables in the environment.  If the Environment does
              not have the specified construction variable, it is simply added
              to  the environment.  If the values of the construction variable
              and the keyword argument are the same type, then the two  values
              will  be  simply  added  together.   Otherwise, the construction
              variable and the value of the keyword argument are both  coerced
              to  lists,  and  the  lists  are  added together.  (See also the
              Append method, above.)

              env.Prepend(CCFLAGS = '-g ', FOO = ['foo.yyy'])


       env.PrependENVPath(_n_a_m_e, _n_e_w_p_a_t_h, [_e_n_v_n_a_m_e, _s_e_p])
              This appends new path elements to the given path in  the  speci-
              fied  external environment (EENNVV by default).  This will only add
              any particular path once (leaving the first  one  it  encounters
              and  ignoring  the  rest,  to  preserve path order), and to help
              assure this, will normalize all  paths  (using  ooss..ppaatthh..nnoorrmmppaatthh
              and  ooss..ppaatthh..nnoorrmmccaassee).  This can also handle the case where the
              given old path variable is a list instead of a string, in  which
              case a list will be returned instead of a string.  Example:

              print 'before:',env['ENV']['INCLUDE']
              include_path = '/foo/bar:/foo'
              env.PrependENVPath('INCLUDE', include_path)
              print 'after:',env['ENV']['INCLUDE']

              yields:
              before: /biz:/foo
              after: /foo/bar:/foo:/biz


       env.PrependUnique(_k_e_y=_v_a_l, [...])
              Appends the specified keyword arguments to the beginning of con-
              struction variables in the environment.  If the Environment does
              not have the specified construction variable, it is simply added
              to the environment.  If the construction variable being appended
              to  is  a list, then any value(s) that already exist in the con-
              struction variable will _n_o_t be added again to the list.

              env.PrependUnique(CCFLAGS = '-g', FOO = ['foo.yyy'])


       env.RCS()
              A factory function that returns a Builder object to be  used  to
              fetch  source  files from RCS.  The returned Builder is intended
              to be passed to the SSoouurrcceeCCooddee function:

              env.SourceCode('.', env.RCS())

              Note that ssccoonnss will fetch source files from RCS  subdirectories
              automatically,  so  configuring RCS as demonstrated in the above
              example should only be necessary if you are fetching from  RCS,v
              files  in the same directory as the source files, or if you need
              to explicitly specify RCS for a specific subdirectory.


       env.Replace(_k_e_y=_v_a_l, [...])
              Replaces construction variables  in  the  Environment  with  the
              specified keyword arguments.

              env.Replace(CCFLAGS = '-g', FOO = 'foo.xxx')


       Repository(_d_i_r_e_c_t_o_r_y)

       env.Repository(_d_i_r_e_c_t_o_r_y)
              Specifies  that  _d_i_r_e_c_t_o_r_y  is  a  repository to be searched for
              files.  Multiple calls to RReeppoossiittoorryy() are legal, and  each  one
              adds to the list of repositories that will be searched.

              To  ssccoonnss,  a  repository is a copy of the source tree, from the
              top-level directory on down, which may contain both source files
              and derived files that can be used to build targets in the local
              source tree.  The canonical example would be an official  source
              tree  maintained  by  an integrator.  If the repository contains
              derived files, then the derived files  should  have  been  built
              using  ssccoonnss, so that the repository contains the necessary sig-
              nature information to allow ssccoonnss  to  figure  out  when  it  is
              appropriate  to  use  the  repository  copy  of  a derived file,
              instead of building one locally.

              Note that if an up-to-date derived  file  already  exists  in  a
              repository,  ssccoonnss  will  _n_o_t make a copy in the local directory
              tree.  In order to guarantee that a local copy will be made, use
              the LLooccaall(()) method.


       Return(_v_a_r_s)
              This  tells ssccoonnss what variable(s) to use as the return value(s)
              of the current SConscript file. These variables will be returned
              to the "calling" SConscript file as the return value(s) of SSCCoonn--
              ssccrriipptt().  Multiple variable names should be passed to  RReettuurrnn()
              as a list. Example:

              Return("foo")
              Return(["foo", "bar"])


       Scanner(_f_u_n_c_t_i_o_n, [_a_r_g_u_m_e_n_t, _k_e_y_s, _p_a_t_h___f_u_n_c_t_i_o_n, _n_o_d_e___c_l_a_s_s, _n_o_d_e___f_a_c_-
       _t_o_r_y, _s_c_a_n___c_h_e_c_k, _r_e_c_u_r_s_i_v_e])

       env.Scanner(_f_u_n_c_t_i_o_n,   [_a_r_g_u_m_e_n_t,   _k_e_y_s,  _p_a_t_h___f_u_n_c_t_i_o_n,  _n_o_d_e___c_l_a_s_s,
       _n_o_d_e___f_a_c_t_o_r_y, _s_c_a_n___c_h_e_c_k, _r_e_c_u_r_s_i_v_e])
              Creates  a  Scanner  object for the specified _f_u_n_c_t_i_o_n.  See the
              section "Scanner Objects," below, for a complete explanation  of
              the arguments and behavior.


       env.SCCS()
              A  factory  function that returns a Builder object to be used to
              fetch source files from SCCS.  The returned Builder is  intended
              to be passed to the SSoouurrcceeCCooddee function:

              env.SourceCode('.', env.SCCS())

              Note that ssccoonnss will fetch source files from SCCS subdirectories
              automatically, so configuring SCCS as demonstrated in the  above
              example should only be necessary if you are fetching from _s_._S_C_C_S
              files in the same directory as the source files, or if you  need
              to explicitly specify SCCS for a specific subdirectory.


       SConscript(_s_c_r_i_p_t_s, [_e_x_p_o_r_t_s, _b_u_i_l_d___d_i_r, _s_r_c___d_i_r, _d_u_p_l_i_c_a_t_e])

       env.SConscript(_s_c_r_i_p_t_s, [_e_x_p_o_r_t_s, _b_u_i_l_d___d_i_r, _s_r_c___d_i_r, _d_u_p_l_i_c_a_t_e])

       SConscript(dirs=_s_u_b_d_i_r_s,  [name=_s_c_r_i_p_t,  _e_x_p_o_r_t_s,  _b_u_i_l_d___d_i_r,  _s_r_c___d_i_r,
       _d_u_p_l_i_c_a_t_e])

       env.SConscript(dirs=_s_u_b_d_i_r_s, [name=_s_c_r_i_p_t, _e_x_p_o_r_t_s, _b_u_i_l_d___d_i_r, _s_r_c___d_i_r,
       _d_u_p_l_i_c_a_t_e])
              This  tells  ssccoonnss  to execute one or more subsidiary SConscript
              (configuration) files.  There are two ways  to  call  the  SSCCoonn--
              ssccrriipptt() function.

              The first way you can call SSCCoonnssccrriipptt() is to explicitly specify
              one or more _s_c_r_i_p_t_s as the first argument.  A single script  may
              be  specified as a string; multiple scripts must be specified as
              a list (either explicitly or  as  created  by  a  function  like
              SSpplliitt()).

              The second way you can call SSCCoonnssccrriipptt() is to specify a list of
              (sub)directory names as a  dirs=_s_u_b_d_i_r_s  keyword  argument.   In
              this case, ssccoonnss will, by default, execute a subsidiary configu-
              ration file named SSCCoonnssccrriipptt in each of the  specified  directo-
              ries.  You may specify a name other than SSCCoonnssccrriipptt by supplying
              an optional name=_s_c_r_i_p_t keyword argument.

              The optional _e_x_p_o_r_t_s argument provides a list of variable  names
              or  a  dictionary  of  named  values to export to the _s_c_r_i_p_t_(_s_).
              These variables are  locally  exported  only  to  the  specified
              _s_c_r_i_p_t_(_s_),  and  do not affect the global pool of variables used
              by the EExxppoorrtt() function.  The subsidiary _s_c_r_i_p_t_(_s_) must use the
              IImmppoorrtt() function to import the variables.

              The optional _b_u_i_l_d___d_i_r argument specifies that all of the target
              files (for example, object files  and  executables)  that  would
              normally  be  built  in the subdirectory in which _s_c_r_i_p_t resides
              should actually be built in _b_u_i_l_d___d_i_r.  _b_u_i_l_d___d_i_r is interpreted
              relative to the directory of the calling SConscript file.

              The  optional  _s_r_c___d_i_r  argument specifies that the source files
              from which the target files should be  built  can  be  found  in
              _s_r_c___d_i_r.   _s_r_c___d_i_r  is  interpreted relative to the directory of
              the calling SConscript file.

              By default, ssccoonnss will link or copy (depending on the  platform)
              all  the  source  files into the build directory.  This behavior
              may be disabled by setting the optional _d_u_p_l_i_c_a_t_e argument to  0
              (it  is  set  to  1  by default), in which case ssccoonnss will refer
              directly to the source files  in  their  source  directory  when
              building  target  files.   (Setting _d_u_p_l_i_c_a_t_e=0 is usually safe,
              and always more efficient than the default of  _d_u_p_l_i_c_a_t_e=1,  but
              it  may  cause build problems in certain end-cases, such as com-
              piling from source files that are generated by the build.)

              Any variables returned by _s_c_r_i_p_t using RReettuurrnn() will be returned
              by the call to SSCCoonnssccrriipptt().

              Examples:

              SConscript('subdir/SConscript')
              foo = SConscript('sub/SConscript', exports='env')
              SConscript('dir/SConscript', exports=['env', 'variable'])
              SConscript('src/SConscript', build_dir='build', duplicate=0)
              SConscript('bld/SConscript', src_dir='src', exports='env variable')
              SConscript(dirs=['sub1', 'sub2'])
              SConscript(dirs=['sub3', 'sub4'], name='MySConscript')


       SConscriptChdir(_v_a_l_u_e)

       env.SConscriptChdir(_v_a_l_u_e)
              By default, ssccoonnss changes its working directory to the directory
              in which each subsidiary SConscript file lives.   This  behavior
              may be disabled by specifying either:

              SConscriptChdir(0)
              env.SConscriptChdir(0)

              in  which  case ssccoonnss will stay in the top-level directory while
              reading all SConscript  files.   (This  may  be  necessary  when
              building  from  repositories,  when all the directories in which
              SConscript files may be found don't necessarily exist  locally.)

              You  may  enable  and  disable  this  ability  by  calling SCon-
              scriptChdir() multiple times:

              env = Environment()
              SConscriptChdir(0)
              SConscript('foo/SConscript')  # will not chdir to foo
              env.SConscriptChdir(1)
              SConscript('bar/SConscript')  # will chdir to bar


       SConsignFile([_f_i_l_e,_d_b_m___m_o_d_u_l_e])

       env.SConsignFile([_f_i_l_e,_d_b_m___m_o_d_u_l_e])
              This tells ssccoonnss to store all file signatures in  the  specified
              database  _f_i_l_e.   If the _f_i_l_e name is omitted, ..ssccoonnssiiggnn is used
              by default.  (The actual file name(s) stored on disk may have an
              appropriated suffix appended by the _d_b_m___m_o_d_u_l_e.)  If _f_i_l_e is not
              an absolute path name, the file is placed in the same  directory
              as the top-level SSCCoonnssttrruucctt file.

              If _f_i_l_e is NNoonnee, then ssccoonnss will store file signatures in a sep-
              arate ..ssccoonnssiiggnn file  in  each  directory,  not  in  one  global
              database  file.   (This  was the default behavior prior to SCons
              0.96.91 and 0.97.)

              The optional _d_b_m___m_o_d_u_l_e argument can be used  to  specify  which
              Python   database   module  The  default  is  to  use  a  custom
              SSCCoonnss..ddbblliittee module that uses pickled  Python  data  structures,
              and which works on all Python versions from 1.5.2 on.

              Examples:

              # Explicitly stores signatures in ".sconsign.dblite"
              # in the top-level SConstruct directory (the
              # default behavior).
              SConsignFile()

              # Stores signatures in the file "etc/scons-signatures"
              # relative to the top-level SConstruct directory.
              SConsignFile("etc/scons-signatures")

              # Stores signatures in the specified absolute file name.
              SConsignFile("/home/me/SCons/signatures")

              # Stores signatures in a separate .sconsign file
              # in each directory.
              SConsignFile(None)


       env.SetDefault(key_=val_, _[_._._._]_)
              Sets construction variables to default values specified with the
              keyword arguments if (and only if) the variables are not already
              set.  The following statements are equivalent:

              env.SetDefault(FOO = 'foo')

              if not env.has_key('FOO'): env['FOO'] = 'foo'


       SetOption(_n_a_m_e, _v_a_l_u_e)

       env.SetOption(_n_a_m_e, _v_a_l_u_e)
              This function provides a way to set a select subset of the scons
              command line options from a SConscript file.  The  options  sup-
              ported   are:  cclleeaann  which  corresponds  to  -c,  --clean,  and
              --remove;   dduupplliiccaattee   which   corresponds   to    --duplicate;
              iimmpplliicciitt__ccaacchhee  which corresponds to --implicit-cache; mmaaxx__ddrriifftt
              which corresponds to --max-drift; nnuumm__jjoobbss which corresponds  to
              -j and --jobs.  See the documentation for the corresponding com-
              mand line object for information  about  each  specific  option.
              Example:

              SetOption('max_drift', 1)


       SideEffect(_s_i_d_e___e_f_f_e_c_t, _t_a_r_g_e_t)

       env.SideEffect(_s_i_d_e___e_f_f_e_c_t, _t_a_r_g_e_t)
              Declares  _s_i_d_e___e_f_f_e_c_t as a side effect of building _t_a_r_g_e_t.  Both
              _s_i_d_e___e_f_f_e_c_t and _t_a_r_g_e_t can be a list, a file name, or a node.  A
              side  effect  is  a  target  that is created as a side effect of
              building other targets.  For example, a Windows PDB file is cre-
              ated  as  a  side effect of building the .obj files for a static
              library.  If a target is a side effect of  multiple  build  com-
              mands,  ssccoonnss  will ensure that only one set of commands is exe-
              cuted at a time.  Consequently, you only need to use this method
              for  side-effect  targets that are built as a result of multiple
              build commands.


       SourceCode(_e_n_t_r_i_e_s, _b_u_i_l_d_e_r)

       env.SourceCode(_e_n_t_r_i_e_s, _b_u_i_l_d_e_r)
              Arrange for non-existent source  files  to  be  fetched  from  a
              source  code management system using the specified _b_u_i_l_d_e_r.  The
              specified _e_n_t_r_i_e_s may be a Node, string or list of both, and may
              represent either individual source files or directories in which
              source files can be found.

              For any non-existent source files,  ssccoonnss  will  search  up  the
              directory  tree  and  use the first SSoouurrcceeCCooddee builder it finds.
              The specified _b_u_i_l_d_e_r may be NNoonnee, in which case ssccoonnss will  not
              use  a  builder to fetch source files for the specified _e_n_t_r_i_e_s,
              even if a SSoouurrcceeCCooddee builder has been specified for a  directory
              higher up the tree.

              ssccoonnss will, by default, fetch files from SCCS or RCS subdirecto-
              ries without explicit configuration.  This takes some extra pro-
              cessing  time to search for the necessary source code management
              files on disk.  You can avoid these extra searches and speed  up
              your build a little by disabling these searches as follows:

              env.SourceCode('.', None)


              Note that if the specified _b_u_i_l_d_e_r is one you create by hand, it
              must have an associated construction  environment  to  use  when
              fetching a source file.

              ssccoonnss  provides  a  set  of canned factory functions that return
              appropriate Builders for various popular source code  management
              systems.  Canonical examples of invocation include:

              env.SourceCode('.', env.BitKeeper('/usr/local/BKsources'))
              env.SourceCode('src', env.CVS('/usr/local/CVSROOT'))
              env.SourceCode('/', env.RCS())
              env.SourceCode(['f1.c', 'f2.c'], env.SCCS())
              env.SourceCode('no_source.c', None)


       env.subst(_s_t_r_i_n_g)
              Performs  construction  variable  interpolation on the specified
              string argument.

              print env.subst("The C compiler is: $CC")

              def compile(target, source, env):
                  sourceDir = env.subst("${SOURCE.srcdir}")



       SourceSignatures(_t_y_p_e)

       env.SourceSignatures(_t_y_p_e)
              This function tells SCons what type  of  signature  to  use  for
              source  files:  MMDD55  or ttiimmeessttaammpp.  If the environment method is
              used, the specified type of source signature is only  used  when
              deciding  whether targets built with that environment are up-to-
              date or must be rebuilt.  If the global function  is  used,  the
              specified  type of source signature becomes the default used for
              all decisions about whether targets are up-to-date.

              "MD5" means the signature of a source file is the  MD5  checksum
              of  its  contents.   "timestamp" means the signature of a source
              file is its timestamp (modification time).  There is no  differ-
              ent  between  the two behaviors for Python VVaalluuee() node objects.
              "MD5" signatures take longer to compute, but are  more  accurate
              than "timestamp" signatures.  The default is "MD5".


       Split(_a_r_g)

       env.Split(_a_r_g)
              Returns  a  list  of  file  names or other objects.  If arg is a
              string, it will be split on strings  of  white-space  characters
              within  the string, making it easier to write long lists of file
              names.  If arg is already a list,  the  list  will  be  returned
              untouched.   If  arg  is  any  other  type of object, it will be
              returned as a list containing just the object.

              files = Split("f1.c f2.c f3.c")
              files = env.Split("f4.c f5.c f6.c")
              files = Split("""
                   f7.c
                   f8.c
                   f9.c
              """)


       TargetSignatures(_t_y_p_e)

       env.TargetSignatures(_t_y_p_e)
              This function tells SCons what type of  signatures  to  use  for
              target  files:  bbuuiilldd  or ccoonntteenntt.  If the environment method is
              used, the specified type of signature is only used  for  targets
              built  with  that  environment.  If the global function is used,
              the specified type of signature becomes the default used for all
              target  files  that don't have an explicit target signature type
              specified for their environments.

              "build" means the signature of a target file is made by concate-
              nating all of the signatures of all its source files.  "content"
              means the signature of a target file is an MD5 checksum  of  its
              contents.  "build" signatures are usually faster to compute, but
              "content" signatures can prevent  unnecessary  rebuilds  when  a
              target  file is rebuilt to the exact same contents as the previ-
              ous build.  The default is "build".


       Tool(_s_t_r_i_n_g[,_t_o_o_l_p_a_t_h, _*_*_k_w])
              Returns a callable object that can be used to initialize a  con-
              struction  environment  using  the tools keyword of the Environ-
              ment() method.  The object may be  called  with  a  construction
              environment  as  an  argument, in which case the object will add
              the necessary variables to the construction environment and  the
              name  of the tool will be added to the $$TTOOOOLLSS construction vari-
              able.

              Additional keyword arguments are passed to the tool's ggeenneerraattee(())
              method.

              env = Environment(tools = [ Tool('msvc') ])

              env = Environment()
              t = Tool('msvc')
              t(env)  # adds 'msvc' to the TOOLS variable
              u = Tool('opengl', toolpath = ['tools'])
              u(env)  # adds 'opengl' to the TOOLS variable

       env.Tool(_s_t_r_i_n_g[,_t_o_o_l_p_a_t_h, _*_*_k_w])
              Applies the callable object for the specified tool _s_t_r_i_n_g to the
              environment through which the method was called.

              Additional keyword arguments are passed to the tool's ggeenneerraattee(())
              method.

              env.Tool('gcc')
              env.Tool('opengl', toolpath = ['build/tools'])


       Value(_v_a_l_u_e)

       env.Value(_v_a_l_u_e)
              Returns  a  Node object representing the specified Python value.
              Value nodes can be used as  dependencies  of  targets.   If  the
              result  of  calling  ssttrr((value))  changes between SCons runs, any
              targets depending on VVaalluuee((value)) will be rebuilt.   When  using
              timestamp  source  signatures, Value nodes' timestamps are equal
              to the system time when the node is created.

              def create(target, source, env):
                  f = open(str(target[0]), 'wb')
                  f.write('prefix=' + source[0].get_contents())

              prefix = ARGUMENTS.get('prefix', '/usr/local')
              env = Environment()
              env['BUILDERS']['Config'] = Builder(action = create)
              env.Config(target = 'package-config', source = Value(prefix))


       WhereIs(_p_r_o_g_r_a_m, [_p_a_t_h, _p_a_t_h_e_x_t, _r_e_j_e_c_t])

       env.WhereIs(_p_r_o_g_r_a_m, [_p_a_t_h, _p_a_t_h_e_x_t, _r_e_j_e_c_t])

              Searches for the specified  executable  _p_r_o_g_r_a_m_,  returning  the
              full path name to the program if it is found, and returning None
              if not.  Searches the specified _p_a_t_h_, the value of  the  calling
              environment's  PATH  (env['ENV']['PATH']), or the user's current
              external PATH (os.environ['PATH']) by default.   On  Win32  sys-
              tems,  searches  for  executable  programs  with any of the file
              extensions listed in the specified _p_a_t_h_e_x_t_, the calling environ-
              ment's  PATHEXT  (env['ENV']['PATHEXT'])  or  the user's current
              PATHEXT (os.environ['PATHEXT']) by default.  Will not select any
              path name or names in the specified _r_e_j_e_c_t list, if any.


   SSCCoonnssccrriipptt VVaarriiaabblleess
       In  addition to the global functions and methods, ssccoonnss supports a num-
       ber of Python variables that can be used in SConscript files to  affect
       how  you  want  the  build  to  be  performed.   These variables may be
       accessed from custom Python modules that you import into an  SConscript
       file by adding the following to the Python module:

              from SCons.Script import *


       ARGLIST
              A  list  _k_e_y_w_o_r_d=_v_a_l_u_e  arguments specified on the command line.
              Each  element  in  the  list   is   a   tuple   containing   the
              (_k_e_y_w_o_r_d,_v_a_l_u_e) of the argument.  The separate _k_e_y_w_o_r_d and _v_a_l_u_e
              elements of the tuple can be accessed by subscripting  for  ele-
              ment [[00]] and [[11]] of the tuple, respectively.

              print "first keyword, value =", ARGLIST[0][0], ARGLIST[0][1]
              print "second keyword, value =", ARGLIST[1][0], ARGLIST[1][1]
              third_tuple = ARGLIST[2]
              print "third keyword, value =", third_tuple[0], third_tuple[1]
              for key, value in ARGLIST:
                  # process key and value


       ARGUMENTS
              A dictionary of all the _k_e_y_w_o_r_d=_v_a_l_u_e arguments specified on the
              command line.  The dictionary is not in order, and  if  a  given
              keyword  has  more  than one value assigned to it on the command
              line, the last (right-most) value is the one  in  the  AARRGGUUMMEENNTTSS
              dictionary.

              if ARGUMENTS.get('debug', 0):
                  env = Environment(CCFLAGS = '-g')
              else:
                  env = Environment()


       BUILD_TARGETS
              A  list  of  the targets which ssccoonnss will actually try to build,
              regardless of whether they were specified on the command line or
              via the DDeeffaauulltt() function or method.  The elements of this list
              may be strings _o_r nodes, so you should run the list through  the
              Python  ssttrr  function  to make sure any Node path names are con-
              verted to strings.

              Because this list may be taken from the list of  targets  speci-
              fied using the DDeeffaauulltt() function or method, the contents of the
              list may change on each successive call to DDeeffaauulltt().   See  the
              DDEEFFAAUULLTT__TTAARRGGEETTSS list, below, for additional information.

              if 'foo' in BUILD_TARGETS:
                  print "Don't forget to test the `foo' program!"
              if 'special/program' in BUILD_TARGETS:
                  SConscript('special')

              Note  that the BBUUIILLDD__TTAARRGGEETTSS list only contains targets expected
              listed on the command line or via calls to the  DDeeffaauulltt()  func-
              tion  or method.  It does _n_o_t contain all dependent targets that
              will be built as a result of making  the  sure  the  explicitly-
              specified targets are up to date.


       COMMAND_LINE_TARGETS
              A  list of the targets explicitly specified on the command line.
              If there are no targets specified on the command line, the  list
              is  empty.   This  can  be  used,  for example, to take specific
              actions only when a certain  target  or  targets  is  explicitly
              being built:

              if 'foo' in COMMAND_LINE_TARGETS:
                  print "Don't forget to test the `foo' program!"
              if 'special/program' in COMMAND_LINE_TARGETS:
                  SConscript('special')


       DEFAULT_TARGETS
              A  list  of  the target _n_o_d_e_s that have been specified using the
              DDeeffaauulltt() function or method.  The  elements  of  the  list  are
              nodes,  so  you need to run them through the Python ssttrr function
              to get at the path name for each Node.

              print str(DEFAULT_TARGETS[0])
              if 'foo' in map(str, DEFAULT_TARGETS):
                  print "Don't forget to test the `foo' program!"

              The contents of the DDEEFFAAUULLTT__TTAARRGGEETTSS list change on on each  suc-
              cessive call to the DDeeffaauulltt() function:

              print map(str, DEFAULT_TARGETS)   # originally []
              Default('foo')
              print map(str, DEFAULT_TARGETS)   # now a node ['foo']
              Default('bar')
              print map(str, DEFAULT_TARGETS)   # now a node ['foo', 'bar']
              Default(None)
              print map(str, DEFAULT_TARGETS)   # back to []

              Consequently,  be  sure to use DDEEFFAAUULLTT__TTAARRGGEETTSS only after you've
              made all of your DDeeffaauulltt() calls, or else simply be  careful  of
              the  order  of these statements in your SConscript files so that
              you don't look for a specific default target before  it's  actu-
              ally been added to the list.


   CCoonnssttrruuccttiioonn VVaarriiaabblleess
       A construction environment has an associated dictionary of _c_o_n_s_t_r_u_c_t_i_o_n
       _v_a_r_i_a_b_l_e_s that are used by built-in or user-supplied build rules.  Con-
       struction  variables must follow the same rules for Python identifiers:
       the initial character must be an underscore or letter, followed by  any
       number of underscores, letters, or digits.

       A  number of useful construction variables are automatically defined by
       scons for each supported platform, and  additional  construction  vari-
       ables  can be defined by the user. The following is a list of the auto-
       matically defined construction variables:


       AR     The static library archiver.


       ARCOM  The command line used to generate a static library  from  object
              files.


       ARCOMSTR
              The  string  displayed  when an object file is generated from an
              assembly-language source file.  If this is not set, then  $ARCOM
              (the command line) is displayed.

              env = Environment(ARCOMSTR = "Archiving $TARGET")


       ARFLAGS
              General options passed to the static library archiver.


       AS     The assembler.


       ASCOM  The  command line used to generate an object file from an assem-
              bly-language source file.


       ASCOMSTR
              The string displayed when an object file is  generated  from  an
              assembly-language  source file.  If this is not set, then $ASCOM
              (the command line) is displayed.

              env = Environment(ASCOMSTR = "Assembling $TARGET")


       ASFLAGS
              General options passed to the assembler.


       ASPPCOM
              The command line used to assemble  an  assembly-language  source
              file  into  an  object file after first running the file through
              the C preprocessor.  Any options specified in the  $ASFLAGS  and
              $CPPFLAGS  construction  variables  are included on this command
              line.


       ASPPCOMSTR
              The string displayed when an object file is  generated  from  an
              assembly-language  source  file  after  first  running  the file
              through the C preprocessor.  If this is not set,  then  $ASPPCOM
              (the command line) is displayed.

              env = Environment(ASPPCOMSTR = "Assembling $TARGET")


       ASPPFLAGS
              General  options  when an assembling an assembly-language source
              file into an object file after first running  the  file  through
              the  C  preprocessor.   The  default  is  to  use  the  value of
              $ASFLAGS.


       BIBTEX The bibliography generator for the TeX formatter and  typesetter
              and the LaTeX structured formatter and typesetter.


       BIBTEXCOM
              The command line used to call the bibliography generator for the
              TeX formatter and typesetter and the LaTeX structured  formatter
              and typesetter.


       BIBTEXCOMSTR
              The  string  displayed when generating a bibliography for TeX or
              LaTeX.  If this is not set, then $BIBTEXCOM (the  command  line)
              is displayed.

              env = Environment(BIBTEXCOMSTR = "Generating bibliography $TARGET")



       BIBTEXFLAGS
              General options passed to the bibliography generator for the TeX
              formatter and typesetter and the LaTeX structured formatter  and
              typesetter.


       BITKEEPER
              The BitKeeper executable.


       BITKEEPERCOM
              The command line for fetching source files using BitKeeper.


       BITKEEPERCOMSTR
              The  string  displayed  when  fetching  a source file using Bit-
              Keeper.  If this is not set,  then  $BITKEEPERCOM  (the  command
              line) is displayed.


       BITKEEPERGET
              The  command  ($BITKEEPER)  and  subcommand  for fetching source
              files using BitKeeper.


       BITKEEPERGETFLAGS
              Options that are passed to the BitKeeper ggeett subcommand.


       BUILDERS
              A dictionary mapping the names of the builders available through
              this  environment to underlying Builder objects.  Builders named
              Alias, CFile, CXXFile, DVI, Library,  Object,  PDF,  PostScript,
              and  Program  are  available by default.  If you initialize this
              variable when an Environment is created:

              env = Environment(BUILDERS = {'NewBuilder' : foo})

              the default Builders will no longer be available.  To use a  new
              Builder object in addition to the default Builders, add your new
              Builder object like this:

              env = Environment()
              env.Append(BUILDERS = {'NewBuilder' : foo})

              or this:

              env = Environment()
              env['BUILDERS]['NewBuilder'] = foo


       CC     The C compiler.


       CCCOM  The command line used to compile a C source file to  a  (static)
              object   file.   Any  options  specified  in  the  $CCFLAGS  and
              $CPPFLAGS construction variables are included  on  this  command
              line.


       CCCOMSTR
              The  string  displayed  when  a  C  source file is compiled to a
              (static) object file.  If this is not set, then $CCCOM (the com-
              mand line) is displayed.

              env = Environment(CCCOMSTR = "Compiling static object $TARGET")


       CCFLAGS
              General options that are passed to the C compiler.


       CFILESUFFIX
              The  suffix  for  C  source files.  This is used by the internal
              CFile builder when generating C files from Lex (.l) or YACC (.y)
              input files.  The default suffix, of course, is _._c (lower case).
              On case-insensitive systems (like Win32), SCons also  treats  _._C
              (upper case) files as C files.


       CCVERSION
              The  version  number  of the C compiler.  This may or may not be
              set, depending on the specific C compiler being used.


       _concat
              A function used to  produce  variables  like  $_CPPINCFLAGS.  It
              takes  four or five arguments: a prefix to concatenate onto each
              element, a list of elements, a suffix to concatenate  onto  each
              element,  an  environment  for  variable  interpolation,  and an
              optional function that will be  called  to  transform  the  list
              before concatenation.

              env['_CPPINCFLAGS'] = '$( ${_concat(INCPREFIX, CPPPATH, INCSUFFIX, __env__, RDirs)} $)',


       CPPDEFINES
              A  platform  independent specification of C preprocessor defini-
              tions.  The definitions will be added to command  lines  through
              the  automatically-generated $_CPPDEFFLAGS construction variable
              (see below), which is constructed according to the type of value
              of $CPPDEFINES:


              If  $CPPDEFINES is a string, the values of the $CPPDEFPREFIX and
              $CPPDEFSUFFIX  construction  variables  will  be  added  to  the
              beginning and end.

              # Will add -Dxyz to POSIX compiler command lines,
              # and /Dxyz to Microsoft Visual C++ command lines.
              env = Environment(CPPDEFINES='xyz')


              If  $CPPDEFINES  is  a list, the values of the $CPPDEFPREFIX and
              $CPPDEFSUFFIX construction variables will  be  appended  to  the
              beginning  and  end of each element in the list.  If any element
              is a list or tuple, then  the  first  item  is  the  name  being
              defined and the second item is its value:

              # Will add -DB=2 -DA to POSIX compiler command lines,
              # and /DB=2 /DA to Microsoft Visual C++ command lines.
              env = Environment(CPPDEFINES=[('B', 2), 'A'])


              If  $CPPDEFINES is a dictionary, the values of the $CPPDEFPREFIX
              and $CPPDEFSUFFIX construction variables will be appended to the
              beginning  and end of each item from the dictionary.  The key of
              each dictionary item is a name being defined to  the  dictionary
              item's  corresponding value; if the value is NNoonnee, then the name
              is defined without an explicit value.  Note that  the  resulting
              flags  are  sorted  by  keyword  to ensure that the order of the
              options on the command line is consistent each time ssccoonnss
               is run.

              # Will add -DA -DB=2 to POSIX compiler command lines,
              # and /DA /DB=2 to Microsoft Visual C++ command lines.
              env = Environment(CPPDEFINES={'B':2, 'A':None})


       _CPPDEFFLAGS
              An automatically-generated construction variable containing  the
              C preprocessor command-line options to define values.  The value
              of $_CPPDEFFLAGS  is  created  by  appending  $CPPDEFPREFIX  and
              $CPPDEFSUFFIX  to  the  beginning  and  end of each directory in
              $CPPDEFINES.


       CPPDEFPREFIX
              The prefix used to specify preprocessor  definitions  on  the  C
              compiler  command  line.  This will be appended to the beginning
              of each definition in the $CPPDEFINES construction variable when
              the $_CPPDEFFLAGS variable is automatically generated.


       CPPDEFSUFFIX
              The  suffix  used  to  specify preprocessor definitions on the C
              compiler command line.  This will be appended to the end of each
              definition  in  the  $CPPDEFINES  construction variable when the
              $_CPPDEFFLAGS variable is automatically generated.


       CPPFLAGS
              User-specified C preprocessor options.  These will  be  included
              in  any command that uses the C preprocessor, including not just
              compilation of C and C++ source files via the $CCCOM,  $SHCCCOM,
              $CXXCOM and $SHCXXCOM command lines, but also the $FORTRANPPCOM,
              $SHFORTRANPPCOM, $F77PPCOM and $SHF77PPCOM command lines used to
              compile  a  Fortran  source  file, and the $ASPPCOM command line
              used to assemble an assembly language source file,  after  first
              running  each  file  through the C preprocessor.  Note that this
              variable does _n_o_t contain --II (or similar)  include  search  path
              options  that  scons generates automatically from $CPPPATH.  See
              __CCPPPPIINNCCFFLLAAGGSS, below, for the  variable  that  expands  to  those
              options.


       _CPPINCFLAGS
              An  automatically-generated construction variable containing the
              C preprocessor command-line options for  specifying  directories
              to be searched for include files.  The value of $_CPPINCFLAGS is
              created by appending $INCPREFIX and $INCSUFFIX to the  beginning
              and end of each directory in $CPPPATH.


       CPPPATH
              The  list of directories that the C preprocessor will search for
              include directories. The C/C++ implicit dependency scanner  will
              search these directories for include files. Don't explicitly put
              include directory arguments in CCFLAGS or CXXFLAGS  because  the
              result  will  be  non-portable  and  the directories will not be
              searched by the dependency scanner.  Note:  directory  names  in
              CPPPATH  will  be looked-up relative to the SConscript directory
              when they are used in a command. To force  ssccoonnss  to  look-up  a
              directory relative to the root of the source tree use #:

              env = Environment(CPPPATH='#/include')


              The  directory  look-up can also be forced using the DDiirr() func-
              tion:

              include = Dir('include')
              env = Environment(CPPPATH=include)


              The directory list will be added to command  lines  through  the
              automatically-generated   $_CPPINCFLAGS  construction  variable,
              which is constructed by appending the values of  the  $INCPREFIX
              and  $INCSUFFIX  construction variables to the beginning and end
              of each directory in $CPPPATH.  Any  command  lines  you  define
              that   need   the   CPPPATH   directory   list   should  include
              $_CPPINCFLAGS:

              env = Environment(CCCOM="my_compiler $_CPPINCFLAGS -c -o $TARGET $SOURCE")


       CPPSUFFIXES
              The list of suffixes of files that will be scanned for C prepro-
              cessor implicit dependencies (#include lines).  The default list
              is:

              [".c", ".C", ".cxx", ".cpp", ".c++", ".cc",
               ".h", ".H", ".hxx", ".hpp", ".hh",
               ".F", ".fpp", ".FPP",
               ".m", ".mm",
               ".S", ".spp", ".SPP"]


       CVS    The CVS executable.


       CVSCOFLAGS
              Options that are passed to the CVS checkout subcommand.


       CVSCOM The command line used to fetch source files from a  CVS  reposi-
              tory.


       CVSCOMSTR
              The  string  displayed  when  fetching  a source file from a CVS
              repository.  If this is not set, then $CVSCOM (the command line)
              is displayed.


       CVSFLAGS
              General options that are passed to CVS.  By default, this is set
              to "-d $CVSREPOSITORY" to specify from where the files  must  be
              fetched.


       CVSREPOSITORY
              The  path  to  the  CVS  repository.   This is referenced in the
              default $CVSFLAGS value.


       CXX    The C++ compiler.


       CXXFILESUFFIX
              The suffix for C++ source files.  This is used by  the  internal
              CXXFile builder when generating C++ files from Lex (.ll) or YACC
              (.yy) input files.  The  default  suffix  is  _._c_c.   SCons  also
              treats files with the suffixes _._c_p_p, _._c_x_x, _._c_+_+, and _._C_+_+ as C++
              files, and files with _._m_m suffixes as Objective C++  files.   On
              case-sensitive  systems  (Linux,  UNIX, and other POSIX-alikes),
              SCons also treats _._C (upper case) files as C++ files.


       CXXCOM The command line used to compile a C++ source file to an  object
              file.  Any options specified in the $CXXFLAGS and $CPPFLAGS con-
              struction variables are included on this command line.


       CXXCOMSTR
              The string displayed when a C++ source file  is  compiled  to  a
              (static)  object  file.   If  this is not set, then $CXXCOM (the
              command line) is displayed.

              env = Environment(CXXCOMSTR = "Compiling static object $TARGET")


       CXXFLAGS
              General options  that  are  passed  to  the  C++  compiler.   By
              default,  this  includes  the value of $CCFLAGS, so that setting
              $CCFLAGS affects both C and C++ compilation.  If you want to add
              C++-specific  flags,  you  must  set  or  override  the value of
              $CXXFLAGS.


       CXXVERSION
              The version number of the C++ compiler.  This may or may not  be
              set, depending on the specific C++ compiler being used.


       Dir    A  function  that converts a string into a Dir instance relative
              to the target being built.


       Dirs   A function that converts a list of strings into a  list  of  Dir
              instances relative to the target being built.


       DSUFFIXES
              The  list of suffixes of files that will be scanned for imported
              D package files.  The default list is:

              ['.d']


       DVIPDF The TeX DVI file to PDF file converter.


       DVIPDFFLAGS
              General options passed to the TeX DVI  file  to  PDF  file  con-
              verter.


       DVIPDFCOM
              The  command line used to convert TeX DVI files into a PDF file.


       DVIPDFCOMSTR
              The string displayed when a TeX DVI file is converted into a PDF
              file.  If this is not set, then $DVIPDFCOM (the command line) is
              displayed.


       DVIPS  The TeX DVI file to PostScript converter.


       DVIPSFLAGS
              General options passed to the TeX DVI file  to  PostScript  con-
              verter.


       ENV    A  dictionary of environment variables to use when invoking com-
              mands. When ENV is used in a command all  list  values  will  be
              joined  using the path separator and any other non-string values
              will simply be coerced to a  string.   Note  that,  by  default,
              ssccoonnss  does _n_o_t propagate the environment in force when you exe-
              cute ssccoonnss to the commands used to build target files.  This  is
              so  that  builds will be guaranteed repeatable regardless of the
              environment variables set at the time ssccoonnss is invoked.

              If you want to propagate your environment variables to the  com-
              mands executed to build target files, you must do so explicitly:

              import os
              env = Environment(ENV = os.environ)

              Note that you can choose only to propagate  certain  environment
              variables.   A  common  example  is  the system PPAATTHH environment
              variable, so that ssccoonnss uses the same utilities as the  invoking
              shell (or other process):

              import os
              env = Environment(ENV = {'PATH' : os.environ['PATH']})


       ESCAPE A  function  that will be called to escape shell special charac-
              ters in command lines. The function should  take  one  argument:
              the command line string to escape; and should return the escaped
              command line.


       F77    The Fortran 77 compiler.  You should normally set  the  $FORTRAN
              variable,  which  specifies the default Fortran compiler for all
              Fortran versions.  You only need to set $F77 if you need to  use
              a specific compiler or compiler version for Fortran 77 files.


       F77COM The  command line used to compile a Fortran 77 source file to an
              object file.  You only need to set $F77COM if you need to use  a
              specific command line for Fortran 77 files.  You should normally
              set the $FORTRANCOM variable, which specifies the  default  com-
              mand line for all Fortran versions.


       F77COMSTR
              The  string  displayed when a Fortran 77 source file is compiled
              to an object file.  If this is not set, then  $F77COM  or  $FOR-
              TRANCOM (the command line) is displayed.


       F77FLAGS
              General user-specified options that are passed to the Fortran 77
              compiler.  Note that this variable does _n_o_t contain --II (or simi-
              lar)  include search path options that scons generates automati-
              cally from $F77PATH.  See __FF7777IINNCCFFLLAAGGSS, below, for the  variable
              that  expands  to those options.  You only need to set $F77FLAGS
              if you need to define  specific  user  options  for  Fortran  77
              files.   You  should  normally  set  the $FORTRANFLAGS variable,
              which specifies the user-specified options passed to the default
              Fortran compiler for all Fortran versions.


       _F77INCFLAGS
              An  automatically-generated construction variable containing the
              Fortran 77 compiler command-line options for specifying directo-
              ries   to   be   searched  for  include  files.   The  value  of
              $_F77INCFLAGS is created by appending $INCPREFIX and  $INCSUFFIX
              to the beginning and end of each directory in $F77PATH.


       F77PATH
              The list of directories that the Fortran 77 compiler will search
              for include directories. The implicit  dependency  scanner  will
              search these directories for include files. Don't explicitly put
              include directory arguments in $F77FLAGS because the result will
              be  non-portable and the directories will not be searched by the
              dependency scanner. Note: directory names in  $F77PATH  will  be
              looked-up  relative  to  the  SConscript directory when they are
              used in a command. To force ssccoonnss to look-up a  directory  rela-
              tive  to the root of the source tree use #: You only need to set
              $F77PATH if you need to define a specific include path for  For-
              tran  77  files.  You should normally set the $FORTRANPATH vari-
              able, which specifies the include path for the  default  Fortran
              compiler for all Fortran versions.

              env = Environment(F77PATH='#/include')


              The  directory  look-up can also be forced using the DDiirr() func-
              tion:

              include = Dir('include')
              env = Environment(F77PATH=include)


              The directory list will be added to command  lines  through  the
              automatically-generated   $_F77INCFLAGS  construction  variable,
              which is constructed by appending the values of  the  $INCPREFIX
              and  $INCSUFFIX  construction variables to the beginning and end
              of each directory in $F77PATH.  Any  command  lines  you  define
              that   need   the   F77PATH   directory   list   should  include
              $_F77INCFLAGS:

              env = Environment(F77COM="my_compiler $_F77INCFLAGS -c -o $TARGET $SOURCE")


       F77PPCOM
              The command line used to compile a Fortran 77 source file to  an
              object  file  after first running the file through the C prepro-
              cessor.  Any options specified in the  $F77FLAGS  and  $CPPFLAGS
              construction  variables  are included on this command line.  You
              only need to set $F77PPCOM if you need to use a specific  C-pre-
              processor  command  line  for Fortran 77 files.  You should nor-
              mally  set  the  $FORTRANPPCOM  variable,  which  specifies  the
              default C-preprocessor command line for all Fortran versions.


       F90    The  Fortran  90 compiler.  You should normally set the $FORTRAN
              variable, which specifies the default Fortran compiler  for  all
              Fortran  versions.  You only need to set $F90 if you need to use
              a specific compiler or compiler version for Fortran 90 files.


       F90COM The command line used to compile a Fortran 90 source file to  an
              object  file.  You only need to set $F90COM if you need to use a
              specific command line for Fortran 90 files.  You should normally
              set  the  $FORTRANCOM variable, which specifies the default com-
              mand line for all Fortran versions.


       F90COMSTR
              The string displayed when a Fortran 90 source file  is  compiled
              to  an  object  file.  If this is not set, then $F90COM or $FOR-
              TRANCOM (the command line) is displayed.


       F90FLAGS
              General user-specified options that are passed to the Fortran 90
              compiler.  Note that this variable does _n_o_t contain --II (or simi-
              lar) include search path options that scons generates  automati-
              cally  from $F90PATH.  See __FF9900IINNCCFFLLAAGGSS, below, for the variable
              that expands to those options.  You only need to  set  $F90FLAGS
              if  you  need  to  define  specific  user options for Fortran 90
              files.  You should  normally  set  the  $FORTRANFLAGS  variable,
              which specifies the user-specified options passed to the default
              Fortran compiler for all Fortran versions.


       _F90INCFLAGS
              An automatically-generated construction variable containing  the
              Fortran   90   compiler   command-line  options  for  specifying
              directories to be searched for  include  files.   The  value  of
              $_F90INCFLAGS  is created by appending $INCPREFIX and $INCSUFFIX
              to the beginning and end of each directory in $F90PATH.


       F90PATH
              The list of directories that the Fortran 90 compiler will search
              for  include  directories.  The implicit dependency scanner will
              search these directories for include files. Don't explicitly put
              include directory arguments in $F90FLAGS because the result will
              be non-portable and the directories will not be searched by  the
              dependency  scanner.  Note:  directory names in $F90PATH will be
              looked-up relative to the SConscript  directory  when  they  are
              used  in  a command. To force ssccoonnss to look-up a directory rela-
              tive to the root of the source tree use #: You only need to  set
              $F90PATH  if you need to define a specific include path for For-
              tran 90 files.  You should normally set the  $FORTRANPATH  vari-
              able,  which  specifies the include path for the default Fortran
              compiler for all Fortran versions.

              env = Environment(F90PATH='#/include')


              The directory look-up can also be forced using the  DDiirr()  func-
              tion:

              include = Dir('include')
              env = Environment(F90PATH=include)


              The  directory  list  will be added to command lines through the
              automatically-generated  $_F90INCFLAGS  construction   variable,
              which  is  constructed by appending the values of the $INCPREFIX
              and $INCSUFFIX construction variables to the beginning  and  end
              of  each  directory  in  $F90PATH.  Any command lines you define
              that  need   the   F90PATH   directory   list   should   include
              $_F90INCFLAGS:

              env = Environment(F90COM="my_compiler $_F90INCFLAGS -c -o $TARGET $SOURCE")


       F90PPCOM
              The  command line used to compile a Fortran 90 source file to an
              object file after first running the file through the  C  prepro-
              cessor.   Any  options  specified in the $F90FLAGS and $CPPFLAGS
              construction variables are included on this command  line.   You
              only  need to set $F90PPCOM if you need to use a specific C-pre-
              processor command line for Fortran 90 files.   You  should  nor-
              mally  set  the  $FORTRANPPCOM  variable,  which  specifies  the
              default C-preprocessor command line for all Fortran versions.


       F95    The Fortran 95 compiler.  You should normally set  the  $FORTRAN
              variable,  which  specifies the default Fortran compiler for all
              Fortran versions.  You only need to set $F95 if you need to  use
              a specific compiler or compiler version for Fortran 95 files.


       F95COM The  command line used to compile a Fortran 95 source file to an
              object file.  You only need to set $F95COM if you need to use  a
              specific command line for Fortran 95 files.  You should normally
              set the $FORTRANCOM variable, which specifies the  default  com-
              mand line for all Fortran versions.


       F95COMSTR
              The  string  displayed when a Fortran 95 source file is compiled
              to an object file.  If this is not set, then  $F95COM  or  $FOR-
              TRANCOM (the command line) is displayed.


       F95FLAGS
              General user-specified options that are passed to the Fortran 95
              compiler.  Note that this variable does _n_o_t contain --II (or simi-
              lar)  include search path options that scons generates automati-
              cally from $F95PATH.  See __FF9955IINNCCFFLLAAGGSS, below, for the  variable
              that  expands  to those options.  You only need to set $F95FLAGS
              if you need to define  specific  user  options  for  Fortran  95
              files.   You  should  normally  set  the $FORTRANFLAGS variable,
              which specifies the user-specified options passed to the default
              Fortran compiler for all Fortran versions.


       _F95INCFLAGS
              An  automatically-generated construction variable containing the
              Fortran 95 compiler command-line options for specifying directo-
              ries   to   be   searched  for  include  files.   The  value  of
              $_F95INCFLAGS is created by appending $INCPREFIX and  $INCSUFFIX
              to the beginning and end of each directory in $F95PATH.


       F95PATH
              The list of directories that the Fortran 95 compiler will search
              for include directories. The implicit  dependency  scanner  will
              search these directories for include files. Don't explicitly put
              include directory arguments in $F95FLAGS because the result will
              be  non-portable and the directories will not be searched by the
              dependency scanner. Note: directory names in  $F95PATH  will  be
              looked-up  relative  to  the  SConscript directory when they are
              used in a command. To force ssccoonnss to look-up a  directory  rela-
              tive  to the root of the source tree use #: You only need to set
              $F95PATH if you need to define a specific include path for  For-
              tran  95  files.  You should normally set the $FORTRANPATH vari-
              able, which specifies the include path for the  default  Fortran
              compiler for all Fortran versions.

              env = Environment(F95PATH='#/include')


              The  directory  look-up can also be forced using the DDiirr() func-
              tion:

              include = Dir('include')
              env = Environment(F95PATH=include)


              The directory list will be added to command  lines  through  the
              automatically-generated   $_F95INCFLAGS  construction  variable,
              which is constructed by appending the values of  the  $INCPREFIX
              and  $INCSUFFIX  construction variables to the beginning and end
              of each directory in $F95PATH.  Any  command  lines  you  define
              that   need   the   F95PATH   directory   list   should  include
              $_F95INCFLAGS:

              env = Environment(F95COM="my_compiler $_F95INCFLAGS -c -o $TARGET $SOURCE")


       F95PPCOM
              The command line used to compile a Fortran 95 source file to  an
              object  file  after first running the file through the C prepro-
              cessor.  Any options specified in the  $F95FLAGS  and  $CPPFLAGS
              construction  variables  are included on this command line.  You
              only need to set $F95PPCOM if you need to use a specific  C-pre-
              processor  command  line  for Fortran 95 files.  You should nor-
              mally  set  the  $FORTRANPPCOM  variable,  which  specifies  the
              default C-preprocessor command line for all Fortran versions.


       FORTRAN
              The default Fortran compiler for all versions of Fortran.


       FORTRANCOM
              The  command  line  used  to compile a Fortran source file to an
              object file.  By default, any options specified in the $FORTRAN-
              FLAGS,  $CPPFLAGS,  $_CPPDEFFLAGS,  $_FORTRANMODFLAG, and $_FOR-
              TRANINCFLAGS construction variables are included on this command
              line.


       FORTRANCOMSTR
              The  string  displayed when a Fortran source file is compiled to
              an object file.  If this is not set, then $FORTRANCOM (the  com-
              mand line) is displayed.


       FORTRANFLAGS
              General  user-specified  options  that are passed to the Fortran
              compiler.  Note that this variable does _n_o_t contain --II (or simi-
              lar)  include or module search path options that scons generates
              automatically from $FORTRANPATH.   See  __FFOORRTTRRAANNIINNCCFFLLAAGGSSand__FFOORR--
              TTRRAANNMMOODDFFLLAAGGSS,,   below,  for  the  variables  that  expand  those
              options.


       _FORTRANINCFLAGS
              An automatically-generated construction variable containing  the
              Fortran compiler command-line options for specifying directories
              to be searched for include files and module files.  The value of
              $_FORTRANINCFLAGS  is created by prepending/appending $INCPREFIX
              and $INCSUFFIX to the beginning and end  of  each  directory  in
              $FORTRANPATH.


       FORTRANMODDIR
              Directory  location  where the Fortran compiler should place any
              module files it generates.  This variable is empty, by  default.
              Some  Fortran compilers will internally append this directory in
              the search path for module files, as well.


       FORTRANMODDIRPREFIX
              The prefix used to specify a module  directory  on  the  Fortran
              compiler  command  line.  This will be appended to the beginning
              of the directory in the  $FORTRANMODDIR  construction  variables
              when  the $_FORTRANMODFLAG variables is automatically generated.


       FORTRANMODDIRSUFFIX
              The suffix used to specify a module  directory  on  the  Fortran
              compiler  command  line.  This will be appended to the beginning
              of the directory in the  $FORTRANMODDIR  construction  variables
              when  the $_FORTRANMODFLAG variables is automatically generated.


       _FORTRANMODFLAG
              An automatically-generated construction variable containing  the
              Fortran  compiler  command-line option for specifying the direc-
              tory location where the Fortran compiler should place any module
              files  that  happen  to  get  generated during compilation.  The
              value of $_FORTRANMODFLAG  is  created  by  prepending/appending
              $FORTRANMODDIRPREFIX  and  $FORTRANMODDIRSUFFIX to the beginning
              and end of the directory in $FORTRANMODDIR.


       FORTRANMODPREFIX
              The module file prefix used  by  the  Fortran  compiler.   SCons
              assumes  that  the  Fortran  compiler follows the quasi-standard
              naming convention for module files of _<_m_o_d_u_l_e___n_a_m_e_>_._m_o_d_.   As  a
              result, this variable is left empty, by default.  For situations
              in which the compiler does not  necessarily  follow  the  normal
              convention,  the  user may use this variable.  Its value will be
              appended to every module file name as scons attempts to  resolve
              dependencies.


       FORTRANMODSUFFIX
              The  module  file  suffix  used  by the Fortran compiler.  SCons
              assumes that the Fortran  compiler  follows  the  quasi-standard
              naming  convention  for module files of _<_m_o_d_u_l_e___n_a_m_e_>_._m_o_d_.  As a
              result, this variable is set to ".mod", by default.  For  situa-
              tions in which the compiler does not necessarily follow the nor-
              mal convention, the user may use this variable.  Its value  will
              be  appended  to  every  module  file  name as scons attempts to
              resolve dependencies.


       FORTRANPATH
              The list of directories that the Fortran  compiler  will  search
              for  include  files  and  (for some compilers) module files. The
              Fortran implicit dependency scanner will search  these  directo-
              ries  for  include  files  (but  not module files since they are
              autogenerated and, as such, may not actually exist at  the  time
              the  scan  takes  place). Don't explicitly put include directory
              arguments in  FORTRANFLAGS  because  the  result  will  be  non-
              portable  and the directories will not be searched by the depen-
              dency scanner. Note: directory  names  in  FORTRANPATH  will  be
              looked-up  relative  to  the  SConscript directory when they are
              used in a command. To force ssccoonnss to look-up a  directory  rela-
              tive to the root of the source tree use #:

              env = Environment(FORTRANPATH='#/include')


              The  directory  look-up can also be forced using the DDiirr() func-
              tion:

              include = Dir('include')
              env = Environment(FORTRANPATH=include)


              The directory list will be added to command  lines  through  the
              automatically-generated $_FORTRANINCFLAGS construction variable,
              which is constructed by appending the values of  the  $INCPREFIX
              and  $INCSUFFIX  construction variables to the beginning and end
              of each directory in $FORTRANPATH.  Any command lines you define
              that  need  the FORTRANPATH directory list should include $_FOR-
              TRANINCFLAGS:

              env = Environment(FORTRANCOM="my_compiler $_FORTRANINCFLAGS -c -o $TARGET $SOURCE")


       FORTRANPPCOM
              The command line used to compile a Fortran  source  file  to  an
              object  file  after first running the file through the C prepro-
              cessor.  By default, any options specified in the $FORTRANFLAGS,
              $CPPFLAGS, _CPPDEFFLAGS, $_FORTRANMODFLAG, and $_FORTRANINCFLAGS
              construction variables are included on this command line.


       FORTRANSUFFIXES
              The list of suffixes of files that will be scanned  for  Fortran
              implicit  dependencies  (INCLUDE  lines  & USE statements).  The
              default list is:

              [".f", ".F", ".for", ".FOR", ".ftn", ".FTN", ".fpp", ".FPP",
              ".f77", ".F77", ".f90", ".F90", ".f95", ".F95"]


       File   A function that converts a string into a File instance  relative
              to the target being built.


       FRAMEWORKPATH
              On  Mac OS X with gcc, a list containing the paths to search for
              frameworks.   Used  by  the  compiler  to  find  framework-style
              includes  like  #include <Fmwk/Header.h>.  Used by the linker to
              find user-specified frameworks when linking  (see  $FRAMEWORKS).
              For example:
               env.AppendUnique(FRAMEWORKPATH='#myframeworkdir')

              will add
                ... -Fmyframeworkdir

              to the compiler and linker command lines.


       _FRAMEWORKPATH
              On  Mac  OS  X with gcc, an automatically-generated construction
              variable containing the linker command-line options  correspond-
              ing to FRAMEWORKPATH.


       FRAMEWORKPATHPREFIX
              On  Mac  OS X with gcc, the prefix to be used for the FRAMEWORK-
              PATH entries.  (see $FRAMEWORKPATH).  The default value is --FF.


       FRAMEWORKPREFIX
              On Mac OS X with gcc, the prefix  to  be  used  for  linking  in
              frameworks  (see $FRAMEWORKS).  The default value is --ffrraammeewwoorrkk.


       FRAMEWORKS
              On Mac OS X with gcc, a list of the framework names to be linked
              into  a  program or shared library or bundle.  The default value
              is the empty list.  For example:
               env.AppendUnique(FRAMEWORKS=Split('System Cocoa SystemConfiguration'))


       _FRAMEWORKS
              On Mac OS X with gcc,  an  automatically-generated  construction
              variable  containing the linker command-line options for linking
              with FRAMEWORKS.


       FRAMEWORKSFLAGS
              On Mac OS X with gcc, general user-supplied  frameworks  options
              to  be  added  at  the end of a command line building a loadable
              module.  (This has been largely superceded  by  the  $FRAMEWORK-
              PATH,   $FRAMEWORKPATHPREFIX,  $FRAMWORKPREFIX  and  $FRAMEWORKS
              variables described above.)


       GS     The Ghostscript program used to convert PostScript to PDF files.


       GSFLAGS
              General  options passed to the Ghostscript program when convert-
              ing PostScript to PDF files.


       GSCOM  The Ghostscript command line used to convert PostScript  to  PDF
              files.


       GSCOMSTR
              The  string  displayed  when  Ghostscript  is  used to convert a
              PostScript file to a PDF file.  If this is not set, then  $GSCOM
              (the command line) is displayed.


       IDLSUFFIXES
              The  list  of  suffixes  of  files  that will be scanned for IDL
              implicit dependencies (#include or import lines).   The  default
              list is:

              [".idl", ".IDL"]


       INCPREFIX
              The  prefix  used  to specify an include directory on the C com-
              piler command line.  This will be appended to the  beginning  of
              each  directory  in  the  $CPPPATH and $FORTRANPATH construction
              variables when the $_CPPINCFLAGS and $_FORTRANINCFLAGS variables
              are automatically generated.


       INCSUFFIX
              The  suffix  used  to specify an include directory on the C com-
              piler command line.  This will be appended to the  end  of  each
              directory  in  the  $CPPPATH and $FORTRANPATH construction vari-
              ables when the $_CPPINCFLAGS and $_FORTRANINCFLAGS variables are
              automatically generated.


       INSTALL
              A  function  to  be  called to install a file into a destination
              file name.  The default function copies the file into the desti-
              nation (and sets the destination file's mode and permission bits
              to match the source file's).  The function takes  the  following
              arguments:

              def install(dest, source, env):

              _d_e_s_t  is  the  path name of the destination file.  _s_o_u_r_c_e is the
              path name of the source file.  _e_n_v is the construction  environ-
              ment  (a  dictionary  of  construction values) in force for this
              file installation.


       INTEL_C_COMPILER_VERSION
              Set by the "intelc" Tool to the  major  version  number  of  the
              Intel C compiler selected for use.


       JAR    The Java archive tool.


       JARCHDIR
              The  directory  to  which  the  Java  archive tool should change
              (using the --CC option).


       JARCOM The command line used to call the Java archive tool.


       JARCOMSTR
              The string displayed when the Java archive  tool  is  called  If
              this is not set, then $JARCOM (the command line) is displayed.

              env = Environment(JARCOMSTR = "JARchiving $SOURCES into $TARGET")


       JARFLAGS
              General  options  passed  to  the Java archive tool.  By default
              this is set to ccff to create the necessary _j_a_r file.


       JARSUFFIX
              The suffix for Java archives: ..jjaarr by default.


       JAVAC  The Java compiler.


       JAVACCOM
              The command line used to compile  a  directory  tree  containing
              Java  source  files  to  corresponding  Java  class  files.  Any
              options specified in the $JAVACFLAGS construction  variable  are
              included on this command line.


       JAVACCOMSTR
              The  string  displayed  when  compiling a directory tree of Java
              source files to corresponding Java class files.  If this is  not
              set, then $JAVACCOM (the command line) is displayed.

              env = Environment(JAVACCOMSTR = "Compiling class files $TARGETS from $SOURCES")


       JAVACFLAGS
              General options that are passed to the Java compiler.


       JAVACLASSDIR
              The  directory  in which Java class files may be found.  This is
              stripped from the beginning of any Java .class file  names  sup-
              plied to the JJaavvaaHH builder.


       JAVACLASSSUFFIX
              The suffix for Java class files; ..ccllaassss by default.


       JAVAH  The Java generator for C header and stub files.


       JAVAHCOM
              The  command  line used to generate C header and stub files from
              Java classes.  Any options specified  in  the  $JAVAHFLAGS  con-
              struction variable are included on this command line.


       JAVAHCOMSTR
              The  string displayed when C header and stub files are generated
              from Java classes.  If this is not set, then $JAVAHCOM (the com-
              mand line) is displayed.

              env = Environment(JAVAHCOMSTR = "Generating header/stub file(s) $TARGETS from $SOURCES")


       JAVAHFLAGS
              General  options  passed to the C header and stub file generator
              for Java classes.


       JAVASUFFIX
              The suffix for Java files; ..jjaavvaa by default.


       LATEX  The LaTeX structured formatter and typesetter.


       LATEXCOM
              The command line used to call the LaTeX structured formatter and
              typesetter.


       LATEXCOMSTR
              The string displayed when calling the LaTeX structured formatter
              and typesetter.  If this is not set, then $LATEXCOM (the command
              line) is displayed.

              env = Environment(LATEXCOMSTR = "Building $TARGET from LaTeX input $SOURCES")


       LATEXFLAGS
              General  options  passed  to  the LaTeX structured formatter and
              typesetter.


       LDMODULE
              The linker for building loadable modules.  By default,  this  is
              the same as $SHLINK.


       LDMODULECOM
              The  command  line  for building loadable modules.  On Mac OS X,
              this uses the  $LDMODULE,  $LDMODULEFLAGS  and  $FRAMEWORKSFLAGS
              variables.  On other systems, this is the same as $SHLINK.


       LDMODULECOMSTR
              The string displayed when building loadable modules.  If this is
              not set, then $LDMODULECOM (the command line) is displayed.


       LDMODULEFLAGS
              General user options passed to the linker for building  loadable
              modules.


       LDMODULEPREFIX
              The  prefix  used  for loadable module file names.  On Mac OS X,
              this is null; on other systems, this is the same  as  $SHLIBPRE-
              FIX.


       LDMODULESUFFIX
              The  suffix  used  for loadable module file names.  On Mac OS X,
              this is null; on other systems, this is the same  as  $SHLIBSUF-
              FIX.


       LEX    The lexical analyzer generator.


       LEXFLAGS
              General options passed to the lexical analyzer generator.


       LEXCOM The  command line used to call the lexical analyzer generator to
              generate a source file.


       LEXCOMSTR
              The string displayed when generating a  source  file  using  the
              lexical  analyzer  generator.   If this is not set, then $LEXCOM
              (the command line) is displayed.

              env = Environment(LEXCOMSTR = "Lex'ing $TARGET from $SOURCES")


       _LIBDIRFLAGS
              An automatically-generated construction variable containing  the
              linker  command-line  options  for  specifying directories to be
              searched for library.  The value of $_LIBDIRFLAGS is created  by
              appending  $LIBDIRPREFIX  and $LIBDIRSUFFIX to the beginning and
              end of each directory in $LIBPATH.


       LIBDIRPREFIX
              The prefix used to specify a library  directory  on  the  linker
              command  line.   This  will be appended to the beginning of each
              directory in the $LIBPATH construction variable when the  $_LIB-
              DIRFLAGS variable is automatically generated.


       LIBDIRSUFFIX
              The  suffix  used  to  specify a library directory on the linker
              command line.  This will be appended to the end of  each  direc-
              tory  in  the  $LIBPATH  construction  variable  when the $_LIB-
              DIRFLAGS variable is automatically generated.


       _LIBFLAGS
              An automatically-generated construction variable containing  the
              linker  command-line  options  for  specifying  libraries  to be
              linked with the resulting target.  The value  of  $_LIBFLAGS  is
              created  by  appending  $LIBLINKPREFIX and $LIBLINKSUFFIX to the
              beginning and end of each filename in $LIBS.


       LIBLINKPREFIX
              The prefix used to specify a library to link on the linker  com-
              mand  line.   This  will  be  appended  to the beginning of each
              library in the $LIBS construction variable when  the  $_LIBFLAGS
              variable is automatically generated.


       LIBLINKSUFFIX
              The  suffix used to specify a library to link on the linker com-
              mand line.  This will be appended to the end of each library  in
              the  $LIBS construction variable when the $_LIBFLAGS variable is
              automatically generated.


       LIBPATH
              The list of directories that will  be  searched  for  libraries.
              The  implicit  dependency  scanner will search these directories
              for include files. Don't explicitly put include directory  argu-
              ments  in  $LINKFLAGS or $SHLINKFLAGS because the result will be
              non-portable and the directories will not  be  searched  by  the
              dependency  scanner.  Note:  directory  names in LIBPATH will be
              looked-up relative to the SConscript  directory  when  they  are
              used  in  a command. To force ssccoonnss to look-up a directory rela-
              tive to the root of the source tree use #:

              env = Environment(LIBPATH='#/libs')


              The directory look-up can also be forced using the  DDiirr()  func-
              tion:

              libs = Dir('libs')
              env = Environment(LIBPATH=libs)


              The  directory  list  will be added to command lines through the
              automatically-generated  $_LIBDIRFLAGS  construction   variable,
              which  is constructed by appending the values of the $LIBDIRPRE-
              FIX and $LIBDIRSUFFIX construction variables  to  the  beginning
              and  end  of  each directory in $LIBPATH.  Any command lines you
              define that need  the  LIBPATH  directory  list  should  include
              $_LIBDIRFLAGS:

              env = Environment(LINKCOM="my_linker $_LIBDIRFLAGS $_LIBFLAGS -o $TARGET $SOURCE")


       LIBPREFIX
              The  prefix  used  for  (static)  library file names.  A default
              value is set for each platform (posix, win32,  os2,  etc.),  but
              the  value  is overridden by individual tools (ar, mslib, sgiar,
              sunar, tlib, etc.)  to reflect the names of the  libraries  they
              create.


       LIBPREFIXES
              An array of legal prefixes for library file names.


       LIBS   A  list  of  one  or more libraries that will be linked with any
              executable programs created by this environment.


              The library list will be added  to  command  lines  through  the
              automatically-generated  $_LIBFLAGS construction variable, which
              is constructed by appending the values of the $LIBLINKPREFIX and
              $LIBLINKSUFFIX  construction  variables to the beginning and end
              of each filename in $LIBS.  Any command lines  you  define  that
              need the LIBS library list should include $_LIBFLAGS:

              env = Environment(LINKCOM="my_linker $_LIBDIRFLAGS $_LIBFLAGS -o $TARGET $SOURCE")


              If you add a File object to the LIBS list, the name of that file
              will be added to $_LIBFLAGS, and thus  the  link  line,  as  is,
              without $LIBLINKPREFIX or $LIBLINKSUFFIX.  For example:
              env.Append(LIBS=File('/tmp/mylib.so'))


              In  all  cases,  scons will add dependencies from the executable
              program to all the libraries in this list.


       LIBSUFFIX
              The suffix used for (static)  library  file  names.   A  default
              value  is  set  for each platform (posix, win32, os2, etc.), but
              the value is overridden by individual tools (ar,  mslib,  sgiar,
              sunar,  tlib,  etc.)  to reflect the names of the libraries they
              create.


       LIBSUFFIXES
              An array of legal suffixes for library file names.


       LINK   The linker.


       LINKFLAGS
              General user options passed to the linker.  Note that this vari-
              able should _n_o_t contain --ll (or similar) options for linking with
              the libraries listed in  $LIBS,  nor  --LL  (or  similar)  library
              search  path  options  that  scons  generates automatically from
              $LIBPATH.  See __LLIIBBFFLLAAGGSS, above, for the variable  that  expands
              to  library-link options, and __LLIIBBDDIIRRFFLLAAGGSS, above, for the vari-
              able that expands to library search path options.


       LINKCOM
              The command line used to link object files into an executable.


       LINKCOMSTR
              The string displayed when object files are linked into  an  exe-
              cutable.   If  this is not set, then $LINKCOM (the command line)
              is displayed.

              env = Environment(LINKCOMSTR = "Linking $TARGET")


       M4     The M4 macro preprocessor.


       M4FLAGS
              General options passed to the M4 macro preprocessor.


       M4COM  The command line used to pass files through the M4 macro prepro-
              cessor.


       M4COMSTR
              The  string displayed when a file is passed through the M4 macro
              preprocessor.  If this is not  set,  then  $M4COM  (the  command
              line) is displayed.


       MAXLINELENGTH
              The  maximum number of characters allowed on an external command
              line.  On Win32 systems, link lines longer than this many  char-
              acters are linke via a temporary file name.


       MSVS   When the Microsoft Visual Studio tools are initialized, they set
              up this dictionary with the following keys:

              VVEERRSSIIOONN:: the  version  of  MSVS  being  used  (can  be  set  via
              MSVS_VERSION)

              VVEERRSSIIOONNSS:: the available versions of MSVS installed

              VVCCIINNSSTTAALLLLDDIIRR:: installed directory of Visual C++

              VVSSIINNSSTTAALLLLDDIIRR:: installed directory of Visual Studio

              FFRRAAMMEEWWOORRKKDDIIRR:: installed directory of the .NET framework

              FFRRAAMMEEWWOORRKKVVEERRSSIIOONNSS:: list of installed versions of the .NET frame-
              work, sorted latest to oldest.

              FFRRAAMMEEWWOORRKKVVEERRSSIIOONN:: latest installed version of the .NET framework

              FFRRAAMMEEWWOORRKKSSDDKKDDIIRR:: installed location of the .NET SDK.

              PPLLAATTFFOORRMMSSDDKKDDIIRR:: installed location of the Platform SDK.

              PPLLAATTFFOORRMMSSDDKK__MMOODDUULLEESS::  dictionary  of installed Platform SDK mod-
              ules, where the dictionary keys are  keywords  for  the  various
              modules,  and  the  values  are  2-tuples where the first is the
              release date, and the second is the version number.

              If a value isn't set, it wasn't available in the registry.


       MSVS_IGNORE_IDE_PATHS
              Tells the MS Visual Studio tools to use  minimal  INCLUDE,  LIB,
              and PATH settings, instead of the settings from the IDE.

              For  Visual Studio, SCons will (by default) automatically deter-
              mine where MSVS is installed, and use the LIB, INCLUDE, and PATH
              variables  set  by  the  IDE.  You can override this behavior by
              setting these variables after Environment initialization, or  by
              setting MMSSVVSS__IIGGNNOORREE__IIDDEE__PPAATTHHSS == 11 in the Environment initializa-
              tion.  Specifying this will not leave these unset, but will  set
              them  to a minimal set of paths needed to run the tools success-
              fully.

              For VS6, the mininimal set is:
                 INCLUDE:'<VSDir>\VC98\ATL\include;<VSDir>\VC98\MFC\include;<VSDir>\VC98\include'
                 LIB:'<VSDir>\VC98\MFC\lib;<VSDir>\VC98\lib'
                 PATH:'<VSDir>\Common\MSDev98\bin;<VSDir>\VC98\bin'
              For VS7, it is:
                 INCLUDE:'<VSDir>\Vc7\atlmfc\include;<VSDir>\Vc7\include'
                 LIB:'<VSDir>\Vc7\atlmfc\lib;<VSDir>\Vc7\lib'
                 PATH:'<VSDir>\Common7\Tools\bin;<VSDir>\Common7\Tools;<VSDir>\Vc7\bin'


              Where '<VSDir>' is the installed location of Visual Studio.


       MSVS_USE_MFC_DIRS
              Tells the MS Visual Studio tool(s) to use the MFC directories in
              its default paths for compiling and linking.  Under MSVS version
              6, setting  MMSSVVSS__UUSSEE__MMFFCC__DDIIRRSS  to  a  non-zero  value  adds  the
              AATTLL\\iinncclluuddee  and  MMFFCC\\iinncclluuddee directories to the default IINNCCLLUUDDEE
              external environment variable, and adds the MMFFCC\\lliibb directory to
              the  default LLIIBB external environment variable.  Under MSVS ver-
              sion 7, setting MMSSVVSS__UUSSEE__MMFFCC__DDIIRRSS to a non-zero value  adds  the
              aattllmmffcc\\iinncclluuddee  directory  to the default IINNCCLLUUDDEE external envi-
              ronment variable, and  adds  the  aattllmmffcc\\lliibb  directory  to  the
              default  LLIIBB external environment variable.  The current default
              value is 11, which means these directories are added to the paths
              by  default.  This default value is likely to change in a future
              release, so users who want the ATL and MFC  values  included  in
              their paths are encouraged to enable the MMSSVVSS__UUSSEE__MMFFCC__DDIIRRSS value
              explicitly to avoid future incompatibility.  This  variable  has
              no  effect  if  the IINNCCLLUUDDEE or LLIIBB environment variables are set
              explictly.


       MSVS_VERSION
              Sets the preferred version of MSVS to use.

              SCons will (by  default)  select  the  latest  version  of  MSVS
              installed  on  your machine.  So, if you have version 6 and ver-
              sion 7 (MSVS .NET) installed, it will prefer version 7.  You can
              override  this  by  specifying  the MMSSVVSS__VVEERRSSIIOONN variable in the
              Environment initialization, setting it to the  appropriate  ver-
              sion  ('6.0' or '7.0', for example).  If the given version isn't
              installed, tool initialization will fail.


       MSVSPROJECTCOM
              The action used to generate Microsoft Visual Studio project  and
              solution files.


       MSVSPROJECTSUFFIX
              The suffix used for Microsoft Visual Studio project (DSP) files.
              The default value is ..vvccpprroojj when using  Visual  Studio  version
              7.x  (.NET), and ..ddsspp when using earlier versions of Visual Stu-
              dio.


       MSVSSOLUTIONSUFFIX
              The suffix used  for  Microsoft  Visual  Studio  solution  (DSW)
              files.   The default value is ..ssllnn when using Visual Studio ver-
              sion 7.x (.NET), and ..ddssww when using earlier versions of  Visual
              Studio.


       MWCW_VERSION
              The  version  number of the MetroWerks CodeWarrior C compiler to
              be used.


       MWCW_VERSIONS
              A list of installed versions of  the  MetroWerks  CodeWarrior  C
              compiler on this system.


       no_import_lib
              When  set  to  non-zero,  suppresses creation of a corresponding
              Win32 static import lib by the SShhaarreeddLLiibbrraarryy builder  when  used
              with  MinGW  or  Microsoft  Visual Studio.  This also suppresses
              creation of an export (.exp) file when  using  Microsoft  Visual
              Studio.


       OBJPREFIX
              The prefix used for (static) object file names.


       OBJSUFFIX
              The suffix used for (static) object file names.


       P4     The Perforce executable.


       P4COM  The command line used to fetch source files from Perforce.


       P4COMSTR
              The  string displayed when fetching a source file from Perforce.
              If this is not set, then $P4COM (the command line) is displayed.


       P4FLAGS
              General options that are passed to Perforce.


       PCH    The  Microsoft  Visual  C++ precompiled header that will be used
              when compiling object files. This variable is ignored  by  tools
              other  than Microsoft Visual C++.  When this variable is defined
              SCons will add options to the compiler command line to cause  it
              to  use  the precompiled header, and will also set up the depen-
              dencies for the PCH file. Example:

              env['PCH'] = 'StdAfx.pch'


       PCHCOM The command line used by the PPCCHH builder to generated a  precom-
              piled header.


       PCHCOMSTR
              The  string  displayed when generating a precompiled header.  If
              this is not set, then $PCHCOM (the command line) is displayed.


       PCHSTOP
              This variable specifies how much of a  source  file  is  precom-
              piled.  This  variable  is ignored by tools other than Microsoft
              Visual C++, or when the PCH variable is  not  being  used.  When
              this  variable is define it must be a string that is the name of
              the header that is included at the end of the  precompiled  por-
              tion  of  the  source files, or the empty string if the "#pragma
              hrdstop" construct is being used:

              env['PCHSTOP'] = 'StdAfx.h'


       PDB    The Microsoft Visual C++ PDB  file  that  will  store  debugging
              information  for  object  files, shared libraries, and programs.
              This variable is ignored by tools other  than  Microsoft  Visual
              C++.   When  this  variable is defined SCons will add options to
              the compiler and linker command line to cause them  to  generate
              external  debugging information, and will also set up the depen-
              dencies for the PDB file. Example:

              env['PDB'] = 'hello.pdb'


       PDFCOM A deprecated synonym for $DVIPDFCOM.


       PDFPREFIX
              The prefix used for PDF file names.


       PDFSUFFIX
              The suffix used for PDF file names.


       PLATFORM
              The name of the platform used to create the Environment.  If  no
              platform  is  specified  when  the Environment is created, SSCCoonnss
              autodetects the platform.

              env = Environment(tools = [])
              if env['PLATFORM'] == 'cygwin':
                  Tool('mingw')(env)
              else:
                  Tool('msvc')(env)


       PRINT_CMD_LINE_FUNC
              A Python function used to print the command lines  as  they  are
              executed (assuming command printing is not disabled by the --qq or
              --ss options or their equivalents).  The function should take four
              arguments: _s, the command being executed (a string), _t_a_r_g_e_t, the
              target being built (file node, list, or string name(s)), _s_o_u_r_c_e,
              the  source(s)  used  (file  node, list, or string name(s)), and
              _e_n_v, the environment being used.

              The function must do the printing itself.  The default implemen-
              tation, used if this variable is not set or is None, is:
              def print_cmd_line(s, target, source, env):
                sys.stdout.write(s + "0)

       Here's an example of a more interesting function:
              def print_cmd_line(s, target, source, env):
                 sys.stdout.write("Building %s -> %s...0 %
                  (' and '.join([str(x) for x in source]),
                   ' and '.join([str(x) for x in target])))
              env=Environment(PRINT_CMD_LINE_FUNC=print_cmd_line)
              env.Program('foo', 'foo.c')

       This  just  prints "Building <targetname> from <sourcename>..." instead
       of the actual commands.  Such a function could also log the actual com-
       mands to a log file, for example.


       PROGPREFIX
              The prefix used for executable file names.


       PROGSUFFIX
              The suffix used for executable file names.


       PSCOM  The command line used to convert TeX DVI files into a PostScript
              file.


       PSCOMSTR
              The string displayed when a TeX DVI file  is  converted  into  a
              PostScript  file.   If this is not set, then $PSCOM (the command
              line) is displayed.


       PSPREFIX
              The prefix used for PostScript file names.


       PSSUFFIX
              The prefix used for PostScript file names.


       QTDIR  The qt tool tries to take this from os.environ.   It  also  ini-
              tializes  all  QT_*  construction variables listed below.  (Note
              that all paths  are  constructed  with  python's  os.path.join()
              method,  but  are  listed here with the '/' separator for easier
              reading.)  In addition, the construction  environment  variables
              CPPPATH, LIBPATH and LIBS may be modified and the variables PRO-
              GEMITTER, SHLIBEMITTER and LIBEMITTER are modified. Because  the
              build-performance  is affected when using this tool, you have to
              explicitly specify it at Environment creation:

              Environment(tools=['default','qt'])

              The qt tool supports the following operations:

              AAuuttoommaattiicc mmoocc ffiillee ggeenneerraattiioonn ffrroomm hheeaaddeerr  ffiilleess..   You  do  not
              have  to specify moc files explicitly, the tool does it for you.
              However, there are a few preconditions to  do  so:  Your  header
              file must have the same filebase as your implementation file and
              must stay in the same directory. It must have one  of  the  suf-
              fixes  .h,  .hpp,  .H, .hxx, .hh. You can turn off automatic moc
              file generation by setting QT_AUTOSCAN to 0.  See also the  cor-
              responding builder method MMoocc(())

              AAuuttoommaattiicc  mmoocc ffiillee ggeenneerraattiioonn ffrroomm ccxxxx ffiilleess..  As stated in the
              qt documentation, include the moc file at the  end  of  the  cxx
              file. Note that you have to include the file, which is generated
              by  the   transformation   ${QT_MOCCXXPREFIX}<basename>${QT_MOC-
              CXXSUFFIX},  by  default  <basename>.moc. A warning is generated
              after building the moc file, if you do not include  the  correct
              file.  If you are using BuildDir, you may need to specify dupli-
              cate=1. You can turn off automatic moc file generation  by  set-
              ting QT_AUTOSCAN to 0. See also the corresponding builder method
              MMoocc(())

              AAuuttoommaattiicc hhaannddlliinngg ooff ..uuii ffiilleess..  The implementation files  gen-
              erated  from  .ui files are handled much the same as yacc or lex
              files. Each .ui file given as a source of  Program,  Library  or
              SharedLibrary  will  generate three files, the declaration file,
              the implementation file and a moc file. Because there  are  also
              generated  headers, you may need to specify duplicate=1 in calls
              to BuildDir. See also the corresponding builder method UUiicc(())


       QT_AUTOSCAN
              Turn off scanning for mocable files.  Use  the  Moc  Builder  to
              explicitely specify files to run moc on.


       QT_BINPATH
              The path where the qt binaries are installed.  The default value
              is '$QTDIR/bin'.


       QT_CPPPATH
              The path where the qt header files are installed.   The  default
              value  is  '$QTDIR/include'.   Note: If you set this variable to
              None, the tool won't change the CPPPATH construction variable.


       QT_DEBUG
              Prints lots of debugging  information  while  scanning  for  moc
              files.


       QT_LIBPATH
              The  path  where  the  qt  libraries are installed.  The default
              value is '$QTDIR/lib'.  Note: If you set this variable to  None,
              the tool won't change the LIBPATH construction variable.


       QT_LIB Default  value  is  'qt'.  You  may want to set this to 'qt-mt'.
              Note: If you set this variable to None, the  tool  won't  change
              the LIBS variable.


       QT_MOC Default value is '$QT_BINPATH/moc'.


       QT_MOCCXXPREFIX
              Default value is ''. Prefix for moc output files, when source is
              a cxx file.


       QT_MOCCXXSUFFIX
              Default value is '.moc'.  Suffix  for  moc  output  files,  when
              source is a cxx file.


       QT_MOCFROMCPPFLAGS
              Default value is '-i'. These flags are passed to moc, when mocc-
              ing a cpp file.


       QT_MOCFROMCXXCOM
              Command to generate a moc file from a cpp file.


       QT_MOCFROMCXXCOMSTR
              The string displayed when generating a moc file from a cpp file.
              If this is not set, then $QT_MOCFROMCXXCOM (the command line) is
              displayed.


       QT_MOCFROMHCOM
              Command to generate a moc file from a header.


       QT_MOCFROMHCOMSTR
              The string displayed when generating a moc file from a cpp file.
              If  this  is not set, then $QT_MOCFROMHCOM (the command line) is
              displayed.


       QT_MOCFROMHFLAGS
              Default value is ''. These flags are passed to moc, when moccing
              a header file.


       QT_MOCHPREFIX
              Default  value  is  'moc_'.  Prefix  for  moc output files, when
              source is a header.


       QT_MOCHSUFFIX
              Default value is '$CXXFILESUFFIX'. Suffix for moc output  files,
              when source is a header.


       QT_UIC Default value is '$QT_BINPATH/uic'.


       QT_UICCOM
              Command to generate header files from .ui files.


       QT_UICCOMSTR
              The  string  displayed  when  generating  header  files from .ui
              files.  If this is not set, then $QT_UICCOM (the  command  line)
              is displayed.


       QT_UICDECLFLAGS
              Default  value is ''. These flags are passed to uic, when creat-
              ing a a h file from a .ui file.


       QT_UICDECLPREFIX
              Default value is ''. Prefix for uic generated header files.


       QT_UICDECLSUFFIX
              Default value is '.h'. Suffix for uic generated header files.


       QT_UICIMPLFLAGS
              Default value is ''. These flags are passed to uic, when  creat-
              ing a cxx file from a .ui file.


       QT_UICIMPLPREFIX
              Default value is 'uic_'. Prefix for uic generated implementation
              files.


       QT_UICIMPLSUFFIX
              Default value is  '$CXXFILESUFFIX'.  Suffix  for  uic  generated
              implementation files.


       QT_UISUFFIX
              Default value is '.ui'. Suffix of designer input files.


       RANLIB The archive indexer.


       RANLIBFLAGS
              General options passed to the archive indexer.


       RC     The resource compiler used by the RES builder.


       RCCOM  The command line used by the RES builder.


       RCCOMSTR
              The  string  displayed  when invoking the resource compiler.  If
              this is not set, then $RCCOM (the command line) is displayed.


       RCFLAGS
              The flags passed to the resource compiler by the RES builder.


       RCS    The RCS executable.  Note that this  variable  is  not  actually
              used  for  the  command  to fetch source files from RCS; see the
              RRCCSS__CCOO construction variable, below.


       RCS_CO The RCS "checkout" executable, used to fetch source  files  from
              RCS.


       RCS_COCOM
              The command line used to fetch (checkout) source files from RCS.


       RCS_COCOMSTR
              The string displayed when fetching a source file from  RCS.   If
              this  is  not  set,  then  $RCS_COCOM (the command line) is dis-
              played.


       RCS_COFLAGS
              Options that are passed to the $RCS_CO command.


       REGSVR The program used to register DLLs on Windows systems.


       REGSVRCOM
              The command line used to register a newly-built DLL file on Win-
              dows systems.  Invoked when the "register=1" keyword argument is
              passed to the SShhaarreeddLLiibbrraarryy Builder.


       REGSVRCOMSTR
              The string displayed when registering a  newly-built  DLL  file.
              If  this  is not set, then $REGSVRCOM (the command line) is dis-
              played.


       RDirs  A function that converts a string into a list of  Dir  instances
              by searching the repositories.


       RMIC   The Java RMI stub compiler.


       RMICCOM
              The  command  line used to compile stub and skeleton class files
              from Java classes that contain RMI implementations.  Any options
              specified  in  the $RMICFLAGS construction variable are included
              on this command line.


       RMICCOMSTR
              The string displayed when  compiling  stub  and  skeleton  class
              files  from  Java  classes that contain RMI implementations.  If
              this is not set, then $RMICCOM (the command line) is  displayed.

              env = Environment(RMICCOMSTR = "Generating stub/skeleton class files $TARGETS from $SOURCES")


       RMICFLAGS
              General options passed to the Java RMI stub compiler.


       RPCGEN The RPC protocol compiler.


       RPCGENCLIENTFLAGS
              Options  passed  to  the  RPC  protocol compiler when generating
              client side stubs.  These are in addition to any flags specified
              in the RRPPCCGGEENNFFLLAAGGSS construction variable.


       RPCGENFLAGS
              General options passed to the RPC protocol compiler.


       RPCGENHEADERFLAGS
              Options  passed  to  the RPC protocol compiler when generating a
              header file.  These are in addition to any  flags  specified  in
              the RRPPCCGGEENNFFLLAAGGSS construction variable.


       RPCGENSERVICEFLAGS
              Options  passed  to  the  RPC  protocol compiler when generating
              server side stubs.  These are in addition to any flags specified
              in the RRPPCCGGEENNFFLLAAGGSS construction variable.


       RPCGENXDRFLAGS
              Options  passed to the RPC protocol compiler when generating XDR
              routines.  These are in addition to any flags specified  in  the
              RRPPCCGGEENNFFLLAAGGSS construction variable.


       RPATH  A list of paths to search for shared libraries when running pro-
              grams.  Currently only used in the GNU (gnulink), IRIX (sgilink)
              and  Sun (sunlink) linkers.  Ignored on platforms and toolchains
              that don't support it.  Note that the paths added to  RPATH  are
              not  transformed  by  ssccoonnss in any way:  if you want an absolute
              path, you must make it absolute yourself.


       SCANNERS
              A list of the available implicit dependency scanners.  New  file
              scanners  may  be  added by appending to this list, although the
              more flexible approach is to associate scanners with a  specific
              Builder.   See  the  sections  "Builder  Objects"  and  "Scanner
              Objects," below, for more information.


       SCCS   The SCCS executable.


       SCCSCOM
              The command line used to fetch source files from SCCS.


       SCCSCOMSTR
              The string displayed when fetching a  source  file  from  a  CVS
              repository.   If  this  is  not  set, then $SCCSCOM (the command
              line) is displayed.


       SCCSFLAGS
              General options that are passed to SCCS.


       SCCSGETFLAGS
              Options that are passed specifically to the SCCS  "get"  subcom-
              mand.  This can be set, for example, to _-_e to check out editable
              files from SCCS.


       SHCC   The C compiler used for generating shared-library objects.


       SHCCCOM
              The command line used to compile a C source file  to  a  shared-
              library  object  file.   Any options specified in the $SHCCFLAGS
              and $CPPFLAGS construction variables are included on  this  com-
              mand line.


       SHCCCOMSTR
              The  string  displayed  when  a  C  source file is compiled to a
              shared object file.  If this is  not  set,  then  $SHCCCOM  (the
              command line) is displayed.

              env = Environment(SHCCCOMSTR = "Compiling shared object $TARGET")


       SHCCFLAGS
              Options  that  are  passed to the C compiler to generate shared-
              library objects.


       SHCXX  The C++ compiler used for generating shared-library objects.


       SHCXXCOM
              The command line used to compile a C++ source file to a  shared-
              library  object  file.  Any options specified in the $SHCXXFLAGS
              and $CPPFLAGS construction variables are included on  this  com-
              mand line.


       SHCXXCOMSTR
              The  string  displayed  when  a C++ source file is compiled to a
              shared object file.  If this is not  set,  then  $SHCXXCOM  (the
              command line) is displayed.

              env = Environment(SHCXXCOMSTR = "Compiling shared object $TARGET")


       SHCXXFLAGS
              Options  that are passed to the C++ compiler to generate shared-
              library objects.


       SHELL  A string naming the shell program that will  be  passed  to  the
              _S_P_A_W_N  function.   See  the _S_P_A_W_N construction variable for more
              information.


       SHF77  The Fortran  77  compiler  used  for  generating  shared-library
              objects.   You  should  normally  set  the $SHFORTRANC variable,
              which specifies the default Fortran  compiler  for  all  Fortran
              versions.  You only need to set $SHF77 if you need to use a spe-
              cific compiler or compiler version for Fortran 77 files.


       SHF77COM
              The command line used to compile a Fortran 77 source file  to  a
              shared-library  object  file.  You only need to set $SHF77COM if
              you need to use a specific command line for  Fortran  77  files.
              You should normally set the $SHFORTRANCOM variable, which speci-
              fies the default command line for all Fortran versions.


       SHF77COMSTR
              The string displayed when a Fortran 77 source file  is  compiled
              to  a  shared-library  object  file.   If  this is not set, then
              $SHF77COM or $SHFORTRANCOM (the command line) is displayed.


       SHF77FLAGS
              Options that are passed to the Fortran 77 compiler to  generated
              shared-library objects.  You only need to set $SHF77FLAGS if you
              need to define specific user options for Fortran 77 files.   You
              should  normally  set the $SHFORTRANFLAGS variable, which speci-
              fies the user-specified options passed to  the  default  Fortran
              compiler for all Fortran versions.


       SHF77PPCOM
              The  command  line used to compile a Fortran 77 source file to a
              shared-library object file after first running the file  through
              the  C  preprocessor.   Any options specified in the $SHF77FLAGS
              and $CPPFLAGS construction variables are included on  this  com-
              mand  line.  You only need to set $SHF77PPCOM if you need to use
              a specific C-preprocessor command line  for  Fortran  77  files.
              You  should  normally  set  the  $SHFORTRANPPCOM variable, which
              specifies the default C-preprocessor command line for  all  For-
              tran versions.


       SHF90  The  Fortran  90  compiler  used  for  generating shared-library
              objects.  You should  normally  set  the  $SHFORTRANC  variable,
              which  specifies  the  default  Fortran compiler for all Fortran
              versions.  You only need to set $SHF90 if you need to use a spe-
              cific compiler or compiler version for Fortran 90 files.


       SHF90COM
              The  command  line used to compile a Fortran 90 source file to a
              shared-library object file.  You only need to set  $SHF90COM  if
              you  need  to  use a specific command line for Fortran 90 files.
              You should normally set the $SHFORTRANCOM variable, which speci-
              fies the default command line for all Fortran versions.


       SHF90COMSTR
              The  string  displayed when a Fortran 90 source file is compiled
              to a shared-library object file.   If  this  is  not  set,  then
              $SHF90COM or $SHFORTRANCOM (the command line) is displayed.


       SHF90FLAGS
              Options  that are passed to the Fortran 90 compiler to generated
              shared-library objects.  You only need to set $SHF90FLAGS if you
              need  to define specific user options for Fortran 90 files.  You
              should normally set the $SHFORTRANFLAGS variable,  which  speci-
              fies  the  user-specified  options passed to the default Fortran
              compiler for all Fortran versions.


       SHF90PPCOM
              The command line used to compile a Fortran 90 source file  to  a
              shared-library  object file after first running the file through
              the C preprocessor.  Any options specified  in  the  $SHF90FLAGS
              and  $CPPFLAGS  construction variables are included on this com-
              mand line.  You only need to set $SHF90PPCOM if you need to  use
              a  specific  C-preprocessor  command  line for Fortran 90 files.
              You should normally  set  the  $SHFORTRANPPCOM  variable,  which
              specifies  the  default C-preprocessor command line for all For-
              tran versions.


       SHF95  The Fortran  95  compiler  used  for  generating  shared-library
              objects.   You  should  normally  set  the $SHFORTRANC variable,
              which specifies the default Fortran  compiler  for  all  Fortran
              versions.  You only need to set $SHF95 if you need to use a spe-
              cific compiler or compiler version for Fortran 95 files.


       SHF95COM
              The command line used to compile a Fortran 95 source file  to  a
              shared-library  object  file.  You only need to set $SHF95COM if
              you need to use a specific command line for  Fortran  95  files.
              You should normally set the $SHFORTRANCOM variable, which speci-
              fies the default command line for all Fortran versions.


       SHF95COMSTR
              The string displayed when a Fortran 95 source file  is  compiled
              to  a  shared-library  object  file.   If  this is not set, then
              $SHF95COM or $SHFORTRANCOM (the command line) is displayed.


       SHF95FLAGS
              Options that are passed to the Fortran 95 compiler to  generated
              shared-library objects.  You only need to set $SHF95FLAGS if you
              need to define specific user options for Fortran 95 files.   You
              should  normally  set the $SHFORTRANFLAGS variable, which speci-
              fies the user-specified options passed to  the  default  Fortran
              compiler for all Fortran versions.


       SHF95PPCOM
              The  command  line used to compile a Fortran 95 source file to a
              shared-library object file after first running the file  through
              the  C  preprocessor.   Any options specified in the $SHF95FLAGS
              and $CPPFLAGS construction variables are included on  this  com-
              mand  line.  You only need to set $SHF95PPCOM if you need to use
              a specific C-preprocessor command line  for  Fortran  95  files.
              You  should  normally  set  the  $SHFORTRANPPCOM variable, which
              specifies the default C-preprocessor command line for  all  For-
              tran versions.


       SHFORTRAN
              The  default Fortran compiler used for generating shared-library
              objects.


       SHFORTRANCOM
              The command line used to compile a  Fortran  source  file  to  a
              shared-library object file.


       FORTRANCOMSTR
              The string displayed when a Fortran source file is compiled to a
              shared-library object file.  If this is not  set,  then  $SHFOR-
              TRANCOM (the command line) is displayed.


       SHFORTRANFLAGS
              Options  that  are  passed  to  the Fortran compiler to generate
              shared-library objects.


       SHFORTRANPPCOM
              The command line used to compile a  Fortran  source  file  to  a
              shared-library  object file after first running the file through
              the C preprocessor.  Any options specified  in  the  $SHFORTRAN-
              FLAGS  and $CPPFLAGS construction variables are included on this
              command line.


       SHLIBPREFIX
              The prefix used for shared library file names.


       SHLIBSUFFIX
              The suffix used for shared library file names.


       SHLINK The linker for programs that use shared libraries.


       SHLINKCOM
              The command line used to link programs using shared libaries.


       SHLINKCOMSTR
              The string displayed when programs using  shared  libraries  are
              linked.   If this is not set, then $SHLINKCOM (the command line)
              is displayed.

              env = Environment(SHLINKCOMSTR = "Linking shared $TARGET")


       SHLINKFLAGS
              General user options passed to the  linker  for  programs  using
              shared libraries.  Note that this variable should _n_o_t contain --ll
              (or similar) options for linking with the  libraries  listed  in
              $LIBS,  nor  --LL  (or  similar)  include search path options that
              scons generates automatically  from  $LIBPATH.   See  __LLIIBBFFLLAAGGSS,
              above,  for  the  variable that expands to library-link options,
              and __LLIIBBDDIIRRFFLLAAGGSS,  above,  for  the  variable  that  expands  to
              library search path options.


       SHOBJPREFIX
              The prefix used for shared object file names.


       SHOBJSUFFIX
              The suffix used for shared object file names.


       SOURCE A  reserved  variable name that may not be set or used in a con-
              struction environment.  (See "Variable Substitution," below.)


       SOURCES
              A reserved variable name that may not be set or used in  a  con-
              struction environment.  (See "Variable Substitution," below.)


       SPAWN  A  command  interpreter  function that will be called to execute
              command line strings. The function  must  expect  the  following
              arguments:

              def spawn(shell, escape, cmd, args, env):

              _s_h  is  a  string  naming the shell program to use.  _e_s_c_a_p_e is a
              function that can be called to escape shell  special  characters
              in  the command line.  _c_m_d is the path to the command to be exe-
              cuted.  _a_r_g_s is the arguments to the command.  _e_n_v is a  dictio-
              nary of the environment variables in which the command should be
              executed.


       SWIG   The scripting language wrapper and interface generator.


       SWIGCFILESUFFIX
              The suffix that will be used for  intermediate  C  source  files
              generated by the scripting language wrapper and interface gener-
              ator.  The default value is __wwrraapp$$CCFFIILLEESSUUFFFFIIXX.  By default, this
              value  is used whenever the --cc++++ option is _n_o_t specified as part
              of the SSWWIIGGFFLLAAGGSS construction variable.


       SWIGCOM
              The command line used to call the scripting language wrapper and
              interface generator.


       SWIGCOMSTR
              The string displayed when calling the scripting language wrapper
              and interface generator.  If this is not set, then $SWIGCOM (the
              command line) is displayed.


       SWIGCXXFILESUFFIX
              The  suffix  that will be used for intermediate C++ source files
              generated by the scripting language wrapper and interface gener-
              ator.  The default value is __wwrraapp$$CCFFIILLEESSUUFFFFIIXX.  By default, this
              value is used whenever the --cc++++ option is specified as  part  of
              the SSWWIIGGFFLLAAGGSS construction variable.


       SWIGFLAGS
              General  options  passed  to  the scripting language wrapper and
              interface generator.  This is  where  you  should  set  --ppyytthhoonn,
              --ppeerrll55,  --ttccll,  or whatever other options you want to specify to
              SWIG.  If you set the --cc++++ option in this variable, ssccoonnss  will,
              by  default,  generate  a  C++ intermediate source file with the
              extension that is specified as the $$CCXXXXFFIILLEESSUUFFFFIIXX variable.


       TAR    The tar archiver.


       TARCOM The command line used to call the tar archiver.


       TARCOMSTR
              The  string  displayed  when  archiving  files  using  the   tar
              archiver.   If  this is not set, then $TARCOM (the command line)
              is displayed.

              env = Environment(TARCOMSTR = "Archiving $TARGET")


       TARFLAGS
              General options passed to the tar archiver.


       TARGET A reserved variable name that may not be set or used in  a  con-
              struction environment.  (See "Variable Substitution," below.)


       TARGETS
              A  reserved  variable name that may not be set or used in a con-
              struction environment.  (See "Variable Substitution," below.)


       TARSUFFIX
              The suffix used for tar file names.


       TEMPFILEPREFIX
              The prefix for a temporary file used  to  execute  lines  longer
              than  $MAXLINELENGTH.   The default is '@'.  This may be set for
              toolchains that use other values, such as '-@' for the diab com-
              piler or '-via' for ARM toolchain.


       TEX    The TeX formatter and typesetter.


       TEXCOM The  command line used to call the TeX formatter and typesetter.


       TEXCOMSTR
              The string displayed when calling the TeX formatter and typeset-
              ter.   If  this  is  not set, then $TEXCOM (the command line) is
              displayed.

              env = Environment(TEXCOMSTR = "Building $TARGET from TeX input $SOURCES")


       TEXFLAGS
              General options passed to the TeX formatter and typesetter.


       TOOLS  A list of the names of the Tool specifications that are part  of
              this construction environment.


       WIN32_INSERT_DEF
              When  this  is  set  to  true, a library build of a WIN32 shared
              library (.dll file) will also build a corresponding .def file at
              the  same  time, if a .def file is not already listed as a build
              target.  The default is 0 (do not build a .def file).


       WIN32DEFPREFIX
              The prefix used for WIN32 .def file names.


       WIN32DEFSUFFIX
              The suffix used for WIN32 .def file names.


       YACC   The parser generator.


       YACCCOM
              The command line used to call the parser generator to generate a
              source file.


       YACCCOMSTR
              The  string  displayed  when  generating a source file using the
              parser generator.  If this is not set, then $YACCCOM  (the  com-
              mand line) is displayed.

              env = Environment(YACCCOMSTR = "Yacc'ing $TARGET from $SOURCES")


       YACCFLAGS
              General  options  passed to the parser generator.  If $YACCFLAGS
              contains a -d option, SCons assumes that the call will also cre-
              ate a .h file (if the yacc source file ends in a .y suffix) or a
              .hpp file (if the yacc source file ends in a .yy suffix)


       YACCHFILESUFFIX
              The suffix of the C header file generated by the parser  genera-
              tor when the --dd option is used.  Note that setting this variable
              does not cause the parser generator to generate  a  header  file
              with  the  specified  suffix,  it exists to allow you to specify
              what suffix the parser generator will use  of  its  own  accord.
              The default value is ..hh.


       YACCHXXFILESUFFIX
              The suffix of the C++ header file generated by the parser gener-
              ator when the --dd option is used.  Note that setting  this  vari-
              able  does  not  cause the parser generator to generate a header
              file with the specified suffix, it exists to allow you to  spec-
              ify what suffix the parser generator will use of its own accord.
              The default value is ..hhpppp.


       ZIP    The zip compression and file packaging utility.


       ZIPCOM The command line used to call the zip utility, or  the  internal
              Python function used to create a zip archive.


       ZIPCOMSTR
              The string displayed when archiving files using the zip utility.
              If this is not set, then $ZIPCOM (the command line  or  internal
              Python function) is displayed.

              env = Environment(ZIPCOMSTR = "Zipping $TARGET")


       ZIPCOMPRESSION
              The  _c_o_m_p_r_e_s_s_i_o_n flag from the Python zziippffiillee module used by the
              internal Python function to control whether the zip  archive  is
              compressed  or  not.  The default value is zziippffiillee..ZZIIPP__DDEEFFLLAATTEEDD,
              which creates a compressed  zip  archive.   This  value  has  no
              effect  when using Python 1.5.2 or if the zziippffiillee module is oth-
              erwise unavailable.


       ZIPFLAGS
              General options passed to the zip utility.


       Construction variables can be retrieved and set  using  the  DDiiccttiioonnaarryy
       method of the construction environment:

              dict = env.Dictionary()
              dict["CC"] = "cc"

       or using the [] operator:

              env["CC"] = "cc"

       Construction  variables can also be passed to the construction environ-
       ment constructor:

              env = Environment(CC="cc")

       or when copying a construction environment using the CCooppyy method:

              env2 = env.Copy(CC="cl.exe")


   CCoonnffiigguurree CCoonntteexxttss
       ssccoonnss supports _c_o_n_f_i_g_u_r_e _c_o_n_t_e_x_t_s_, an integrated mechanism  similar  to
       the  various  AC_CHECK macros in GNU autoconf for testing for the exis-
       tence of C header files, libraries,  etc.   In  contrast  to  autoconf,
       ssccoonnss  does  not  maintain  an explicit cache of the tested values, but
       uses its normal dependency tracking to keep the checked  values  up  to
       date. However, users may override this behaviour with the ----ccoonnffiigg com-
       mand line option.

       The following methods can be used to perform checks:


       Configure(_e_n_v, [_c_u_s_t_o_m___t_e_s_t_s, _c_o_n_f___d_i_r, _l_o_g___f_i_l_e, _c_o_n_f_i_g___h])

       env.Configure([_c_u_s_t_o_m___t_e_s_t_s, _c_o_n_f___d_i_r, _l_o_g___f_i_l_e, _c_o_n_f_i_g___h])
              This creates a configure context, which can be used  to  perform
              checks.   _e_n_v  specifies the environment for building the tests.
              This environment may be modified when performing  checks.   _c_u_s_-
              _t_o_m___t_e_s_t_s is a dictionary containing custom tests.  See also the
              section about custom tests below.  By default, no  custom  tests
              are added to the configure context.  _c_o_n_f___d_i_r specifies a direc-
              tory where the test cases are built.  Note that  this  directory
              is  not  used for building normal targets.  The default value is
              the directory #/.sconf_temp.  _l_o_g___f_i_l_e specifies  a  file  which
              collects the output from commands that are executed to check for
              the existence of header files, libraries, etc.  The  default  is
              the  file  #/config.log.   If you are using the BBuuiillddDDiirr method,
              you may want to specify a subdirectory under your  build  direc-
              tory.   _c_o_n_f_i_g___h  specifies a C header file where the results of
              tests  will  be  written,  e.g.  #define  HAVE_STDIO_H,  #define
              HAVE_LIBM,  etc.   The  default is to not write a ccoonnffiigg..hh file.
              You can specify the same ccoonnffiigg..hh file in multiple calls to Con-
              figure,  in which case ssccoonnss will concatenate all results in the
              specified file.  Note that  SCons  uses  its  normal  dependency
              checking  to  decide  if it's necessary to rebuild the specified
              _c_o_n_f_i_g___h file.  This means that the file is not necessarily  re-
              built  each  time  scons is run, but is only rebuilt if its con-
              tents will have changed and some target that depends on the _c_o_n_-
              _f_i_g___h file is being built.

       A created CCoonnffiigguurree instance has the following associated methods:


       Configure.Finish(_s_e_l_f)
              This  method  should  be called after configuration is done.  It
              returns the environment as modified by the configuration  checks
              performed.   After  this method is called, no further checks can
              be performed with this configuration context.  However, you  can
              create  a  new  Configure  context to perform additional checks.
              Only one context should be active at a time.

              The following Checks are predefined.   (This  list  will  likely
              grow larger as time goes by and developers contribute new useful
              tests.)


       Configure.CheckHeader(_s_e_l_f, _h_e_a_d_e_r, [_i_n_c_l_u_d_e___q_u_o_t_e_s, _l_a_n_g_u_a_g_e])
              Checks if _h_e_a_d_e_r is usable in the  specified  language.   _h_e_a_d_e_r
              may  be  a  list, in which case the last item in the list is the
              header file to be checked,  and  the  previous  list  items  are
              header files whose ##iinncclluuddee lines should precede the header line
              being checked for.  The optional argument _i_n_c_l_u_d_e___q_u_o_t_e_s must be
              a  two  character  string, where the first character denotes the
              opening quote and  the  second  character  denotes  the  closing
              quote.   By default, both characters  are " (double quote).  The
              optional argument _l_a_n_g_u_a_g_e should be either CC or CC++++ and selects
              the compiler to be used for the check.  Returns 1 on success and
              0 on failure.


       Configure.CheckCHeader(_s_e_l_f, _h_e_a_d_e_r, [_i_n_c_l_u_d_e___q_u_o_t_e_s])
              This is a wrapper around CCoonnffiigguurree..CChheecckkHHeeaaddeerr which  checks  if
              _h_e_a_d_e_r  is  usable  in the C language.  _h_e_a_d_e_r may be a list, in
              which case the last item in the list is the header  file  to  be
              checked,  and  the  previous  list  items are header files whose
              ##iinncclluuddee lines should precede the header line being checked for.
              The  optional  argument  _i_n_c_l_u_d_e___q_u_o_t_e_s  must be a two character
              string, where the first character denotes the opening quote  and
              the  second character denotes the closing quote (both default to
              ").  Returns 1 on success and 0 on failure.


       Configure.CheckCXXHeader(_s_e_l_f, _h_e_a_d_e_r, [_i_n_c_l_u_d_e___q_u_o_t_e_s])
              This is a wrapper around CCoonnffiigguurree..CChheecckkHHeeaaddeerr which  checks  if
              _h_e_a_d_e_r  is usable in the C++ language.  _h_e_a_d_e_r may be a list, in
              which case the last item in the list is the header  file  to  be
              checked,  and  the  previous  list  items are header files whose
              ##iinncclluuddee lines should precede the header line being checked for.
              The  optional  argument  _i_n_c_l_u_d_e___q_u_o_t_e_s  must be a two character
              string, where the first character denotes the opening quote  and
              the  second character denotes the closing quote (both default to
              ").  Returns 1 on success and 0 on failure.


       Configure.CheckFunc(_s_e_l_f, _f_u_n_c_t_i_o_n___n_a_m_e, [_h_e_a_d_e_r, _l_a_n_g_u_a_g_e])
              Checks if the specified C or C++ function is  available.   _f_u_n_c_-
              _t_i_o_n___n_a_m_e  is  the  name  of  the  function  to  check for.  The
              optional _h_e_a_d_e_r argument is a string that will be placed at  the
              top of the test file that will be compiled to check if the func-
              tion exists; the default is:
              #ifdef __cplusplus
              extern "C"
              #endif
              char function_name();
       The optional _l_a_n_g_u_a_g_e argument should be CC or CC++++ and selects the  com-
       piler to be used for the check; the default is "C".


       Configure.CheckLib(_s_e_l_f,    [_l_i_b_r_a_r_y,    _s_y_m_b_o_l,    _h_e_a_d_e_r,   _l_a_n_g_u_a_g_e,
       _a_u_t_o_a_d_d_=_1])
              Checks if _l_i_b_r_a_r_y provides _s_y_m_b_o_l.  If the value of _a_u_t_o_a_d_d is 1
              and the library  provides  the  specified  _s_y_m_b_o_l,  appends  the
              library  to the LIBS construction environment variable.  _l_i_b_r_a_r_y
              may also be None (the default), in which case _s_y_m_b_o_l is  checked
              with  the  current LIBS variable, or a list of library names, in
              which case each library in the list will be checked for  _s_y_m_b_o_l.
              The  default  _s_y_m_b_o_l is "main", which just check if you can link
              against the specified _l_i_b_r_a_r_y.  The optional  _l_a_n_g_u_a_g_e  argument
              should  be  CC or CC++++ and selects the compiler to be used for the
              check; the default is "C".  The default value for _a_u_t_o_a_d_d is  1.
              It is assumed, that the C-language is used.  This method returns
              1 on success and 0 on error.


       Configure.CheckLibWithHeader(_s_e_l_f, _l_i_b_r_a_r_y,  _h_e_a_d_e_r,  _l_a_n_g_u_a_g_e,  [_c_a_l_l,
       _a_u_t_o_a_d_d])

              In contrast to the Configure.CheckLib call, this call provides a
              more  sophisticated  way  to  check  against  libraries.  Again,
              _l_i_b_r_a_r_y specifies the library or a list of libraries  to  check.
              _h_e_a_d_e_r  specifies  a header to check for.  _h_e_a_d_e_r may be a list,
              in which case the last item in the list is the header file to be
              checked,  and  the  previous  list  items are header files whose
              ##iinncclluuddee lines should precede the header line being checked for.
              _l_a_n_g_u_a_g_e  may  be  one  of  'C','c','CXX','cxx','C++' and 'c++'.
              _c_a_l_l can be any valid expression  (with  a  trailing  ';').  The
              default  is  'main();'.   _a_u_t_o_a_d_d  specifies  whether to add the
              library to the environment (only if the  check  succeeds).  This
              method returns 1 on success and 0 on error.


       Configure.CheckType(_s_e_l_f, _t_y_p_e___n_a_m_e, [_i_n_c_l_u_d_e_s, _l_a_n_g_u_a_g_e])
              Checks   for  the  existence  of  a  type  defined  by  ttyyppeeddeeff.
              _t_y_p_e___n_a_m_e specifies the typedef name to check for.  _i_n_c_l_u_d_e_s  is
              a  string  containing  one  or  more ##iinncclluuddee lines that will be
              inserted into the program that will be run to test for the exis-
              tence  of  the type.  The optional _l_a_n_g_u_a_g_e argument should be CC
              or CC++++ and selects the compiler to be used for  the  check;  the
              default is "C".

       Example of a typical Configure usage:

              env = Environment()
              conf = Configure( env )
              if not conf.CheckCHeader( 'math.h' ):
                  print 'We really need math.h!'
                  Exit(1)
              if conf.CheckLibWithHeader( 'qt', 'qapp.h', 'c++', 'QApplication qapp(0,0);' ):
                  # do stuff for qt - usage, e.g.
                  conf.env.Append( CPPFLAGS = '-DWITH_QT' )
              env = conf.Finish()

       You  can  define your own custom checks.  in addition to the predefined
       checks.  These are passed in a dictionary to  the  Configure  function.
       This  dictionary  maps  the  names of the checks to user defined Python
       callables (either Python functions or class instances implementing  the
       _____c_a_l_l____ method).  The first argument of the call is always a _C_h_e_c_k_C_o_n_-
       _t_e_x_t instance followed by the arguments, which must be supplied by  the
       user  of  the check.  These CheckContext instances define the following
       methods:


       CheckContext.Message(_s_e_l_f, _t_e_x_t)

              Usually called before the check is started.  _t_e_x_t will  be  dis-
              played to the user, e.g. 'Checking for library X...'


       CheckContext.Result(_s_e_l_f_,, _r_e_s)

              Usually  called  after  the check is done.  _r_e_s can be either an
              integer or a string. In the former case,  'ok'  (res  !=  0)  or
              'failed' (res == 0) is displayed to the user, in the latter case
              the given string is displayed.


       CheckContext.TryCompile(_s_e_l_f, _t_e_x_t, _e_x_t_e_n_s_i_o_n)
              Checks if a file with the specified _e_x_t_e_n_s_i_o_n (e.g.  '.c')  con-
              taining  _t_e_x_t  can  be  compiled  using the environment's OObbjjeecctt
              builder. Returns 1 on success and 0 on failure.


       CheckContext.TryLink(_s_e_l_f, _t_e_x_t, _e_x_t_e_n_s_i_o_n)
              Checks, if a file with the specified _e_x_t_e_n_s_i_o_n (e.g. '.c')  con-
              taining  _t_e_x_t  can  be  compiled using the environment's PPrrooggrraamm
              builder. Returns 1 on success and 0 on failure.


       CheckContext.TryRun(_s_e_l_f, _t_e_x_t, _e_x_t_e_n_s_i_o_n)
              Checks, if a file with the specified _e_x_t_e_n_s_i_o_n (e.g. '.c')  con-
              taining  _t_e_x_t  can  be  compiled using the environment's PPrrooggrraamm
              builder. On success, the program is run. If the program executes
              successfully (that is, its return status is 0), a tuple _(_1_, _o_u_t_-
              _p_u_t_S_t_r_) is returned, where _o_u_t_p_u_t_S_t_r is the standard  output  of
              the  program.  If the program fails execution (its return status
              is non-zero), then (0, '') is returned.


       CheckContext.TryAction(_s_e_l_f, _a_c_t_i_o_n, [_t_e_x_t, _e_x_t_e_n_s_i_o_n])
              Checks if the specified _a_c_t_i_o_n  with  an  optional  source  file
              (contents  _t_e_x_t  ,  extension  _e_x_t_e_n_s_i_o_n = '' ) can be executed.
              _a_c_t_i_o_n may be anything which can be converted to a ssccoonnss Action.
              On  success,  _(_1_, _o_u_t_p_u_t_S_t_r_) is returned, where _o_u_t_p_u_t_S_t_r is the
              content of the target file.  On failure _(_0_, _'_'_) is returned.


       CheckContext.TryBuild(_s_e_l_f, _b_u_i_l_d_e_r, [_t_e_x_t, _e_x_t_e_n_s_i_o_n])
              Low level implementation for testing specific builds; the  meth-
              ods  above are based on this method.  Given the Builder instance
              _b_u_i_l_d_e_r and the optional _t_e_x_t of a  source  file  with  optional
              _e_x_t_e_n_s_i_o_n, this method returns 1 on success and 0 on failure. In
              addition, _s_e_l_f_._l_a_s_t_T_a_r_g_e_t is set to the build  target  node,  if
              the build was successful.

       Example for implementing and using custom tests:

              def CheckQt(context, qtdir):
                  context.Message( 'Checking for qt ...' )
                  lastLIBS = context.env['LIBS']
                  lastLIBPATH = context.env['LIBPATH']
                  lastCPPPATH= context.env['CPPPATH']
                  context.env.Append(LIBS = 'qt', LIBPATH = qtdir + '/lib', CPPPATH = qtdir + '/include' )
                  ret = context.TryLink("""
              #include <qapp.h>
              int main(int argc, char **argv) {
                QApplication qapp(argc, argv);
                return 0;
              }
              """)
                  if not ret:
                      context.env.Replace(LIBS = lastLIBS, LIBPATH=lastLIBPATH, CPPPATH=lastCPPPATH)
                  context.Result( ret )
                  return ret

              env = Environment()
              conf = Configure( env, custom_tests = { 'CheckQt' : CheckQt } )
              if not conf.CheckQt('/usr/lib/qt'):
                  print 'We really need qt!'
                  Exit(1)
              env = conf.Finish()


   CCoonnssttrruuccttiioonn VVaarriiaabbllee OOppttiioonnss
       Often  when  building software, various options need to be specified at
       build time that are not known when the SConstruct/SConscript files  are
       written.  For  example,  libraries  needed for the build may be in non-
       standard locations, or site-specific compiler options may  need  to  be
       passed  to  the  compiler.   ssccoonnss provides a mechanism for overridding
       construction variables from the command line or a text-based SConscript
       file  through  an Options object. To create an Options object, call the
       Options() function:


       Options([_f_i_l_e_s], [_a_r_g_s])
              This creates an Options object that will read construction vari-
              ables from the file or list of filenames specified in _f_i_l_e_s.  If
              no files are specified, or the _f_i_l_e_s argument is NNoonnee,  then  no
              files  will be read.  The optional argument _a_r_g_s is a dictionary
              of values that will override anything read  from  the  specified
              files;  it is primarily intended to be passed the AARRGGUUMMEENNTTSS dic-
              tionary that holds variables  specified  on  the  command  line.
              Example:

              opts = Options('custom.py')
              opts = Options('overrides.py', ARGUMENTS)
              opts = Options(None, {FOO:'expansion', BAR:7})

       Options objects have the following methods:


       Add(_k_e_y, [_h_e_l_p, _d_e_f_a_u_l_t, _v_a_l_i_d_a_t_o_r, _c_o_n_v_e_r_t_e_r])
              This  adds  a  customizable construction variable to the Options
              object.  _k_e_y is the name of the variable.  _h_e_l_p is the help text
              for the variable.  _d_e_f_a_u_l_t is the default value of the variable;
              if the default value is NNoonnee and  there  is  no  explicit  value
              specified,  the  construction  variable will _n_o_t be added to the
              construction environment.  _v_a_l_i_d_a_t_o_r is called to  validate  the
              value  of  the  variable,  and should take three arguments: key,
              value, and environment _c_o_n_v_e_r_t_e_r is called to convert the  value
              before  putting  it in the environment, and should take a single
              argument: value. Example:

              opts.Add('CC', 'The C compiler')


       AddOptions(_l_i_s_t)
              A wrapper script that adds  multiple  customizable  construction
              variables to an Options object.  _l_i_s_t is a list of tuple or list
              objects that contain the arguments for an individual call to the
              AAdddd method.

              opt.AddOptions(
                     ('debug', '', 0),
                     ('CC', 'The C compiler'),
                     ('VALIDATE', 'An option for testing validation',
                      'notset', validator, None),
                  )


       Update(_e_n_v, [_a_r_g_s])
              This  updates a construction environment _e_n_v with the customized
              construction variables.  Normally  this  method  is  not  called
              directly, but is called indirectly by passing the Options object
              to the Environment() function:

              env = Environment(options=opts)


              The text file(s) that were specified when the Options object was
              created  are  executed  as  Python  scripts,  and  the values of
              (global) Python variables set in the file are added to the  con-
              struction environment.  Example:

              CC = 'my_cc'


       Save(_f_i_l_e_n_a_m_e, _e_n_v)
              This  saves  the  currently set options into a script file named
              _f_i_l_e_n_a_m_e that can be used on the next  invocation  to  automati-
              cally  load the current settings.  This method combined with the
              Options method can be used to support caching of options between
              runs.

              env = Environment()
              opts = Options(['options.cache', 'custom.py'])
              opts.Add(...)
              opts.Update(env)
              opts.Save('options.cache', env)


       GenerateHelpText(_e_n_v, [_s_o_r_t])
              This  generates help text documenting the customizable construc-
              tion variables suitable to passing in to  the  Help()  function.
              _e_n_v is the construction environment that will be used to get the
              actual  values  of  customizable  variables.  Calling  with   an
              optional _s_o_r_t function will cause the output to be sorted by the
              specified argument.  The specific _s_o_r_t function should take  two
              arguments  and  return  -1, 0 or 1 (like the standard Python _c_m_p
              function).

              Help(opts.GenerateHelpText(env))
              Help(opts.GenerateHelpText(env, sort=cmp))


       FormatOptionHelpText(_e_n_v, _o_p_t, _h_e_l_p, _d_e_f_a_u_l_t, _a_c_t_u_a_l)
              This method returns a formatted string containing the  printable
              help  text  for one option.  It is normally not called directly,
              but is called by the _G_e_n_e_r_a_t_e_H_e_l_p_T_e_x_t()  method  to  create  the
              returned help text.  It may be overridden with your own function
              that takes the arguments specified above and returns a string of
              help text formatted to your liking.  Note that the _G_e_n_e_r_a_t_e_H_e_l_p_-
              _T_e_x_t() will not put any  blank  lines  or  extra  characters  in
              between  the  entries,  so  you must add those characters to the
              returned string if you want the entries separated.

              def my_format(env, opt, help, default, actual):
                  fmt = "79s: default=%s actual=%s (%s)0
                  return fmt % (opt, default. actual, help)
              opts.FormatOptionHelpText = my_format

       To make it more convenient to work  with  customizable  Options,  ssccoonnss
       provides  a  number  of  functions  that make it easy to set up various
       types of Options:


       BoolOption(_k_e_y, _h_e_l_p, _d_e_f_a_u_l_t)
              Return a tuple of arguments to set up  a  Boolean  option.   The
              option  will use the specified name _k_e_y, have a default value of
              _d_e_f_a_u_l_t, and display the specified _h_e_l_p text.  The  option  will
              interpret the values yy, yyeess, tt, ttrruuee, 11, oonn and aallll as true, and
              the values nn, nnoo, ff, ffaallssee, 00, ooffff and nnoonnee as false.


       EnumOption(_k_e_y, _h_e_l_p, _d_e_f_a_u_l_t, _a_l_l_o_w_e_d___v_a_l_u_e_s, [_m_a_p, _i_g_n_o_r_e_c_a_s_e])
              Return a tuple of arguments to set up an option whose value  may
              be  one  of  a  specified  list of legal enumerated values.  The
              option will use the specified name _k_e_y, have a default value  of
              _d_e_f_a_u_l_t,  and  display the specified _h_e_l_p text.  The option will
              only support those  values  in  the  _a_l_l_o_w_e_d___v_a_l_u_e_s  list.   The
              optional  _m_a_p  argument is a dictionary that can be used to con-
              vert input values into specific legal values in the _a_l_l_o_w_e_d___v_a_l_-
              _u_e_s  list.  If the value of _i_g_n_o_r_e___c_a_s_e is 00 (the default), then
              the values are case-sensitive.  If the value of  _i_g_n_o_r_e___c_a_s_e  is
              11,  then  values will be matched case-insensitive.  If the value
              of _i_g_n_o_r_e___c_a_s_e is 11, then values will be  matched  case-insensi-
              tive, and all input values will be converted to lower case.


       ListOption(_k_e_y, _h_e_l_p, _d_e_f_a_u_l_t, _n_a_m_e_s, [_,map_]_)
              Return  a tuple of arguments to set up an option whose value may
              be one or more of a specified list of legal  enumerated  values.
              The option will use the specified name _k_e_y, have a default value
              of _d_e_f_a_u_l_t, and display the specified  _h_e_l_p  text.   The  option
              will  only  support  the  values aallll, nnoonnee, or the values in the
              _n_a_m_e_s list.  More than one value may be specified, with all val-
              ues  separated by commas.  The default may be a string of comma-
              separated default values, or a list of the default values.   The
              optional  _m_a_p  argument is a dictionary that can be used to con-
              vert input values into specific legal values in the _n_a_m_e_s  list.


       PackageOption(_k_e_y, _h_e_l_p, _d_e_f_a_u_l_t)
              Return a tuple of arguments to set up an option whose value is a
              path name of a package that may be enabled, disabled or given an
              explicit path name.  The option will use the specified name _k_e_y,
              have a default value of _d_e_f_a_u_l_t, and display the specified  _h_e_l_p
              text.   The option will support the values yyeess, ttrruuee, oonn, eennaabbllee
              or sseeaarrcchh, in which case the specified _d_e_f_a_u_l_t will be used,  or
              the option may be set to an arbitrary string (typically the path
              name to a package that is being enabled).  The option will  also
              support  the  values nnoo, ffaallssee, ooffff or ddiissaabbllee to disable use of
              the specified option.


       PathOption(_k_e_y, _h_e_l_p, _d_e_f_a_u_l_t, [_v_a_l_i_d_a_t_o_r])
              Return a tuple of arguments to set up an option whose  value  is
              expected  to  be a path name.  The option will use the specified
              name _k_e_y, have a default value of _d_e_f_a_u_l_t, and display the spec-
              ified  _h_e_l_p text.  An additional _v_a_l_i_d_a_t_o_r may be specified that
              will be called to verify that the specified path is  acceptable.
              SCons  supplies  the  following  ready-made  validators: PPaatthhOOpp--
              ttiioonn..PPaatthhEExxiissttss (the default), which verifies that the specified
              path  exists;  PPaatthhOOppttiioonn..PPaatthhIIssFFiillee,  which  verifies  that the
              specified path is an existing file; PPaatthhOOppttiioonn..PPaatthhIIssDDiirr,  which
              verifies  that  the specified path is an existing directory; and
              PPaatthhOOppttiioonn..PPaatthhIIssDDiirrCCrreeaattee, which verifies  that  the  specified
              path  is a directory, and will create the specified directory if
              the path does not exist.  You  may  supply  your  own  _v_a_l_i_d_a_t_o_r
              function,  which must take three arguments (_k_e_y, the name of the
              options variable to be  set;  _v_a_l,  the  specified  value  being
              checked; and _e_n_v, the construction environment) and should raise
              an exception if the specified value is not acceptable.

       These functions make it convenient to create a number of  options  with
       consistent behavior in a single call to the AAddddOOppttiioonnss method:

              opts.AddOptions(
                  BoolOption('warnings', 'compilation with -Wall and similiar', 1),
                  EnumOption('debug', 'debug output and symbols', 'no'
                             allowed_values=('yes', 'no', 'full'),
                             map={}, ignorecase=0),  # case sensitive
                  ListOption('shared',
                             'libraries to build as shared libraries',
                             'all',
                             names = list_of_libs),
                  PackageOption('x11',
                                'use X11 installed here (yes = search some places)',
                                'yes'),
                  PathOption('qtdir', 'where the root of Qt is installed', qtdir),
                  PathOption('foopath', 'where the foo library is installed', foopath,
                             PathOption.PathIsDir),

              )


   FFiillee aanndd DDiirreeccttoorryy NNooddeess
       The _F_i_l_e() and _D_i_r() functions return _F_i_l_e and _D_i_r Nodes, respectively.
       python objects, respectively.  Those objects have several  user-visible
       attributes and methods that are often useful:


       path   The  build  path  of  the given file or directory.  This path is
              relative to the top-level directory (where the  SSCCoonnssttrruucctt  file
              is  found).   The  build  path is the same as the source path if
              _b_u_i_l_d___d_i_r is not being used.


       abspath
              The absolute build path of the given file or directory.


       srcnode()
              The _s_r_c_n_o_d_e() method returns another _F_i_l_e or _D_i_r  object  repre-
              senting the _s_o_u_r_c_e path of the given _F_i_l_e or _D_i_r.  The

              # Get the current build dir's path, relative to top.
              Dir('.').path
              # Current dir's absolute path
              Dir('.').abspath
              # Next line is always '.', because it is the top dir's path relative to itself.
              Dir('#.').path
              File('foo.c').srcnode().path   # source path of the given source file.

              # Builders also return File objects:
              foo = env.Program('foo.c')
              print "foo will be built in %s"%foo.path


EEXXTTEENNDDIINNGG SSCCOONNSS
   BBuuiillddeerr OObbjjeeccttss
       ssccoonnss can be extended to build different types of targets by adding new
       Builder objects to a construction environment.  _I_n _g_e_n_e_r_a_l, you  should
       only need to add a new Builder object when you want to build a new type
       of file or other external target.  If you just want to invoke a differ-
       ent  compiler or other tool to build a Program, Object, Library, or any
       other type of output file for  which  ssccoonnss  already  has  an  existing
       Builder,  it is generally much easier to use those existing Builders in
       a construction environment that sets the appropriate construction vari-
       ables (CC, LINK, etc.).

       Builder  objects  are  created using the BBuuiillddeerr function.  The BBuuiillddeerr
       function accepts the following arguments:


       action The command line string  used  to  build  the  target  from  the
              source.   aaccttiioonn can also be: a list of strings representing the
              command to be executed and its arguments (suitable for enclosing
              white  space  in  an argument), a dictionary mapping source file
              name suffixes to any combination of command line strings (if the
              builder should accept multiple source file extensions), a Python
              function; an Action object (see the next section); or a list  of
              any of the above.

              An  action  function  takes  three arguments: _s_o_u_r_c_e - a list of
              source nodes, _t_a_r_g_e_t - a list of target nodes, _e_n_v  -  the  con-
              struction environment.


       prefix The prefix that will be prepended to the target file name.  This
              may be specified as a:


                 * _s_t_r_i_n_g,


                 * _c_a_l_l_a_b_l_e _o_b_j_e_c_t - a function or other callable  that  takes
                       two arguments (a construction environment and a list of
                       sources) and returns a prefix,


                 * _d_i_c_t_i_o_n_a_r_y - specifies a mapping  from  a  specific  source
                       suffix (of the first source specified) to a correspond-
                       ing target prefix.  Both the source suffix  and  target
                       prefix specifications may use environment variable sub-
                       stitution, and the target prefix (the  'value'  entries
                       in  the dictionary) may also be a callable object.  The
                       default target prefix may be indicated by a  dictionary
                       entry with a key value of None.


              b = Builder("build_it < $SOURCE > $TARGET"
                          prefix = "file-")

              def gen_prefix(env, sources):
                  return "file-" + env['PLATFORM'] + '-'
              b = Builder("build_it < $SOURCE > $TARGET",
                          prefix = gen_prefix)

              b = Builder("build_it < $SOURCE > $TARGET",
                          suffix = { None: "file-",
                                     "$SRC_SFX_A": gen_prefix })


       suffix The  suffix that will be appended to the target file name.  This
              may be specified in the same manner as the prefix above.  If the
              suffix  is  a string, then ssccoonnss will append a '.' to the begin-
              ning of the suffix  if  it's  not  already  there.   The  string
              returned by callable object (or obtained from the dictionary) is
              untouched and must append its own '.'  to the beginning  if  one
              is desired.

              b = Builder("build_it < $SOURCE > $TARGET"
                          suffix = "-file")

              def gen_suffix(env, sources):
                  return "." + env['PLATFORM'] + "-file"
              b = Builder("build_it < $SOURCE > $TARGET",
                          suffix = gen_suffix)

              b = Builder("build_it < $SOURCE > $TARGET",
                          suffix = { None: ".sfx1",
                                     "$SRC_SFX_A": gen_suffix })


       src_suffix
              The expected source file name suffix.  This may be a string or a
              list of strings.


       target_scanner
              A Scanner object that will be invoked to find implicit dependen-
              cies for this target file.  This keyword argument should be used
              for Scanner objects that find implicit dependencies  based  only
              on  the  target  file  and the construction environment, _n_o_t for
              implicit (See the section "Scanner Objects," below, for informa-
              tion about creating Scanner objects.)


       source_scanner
              A  Scanner  object  that will be invoked to find implicit depen-
              dences in any source files used to build this target file.  This
              is  where  you  would  specify  a  scanner  to  find things like
              ##iinncclluuddee lines in source files.  The pre-built DDiirrSSccaannnneerr  Scan-
              ner object may be used to indicate that this Builder should scan
              directory trees for on-disk changes to files that ssccoonnss does not
              know  about from other Builder or function calls.  (See the sec-
              tion "Scanner Objects," below, for  information  about  creating
              your own Scanner objects.)


       target_factory
              A factory function that the Builder will use to turn any targets
              specified as  strings  into  SCons  Nodes.   By  default,  SCons
              assumes that all targets are files.  Other useful target_factory
              values include DDiirr, for when a Builder creates a directory  tar-
              get,  and  EEnnttrryy, for when a Builder can create either a file or
              directory target.

              Example:

              MakeDirectoryBuilder = Builder(action=my_mkdir, target_factory=Dir)
              env = Environment()
              env.Append(BUILDERS = {'MakeDirectory':MakeDirectoryBuilder})
              env.MakeDirectory('new_directory', [])

       Note that the call to the MakeDirectory Builder  needs  to  specify  an
       empty  source  list  to make the string represent the builder's target;
       without that, it would assume the argument is the source, and would try
       to deduce the target name from it, which in the absence of an automati-
       cally-added prefix or suffix would lead to a matching target and source
       name and a circular dependency.


       source_factory
              A factory function that the Builder will use to turn any sources
              specified as  strings  into  SCons  Nodes.   By  default,  SCons
              assumes  that all source are files.  Other useful source_factory
              values include DDiirr, for when a Builder uses  a  directory  as  a
              source,  and EEnnttrryy, for when a Builder can use files or directo-
              ries (or both) as sources.

              Example:

              CollectBuilder = Builder(action=my_mkdir, source_factory=Entry)
              env = Environment()
              env.Append(BUILDERS = {'Collect':CollectBuilder})
              env.Collect('archive', ['directory_name', 'file_name'])


       emitter
              A function or list of functions to  manipulate  the  target  and
              source  lists  before  dependencies are established and the tar-
              get(s) are actually built.  eemmiitttteerr can also be  a  string  con-
              taining a construction variable to expand to an emitter function
              or list of functions, or a dictionary mapping source  file  suf-
              fixes  to  emitter  functions.   (Only  the  suffix of the first
              source file is used to select the actual emitter  function  from
              an emitter dictionary.)

              An  emitter  function  takes three arguments: _s_o_u_r_c_e - a list of
              source nodes, _t_a_r_g_e_t - a list of target nodes, _e_n_v  -  the  con-
              struction  environment.  An emitter must return a tuple contain-
              ing two lists, the list of targets to be built by this  builder,
              and the list of sources for this builder.

              Example:

              def e(target, source, env):
                  return (target + ['foo.foo'], source + ['foo.src'])

              # Simple association of an emitter function with a Builder.
              b = Builder("my_build < $TARGET > $SOURCE",
                          emitter = e)

              def e2(target, source, env):
                  return (target + ['bar.foo'], source + ['bar.src'])

              # Simple association of a list of emitter functions with a Builder.
              b = Builder("my_build < $TARGET > $SOURCE",
                          emitter = [e, e2])

              # Calling an emitter function through a construction variable.
              env = Environment(MY_EMITTER = e)
              b = Builder("my_build < $TARGET > $SOURCE",
                          emitter = '$MY_EMITTER')

              # Calling a list of emitter functions through a construction variable.
              env = Environment(EMITTER_LIST = [e, e2])
              b = Builder("my_build < $TARGET > $SOURCE",
                          emitter = '$EMITTER_LIST')

              # Associating multiple emitters with different file
              # suffixes using a dictionary.
              def e_suf1(target, source, env):
                  return (target + ['another_target_file'], source)
              def e_suf2(target, source, env):
                  return (target, source + ['another_source_file'])
              b = Builder("my_build < $TARGET > $SOURCE",
                          emitter = {'.suf1' : e_suf1,
                                     '.suf2' : e_suf2})


       multi  Specifies  whether this builder is allowed to be called multiple
              times for the same target file(s). The default is 0, which means
              the builder can not be called multiple times for the same target
              file(s). Calling a builder multiple times for  the  same  target
              simply  adds  additional  source  files to the target; it is not
              allowed to change the environment associated  with  the  target,
              specify addition environment overrides, or associate a different
              builder with the target.


       env    A construction environment that can be used to fetch source code
              using this Builder.  (Note that this environment is _n_o_t used for
              normal builds of normal target files, which use the  environment
              that was used to call the Builder for the target file.)


       generator
              A  function that returns a list of actions that will be executed
              to  build  the  target(s)  from  the  source(s).   The  returned
              action(s)  may be an Action object, or anything that can be con-
              verted into an Action object (see the next section).

              The generator function takes four arguments: _s_o_u_r_c_e - a list  of
              source  nodes,  _t_a_r_g_e_t  - a list of target nodes, _e_n_v - the con-
              struction environment, _f_o_r___s_i_g_n_a_t_u_r_e  -  a  Boolean  value  that
              specifies whether the generator is being called for generating a
              build signature (as opposed to actually executing the  command).
              Example:

              def g(source, target, env, for_signature):
                  return [["gcc", "-c", "-o"] + target + source]

              b = Builder(generator=g)


              The _g_e_n_e_r_a_t_o_r and _a_c_t_i_o_n arguments must not both be used for the
              same Builder.


       src_builder
              Specifies a builder to use when a source file name  suffix  does
              not  match  any of the suffixes of the builder. Using this argu-
              ment produces a multi-stage builder.


       single_source
              Specifies that this builder expects exactly one source file  per
              call.  Giving  more  than  one source files without target files
              results in implicitely calling the builder multiple times  (once
              for  each  source  given). Giving multiple source files together
              with target files results in a UserError exception.


              The _g_e_n_e_r_a_t_o_r and _a_c_t_i_o_n arguments must not both be used for the
              same Builder.


       env    A construction environment that can be used to fetch source code
              using this Builder.  (Note that this environment is _n_o_t used for
              normal  builds of normal target files, which use the environment
              that was used to call the Builder for the target file.)

              b = Builder(action="build < $SOURCE > $TARGET")
              env = Environment(BUILDERS = {'MyBuild' : b})
              env.MyBuild('foo.out', 'foo.in', my_arg = 'xyzzy')


       chdir  A directory from which scons will execute the  action(s)  speci-
              fied  for  this Builder.  If the cchhddiirr argument is a string or a
              directory Node, scons will change to  the  specified  directory.
              If the cchhddiirr is not a string or Node and is non-zero, then scons
              will change to the target file's directory.

              Note that scons will _n_o_t automatically modify its  expansion  of
              construction  variables  like $$TTAARRGGEETT and $$SSOOUURRCCEE when using the
              chdir keyword argument--that is, the expanded  file  names  will
              still  be  relative  to  the top-level SConstruct directory, and
              consequently  incorrect  relative  to   the   chdir   directory.
              Builders  created using chdir keyword argument, will need to use
              construction  variable  expansions   like   $${{TTAARRGGEETT..ffiillee}}   and
              $${{SSOOUURRCCEE..ffiillee}}  to  use just the filename portion of the targets
              and source.

              b = Builder(action="build < ${SOURCE.file} > ${TARGET.file}",
                          chdir=1)
              env = Environment(BUILDERS = {'MyBuild' : b})
              env.MyBuild('sub/dir/foo.out', 'sub/dir/foo.in')

       Any additional keyword arguments supplied when a Builder object is cre-
       ated  (that  is,  when the Builder() function is called) will be set in
       the executing construction  environment  when  the  Builder  object  is
       called.   The  canonical  example  here  would be to set a construction
       variable to the repository of a source code system.

       Any additional keyword arguments supplied  when  a  Builder  _o_b_j_e_c_t  is
       called will only be associated with the target created by that particu-
       lar Builder call (and any other files built as a result of the call).

       These extra keyword arguments are passed to  the  following  functions:
       command generator functions, function Actions, and emitter functions.


   AAccttiioonn OObbjjeeccttss
       The  BBuuiillddeerr(())  function  will turn its aaccttiioonn keyword argument into an
       appropriate internal Action object.   You  can  also  explicity  create
       Action  objects  using  the AAccttiioonn() global function, which can then be
       passed to the BBuuiillddeerr() function.  This can be  used  to  configure  an
       Action  object  more  flexibly, or it may simply be more efficient than
       letting each separate Builder object create a separate Action when mul-
       tiple Builder objects need to do the same thing.

       The  AAccttiioonn()  global  function  returns  an appropriate object for the
       action represented by the type of the first argument:


       Action If the first argument is already an Action object, the object is
              simply returned.


       String If  the  first  argument  is  a string, a command-line Action is
              returned.  Note that the command line string may be preceded  by
              an  @@  (at-sign)  to  suppress printing of the specified command
              line, or by a -- (hyphen) to ignore  the  exit  status  from  the
              specified command.  Examples:

              Action('$CC -c -o $TARGET $SOURCES')

              # Doesn't print the line being executed.
              Action('@build $TARGET $SOURCES')

              # Ignores
              Action('-build $TARGET $SOURCES')




       List   If  the  first argument is a list, then a list of Action objects
              is returned.  An Action object is created as necessary for  each
              element  in the list.  If an element _w_i_t_h_i_n the list is itself a
              list, the internal list is the command and arguments to be  exe-
              cuted  via  the  command  line.   This  allows white space to be
              enclosed in an argument by defining a command in a list within a
              list:

              Action([['cc', '-c', '-DWHITE SPACE', '-o', '$TARGET', '$SOURCES']])


       Function
              If the first argument is a Python function, a function Action is
              returned.  The Python function takes  three  keyword  arguments,
              ttaarrggeett  (a  Node object representing the target file), ssoouurrccee (a
              Node object representing the source file) and eennvv (the construc-
              tion environment used for building the target file).  The ttaarrggeett
              and ssoouurrccee arguments may be lists of Node objects  if  there  is
              more than one target file or source file.  The actual target and
              source file name(s) may be retrieved from their Node objects via
              the built-in Python str() function:

              target_file_name = str(target)
              source_file_names = map(lambda x: str(x), source)

              The  function  should  return 00 or NNoonnee to indicate a successful
              build of the target file(s).  The function may raise  an  excep-
              tion  or return a non-zero exit status to indicate an unsuccess-
              ful build.

              def build_it(target = None, source = None, env = None):
                  # build the target from the source
                  return 0

              a = Action(build_it)

       If the action argument is not one of the above, None is returned.

       The second, optional argument is  a  Python  function  that  returns  a
       string  to  be  printed  to describe the action being executed.  Like a
       function to build a file, this function takes three  arguments:  ttaarrggeett
       (a  Node  object  representing  the target file), ssoouurrccee (a Node object
       representing the source file) and  eennvv  (a  construction  environment).
       The  ttaarrggeett  and ssoouurrccee arguments may be lists of Node objects if there
       is more than one target file or source file.  Examples:

              def build_it(target, source, env):
                  # build the target from the source
                  return 0

              def string_it(target, source, env):
                  return "building '%s' from '%s'" % (target[0], source[0])

              # Use a positional argument.
              a = Action(build_it, string_it)

              # Alternatively, use a keyword argument.
              a = Action(build_it, strfunction=string_it)

       The third, also optional argument is a list of  construction  variables
       whose  values  will  be  included  in  the signature of the Action when
       deciding whether a target should be rebuilt because the action changed.
       This  is necessary whenever you want a target to be rebuilt when a spe-
       cific construction variable changes, because the underlying Python code
       for a function will not change when the value of the construction vari-
       able does.

              def build_it(target, source, env):
                  # build the target from the 'XXX' construction variable
                  open(target[0], 'w').write(env['XXX'])
                  return 0

              def string_it(target, source):
                  return "building '%s' from '%s'" % (target[0], source[0])

              # Use positional arguments.
              a = Action(build_it, string_it, ['XXX'])

              # Alternatively, use a keyword argument.
              a = Action(build_it, varlist=['XXX'])


       The AAccttiioonn() global function also takes a cchhddiirr keyword argument  which
       specifies  that  scons  will  execute  the action after changing to the
       specified directory.  If the chdir argument is a string or a  directory
       Node, scons will change to the specified directory.  If the chdir argu-
       ment is not a string or Node and is non-zero, then scons will change to
       the target file's directory.

       Note  that  scons  will  _n_o_t automatically modify its expansion of con-
       struction variables like $$TTAARRGGEETT and $$SSOOUURRCCEE when using the chdir  key-
       word  argument--that is, the expanded file names will still be relative
       to the top-level SConstruct directory, and consequently incorrect rela-
       tive  to  the  chdir  directory.   Builders created using chdir keyword
       argument, will need to use construction variable expansions like $${{TTAARR--
       GGEETT..ffiillee}}  and  $${{SSOOUURRCCEE..ffiillee}}  to use just the filename portion of the
       targets and source.

              a = Action("build < ${SOURCE.file} > ${TARGET.file}",
                         chdir=1)

       The AAccttiioonn() global function also takes an eexxiittssttaattffuunncc  keyword  argu-
       ment  which  specifies  a  function  that is passed the exit status (or
       return value) from the specified action and can return an arbitrary  or
       modified  value.   This  can  be  used, for example, to specify that an
       Action object's return value should be ignored and SCons should, there-
       fore, consider that the action always suceeds:

              def always_succeed(s):
                  # Always return 0, which indicates success.
                  return 0
              a = Action("build < ${SOURCE.file} > ${TARGET.file}",
                         exitstatfunc=always_succeed)


   MMiisscceellllaanneeoouuss AAccttiioonn FFuunnccttiioonnss
       ssccoonnss  supplies  a  number of functions that arrange for various common
       file and directory manipulations to be performed.  These are similar in
       concept  to  "tasks" in the Ant build tool, although the implementation
       is slightly different.  These functions do  not  actually  perform  the
       specified action at the time the function is called, but instead return
       an Action object that can be executed at  the  appropriate  time.   (In
       Object-Oriented  terminology,  these  are actually Action _F_a_c_t_o_r_y func-
       tions that return Action objects.)

       In practice, there are two natural ways that these Action Functions are
       intended to be used.

       First,  if  you  need  to perform the action at the time the SConscript
       file is being read, you can use the EExxeeccuuttee global function to do so:
              Execute(Touch('file'))

       Second, you can use these functions to supply Actions in a list for use
       by  the CCoommmmaanndd method.  This can allow you to perform more complicated
       sequences of file manipulation  without  relying  on  platform-specific
       external commands: that
              env = Environment(TMPBUILD = '/tmp/builddir')
              env.Command('foo.out', 'foo.in',
                          [Mkdir('$TMPBUILD'),
                           Copy('$TMPBUILD', '${SOURCE.dir}')
                           "cd $TMPBUILD && make",
                           Delete('$TMPBUILD')])


       Chmod(_d_e_s_t, _m_o_d_e)
              Returns  an  Action  object  that changes the permissions on the
              specified _d_e_s_t file or directory to the specified  _m_o_d_e.   Exam-
              ples:

              Execute(Chmod('file', 0755))

              env.Command('foo.out', 'foo.in',
                          [Copy('$TARGET', '$SOURCE'),
                           Chmod('$TARGET', 0755)])


       Copy(_d_e_s_t, _s_r_c)
              Returns  an  Action object that will copy the _s_r_c source file or
              directory to the _d_e_s_t destination file or directory.  Examples:

              Execute(Copy('foo.output', 'foo.input'))

              env.Command('bar.out', 'bar.in',
                          Copy('$TARGET', '$SOURCE'))


       Delete(_e_n_t_r_y, [_m_u_s_t___e_x_i_s_t])
              Returns an Action that deletes the specified _e_n_t_r_y, which may be
              a  file  or  a directory tree.  If a directory is specified, the
              entire directory tree will be removed.  If the  _m_u_s_t___e_x_i_s_t  flag
              is  set,  then  a  Python  error will be thrown if the specified
              entry does not exist; the default is mmuusstt__eexxiisstt==00, that is,  the
              Action  will  silently  do  nothing if the entry does not exist.
              Examples:

              Execute(Delete('/tmp/buildroot'))

              env.Command('foo.out', 'foo.in',
                          [Delete('${TARGET.dir}'),
                           MyBuildAction])

              Execute(Delete('file_that_must_exist', must_exist=1))


       Mkdir(_d_i_r)
              Returns an Action that creates the  specified  directory  _d_i_r  _.
              Examples:

              Execute(Mkdir('/tmp/outputdir'))

              env.Command('foo.out', 'foo.in',
                          [Mkdir('/tmp/builddir',
                           Copy('$SOURCE', '/tmp/builddir')
                           "cd /tmp/builddir && ])



       Move(_d_e_s_t, _s_r_c)
              Returns an Action that moves the specified _s_r_c file or directory
              to the specified _d_e_s_t file or directory.  Examples:

              Execute(Move('file.destination', 'file.source'))

              env.Command('output_file', 'input_file',
                          [MyBuildAction,
                           Move('$TARGET', 'file_created_by_MyBuildAction')])


       Touch(_f_i_l_e)
              Returns an Action that updates  the  modification  time  on  the
              specified _f_i_l_e.  Examples:

              Execute(Touch('file_to_be_touched'))

              env.Command('marker', 'input_file',
                          [MyBuildAction,
                           Touch('$TARGET')])


   VVaarriiaabbllee SSuubbssttiittuuttiioonn
       Before executing a command, ssccoonnss performs construction variable inter-
       polation on the strings that make up  the  command  line  of  builders.
       Variables  are  introduced  by  a $$ prefix.  Besides construction vari-
       ables, scons provides the following variables for each  command  execu-
       tion:


       TARGET The file name of the target being built, or the file name of the
              first target if multiple targets are being built.


       TARGETS
              The file names of all targets being built.


       SOURCE The file name of the source of the build command,  or  the  file
              name of the first source if multiple sources are being built.


       SOURCES
              The file names of the sources of the build command.

              (Note  that  the above variables are reserved and may not be set
              in a construction environment.)


       For example, given the construction variable CC='cc',  targets=['foo'],
       and sources=['foo.c', 'bar.c']:

              action='$CC -c -o $TARGET $SOURCES'

       would produce the command line:

              cc -c -o foo foo.c bar.c

       Variable  names  may be surrounded by curly braces ({}) to separate the
       name from the trailing characters.  Within the curly braces, a variable
       name  may  have a Python slice subscript appended to select one or more
       items from a list.  In the previous example, the string:

              ${SOURCES[1]}

       would produce:

              bar.c

       Additionally, a variable name may have the following special  modifiers
       appended  within  the enclosing curly braces to modify the interpolated
       string:


       base   The base path of the file name, including the directory path but
              excluding any suffix.


       dir    The name of the directory in which the file exists.


       file   The file name, minus any directory portion.


       filebase
              Just  the  basename  of the file, minus any suffix and minus the
              directory.


       suffix Just the file suffix.


       abspath
              The absolute path name of the file.


       posix  The POSIX form of the path,  with  directories  separated  by  //
              (forward  slashes) not backslashes.  This is sometimes necessary
              on Win32 systems when a path references a file on other  (POSIX)
              systems.


       srcpath
              The  directory  and  file name to the source file linked to this
              file through BuildDir.  If  this  file  isn't  linked,  it  just
              returns the directory and filename unchanged.


       srcdir The  directory  containing  the  source file linked to this file
              through BuildDir.  If this file isn't linked,  it  just  returns
              the directory part of the filename.


       rsrcpath
              The  directory  and  file name to the source file linked to this
              file through BuildDir.  If the file does not exist  locally  but
              exists  in a Repository, the path in the Repository is returned.
              If this file isn't linked, it just  returns  the  directory  and
              filename unchanged.


       rsrcdir
              The  Repository  directory  containing the source file linked to
              this file through BuildDir.  If this file isn't linked, it  just
              returns the directory part of the filename.


       For example, the specified target will expand as follows for the corre-
       sponding modifiers:

              $TARGET              => sub/dir/file.x
              ${TARGET.base}       => sub/dir/file
              ${TARGET.dir}        => sub/dir
              ${TARGET.file}       => file.x
              ${TARGET.filebase}   => file
              ${TARGET.suffix}     => .x
              ${TARGET.abspath}    => /top/dir/sub/dir/file.x

              SConscript('src/SConscript', build_dir='sub/dir')
              $SOURCE              => sub/dir/file.x
              ${SOURCE.srcpath}    => src/file.x
              ${SOURCE.srcdir}     => src

              Repository('/usr/repository')
              $SOURCE              => sub/dir/file.x
              ${SOURCE.rsrcpath}   => /usr/repository/src/file.x
              ${SOURCE.rsrcdir}    => /usr/repository/src

       Lastly, a variable name may be a callable  Python  function  associated
       with  a  construction variable in the environment.  The function should
       take four arguments: _t_a_r_g_e_t - a list of target nodes, _s_o_u_r_c_e -  a  list
       of  source nodes, _e_n_v - the construction environment, _f_o_r___s_i_g_n_a_t_u_r_e - a
       Boolean value that specifies whether the function is being  called  for
       generating  a  build  signature.  SCons will insert whatever the called
       function returns into the expanded string:

              def foo(target, source, env, for_signature):
                  return "bar"

              # Will expand $BAR to "bar baz"
              env=Environment(FOO=foo, BAR="$FOO baz")

       You can use this feature to pass arguments to a Python function by cre-
       ating  a callable class that stores one or more arguments in an object,
       and then uses them when the ____ccaallll____(()) method is called.  Note that  in
       this  case,  the  entire  variable  expansion must be enclosed by curly
       braces so that the arguments will be associated with the  instantiation
       of the class:

              class foo:
                  def __init__(self, arg):
                      self.arg = arg

                  def __call__(self, target, source, env, for_signature):
                      return arg + " bar"

              # Will expand $BAR to "my argument bar baz"
              env=Environment(FOO=foo, BAR="${FOO('my argument')} baz")


       The special pseudo-variables $$(( and $$)) may be used to surround parts of
       a command line that may change  _w_i_t_h_o_u_t  causing  a  rebuild--that  is,
       which are not included in the signature of target files built with this
       command.  All text between $$(( and $$)) will be removed from  the  command
       line  before  it is added to file signatures, and the $$(( and $$)) will be
       removed before the command is executed.  For example, the command line:

              echo Last build occurred $( $TODAY $). > $TARGET


       would execute the command:

              echo Last build occurred $TODAY. > $TARGET


       but the command signature added to any target files would be:

              echo Last build occurred  . > $TARGET

       SCons  uses  the following rules when converting construction variables
       into command lines:


       String When the value is a string it is interpreted as a  space  delim-
              ited list of command line arguments.


       List   When  the value is a list it is interpreted as a list of command
              line arguments. Each element of  the  list  is  converted  to  a
              string.


       Other  Anything  that  is not a list or string is converted to a string
              and interpreted as a single command line argument.


       Newline
              Newline characters (\n) delimit lines. The  newline  parsing  is
              done  after  all  other parsing, so it is not possible for argu-
              ments (e.g. file names) to contain embedded newline  characters.
              This  limitation  will  likely  go  away  in a future version of
              SCons.


   SSccaannnneerr OObbjjeeccttss
       You can use the SSccaannnneerr function to define objects  to  scan  new  file
       types  for  implicit dependencies.  Scanner accepts the following argu-
       ments:


       function
              A Python function that will process the Node (file) and return a
              list   of   strings   (file  names)  representing  the  implicit
              dependencies found in the contents.  The function takes three or
              four arguments:

                  def scanner_function(node, env, path):

                  def scanner_function(node, env, path, arg):

              The  nnooddee  argument  is the internal SCons node representing the
              file.  Use  ssttrr((nnooddee))  to  fetch  the  name  of  the  file,  and
              nnooddee..ggeett__ccoonntteennttss(()) to fetch contents of the file.

              The  eennvv  argument is the construction environment for the scan.
              Fetch values from it using the eennvv..DDiiccttiioonnaarryy(()) method.

              The ppaatthh argument is a tuple (or list) of directories  that  can
              be  searched for files.  This will usually be the tuple returned
              by the ppaatthh__ffuunnccttiioonn argument (see below).

              The aarrgg argument is the argument supplied when the  scanner  was
              created, if any.


       name   The  name  of  the Scanner.  This is mainly used to identify the
              Scanner internally.


       argument
              An optional argument that, if specified, will be passed  to  the
              scanner function (described above) and the path function (speci-
              fied below).


       skeys  An optional list that can be used  to  determine  which  scanner
              should  be used for a given Node.  In the usual case of scanning
              for file names, this argument will be a list of suffixes for the
              different  file  types  that this Scanner knows how to scan.  If
              the argument is a string, then it will be expanded into  a  list
              by the current environment.


       path_function
              A Python function that takes two or three arguments: a construc-
              tion environment, directory Node, and optional argument supplied
              when the scanner was created.  The ppaatthh__ffuunnccttiioonn returns a tuple
              of directories that can be searched for files to be returned  by
              this Scanner object.


       node_class
              The  class  of  Node  that  should  be  returned by this Scanner
              object.  Any strings or other objects returned  by  the  scanner
              function  that  are  not  of  this class will be run through the
              nnooddee__ffaaccttoorryy function.


       node_factory
              A Python function that will take a string or  other  object  and
              turn  it  into  the  appropriate class of Node to be returned by
              this Scanner object.


       scan_check
              An optional Python function that takes  two  arguments,  a  Node
              (file)  and  a construction environment, and returns whether the
              Node should, in fact, be scanned for dependencies.   This  check
              can  be used to eliminate unnecessary calls to the scanner func-
              tion when, for example, the underlying  file  represented  by  a
              Node does not yet exist.


       recursive
              An  optional  flag that specifies whether this scanner should be
              re-invoked on the dependency  files  returned  by  the  scanner.
              When  this  flag is not set, the Node subsystem will only invoke
              the scanner on the file being scanned,  and  not  (for  example)
              also  on  the  files specified by the #include lines in the file
              being scanned.  _r_e_c_u_r_s_i_v_e may be a callable function,  in  which
              case  it  will  be  called with a list of Nodes found and should
              return a list of Nodes that should be scanned recursively;  this
              can  be used to select a specific subset of Nodes for additional
              scanning.

              Note that ssccoonnss has a global SSoouurrcceeFFiilleeSSccaannnneerr  object  that  is
              used   by   the  OObbjjeecctt(),  SShhaarreeddOObbjjeecctt(),  and  SSttaattiiccOObbjjeecctt()
              builders to decide which scanner should be  used  for  different
              file  extensions.  You can using the SSoouurrcceeFFiilleeSSccaannnneerr..aadddd__ssccaann--
              nneerr() method to add your own Scanner object to the ssccoonnss infras-
              tructure that builds target programs or libraries from a list of
              source files of different types:

              def xyz_scan(node, env, path):
                  contents = node.get_contents()
                  # Scan the contents and return the included files.

              XYZScanner = Scanner(xyz_scan)

              SourceFileScanner.add_scanner('.xyx', XYZScanner)

              env.Program('my_prog', ['file1.c', 'file2.f', 'file3.xyz'])


SSYYSSTTEEMM--SSPPEECCIIFFIICC BBEEHHAAVVIIOORR
       SCons and its configuration files are very portable, due largely to its
       implementation in Python.  There are, however, a few portability issues
       waiting to trap the unwary.

   ..CC ffiillee ssuuffffiixx
       SCons handles the upper-case ..CC file suffix differently,  depending  on
       the  capabilities of the underlying system.  On a case-sensitive system
       such as Linux or UNIX, SCons treats a file with a ..CC suffix  as  a  C++
       source  file.   On  a  case-insensitive  system  such as Windows, SCons
       treats a file with a ..CC suffix as a C source file.

   ..FF ffiillee ssuuffffiixx
       SCons handles the upper-case ..FF file suffix differently,  depending  on
       the  capabilities of the underlying system.  On a case-sensitive system
       such as Linux or UNIX, SCons treats a file with a ..FF suffix as  a  For-
       tran source file that is to be first run through the standard C prepro-
       cessor.  On a case-insensitive system such as Windows, SCons  treats  a
       file  with  a ..FF suffix as a Fortran source file that should _n_o_t be run
       through the C preprocessor.

   WWIINN3322:: CCyyggwwiinn TToooollss aanndd CCyyggwwiinn PPyytthhoonn vvss.. WWiinnddoowwss PPyytthhoonnss
       Cygwin supplies a set of tools and utilities that let users work  on  a
       Windows  system using a more POSIX-like environment.  The Cygwin tools,
       including Cygwin Python, do this, in part, by  sharing  an  ability  to
       interpret  UNIX-like  path  names.   For example, the Cygwin tools will
       internally translate a Cygwin path name like  /cygdrive/c/mydir  to  an
       equivalent Windows pathname of C:/mydir (equivalent to C:\mydir).

       Versions of Python that are built for native Windows execution, such as
       the python.org and ActiveState versions, do not have  the  Cygwin  path
       name  semantics.   This  means  that  using a native Windows version of
       Python to build compiled programs using  Cygwin  tools  (such  as  gcc,
       bison,  and  flex) may yield unpredictable results.  "Mixing and match-
       ing" in this way can be made to work, but it requires careful attention
       to the use of path names in your SConscript files.

       In  practice,  users  can  sidestep the issue by adopting the following
       rules: When using gcc, use the Cygwin-supplied  Python  interpreter  to
       run  SCons;  when  using  Microsoft Visual C/C++ (or some other Windows
       compiler) use the python.org or ActiveState version of  Python  to  run
       SCons.

   WWIINN3322:: ssccoonnss..bbaatt ffiillee
       On WIN32 systems, SCons is executed via a wrapper ssccoonnss..bbaatt file.  This
       has (at least) two ramifications:

       First, Windows command-line users that want to use variable  assignment
       on  the  command  line may have to put double quotes around the assign-
       ments:

              scons "FOO=BAR" "BAZ=BLEH"

       Second, the Cygwin shell does not recognize this file as being the same
       as  an  ssccoonnss  command issued at the command-line prompt.  You can work
       around this either by executing ssccoonnss..bbaatt from the Cygwin command line,
       or by creating a wrapper shell script named ssccoonnss ..


   MMiinnGGWW
       The  MinGW  bin  directory must be in your PATH environment variable or
       the PATH variable under the ENV  construction  variable  for  SCons  to
       detect  and  use the MinGW tools. When running under the native Windows
       Python interpreter, SCons will prefer the MinGW tools over  the  Cygwin
       tools,  if  they are both installed, regardless of the order of the bin
       directories in the PATH variable. If  you  have  both  MSVC  and  MinGW
       installed  and  you  want  to  use MinGW instead of MSVC, then you must
       explictly tell SCons to use MinGW by passing

              tools=['mingw']

       to the Environment() function, because SCons will prefer the MSVC tools
       over the MinGW tools.


EEXXAAMMPPLLEESS
       To  help  you  get  started  using SCons, this section contains a brief
       overview of some common tasks.


   BBaassiicc CCoommppiillaattiioonn FFrroomm aa SSiinnggllee SSoouurrccee FFiillee
              env = Environment()
              env.Program(target = 'foo', source = 'foo.c')

       Note:  Build the file by specifying the target as an  argument  ("scons
       foo" or "scons foo.exe").  or by specifying a dot ("scons .").


   BBaassiicc CCoommppiillaattiioonn FFrroomm MMuullttiippllee SSoouurrccee FFiilleess
              env = Environment()
              env.Program(target = 'foo', source = Split('f1.c f2.c f3.c'))


   SSeettttiinngg aa CCoommppiillaattiioonn FFllaagg
              env = Environment(CCFLAGS = '-g')
              env.Program(target = 'foo', source = 'foo.c')


   SSeeaarrcchh TThhee LLooccaall DDiirreeccttoorryy FFoorr ..hh FFiilleess
       Note:   You  do  _n_o_t need to set CCFLAGS to specify -I options by hand.
       SCons will construct the right -I options from CPPPATH.

              env = Environment(CPPPATH = ['.'])
              env.Program(target = 'foo', source = 'foo.c')


   SSeeaarrcchh MMuullttiippllee DDiirreeccttoorriieess FFoorr ..hh FFiilleess
              env = Environment(CPPPATH = ['include1', 'include2'])
              env.Program(target = 'foo', source = 'foo.c')


   BBuuiillddiinngg aa SSttaattiicc LLiibbrraarryy
              env = Environment()
              env.StaticLibrary(target = 'foo', source = Split('l1.c l2.c'))
              env.StaticLibrary(target = 'bar', source = ['l3.c', 'l4.c'])


   BBuuiillddiinngg aa SShhaarreedd LLiibbrraarryy
              env = Environment()
              env.SharedLibrary(target = 'foo', source = ['l5.c', 'l6.c'])
              env.SharedLibrary(target = 'bar', source = Split('l7.c l8.c'))


   LLiinnkkiinngg aa LLooccaall LLiibbrraarryy IInnttoo aa PPrrooggrraamm
              env = Environment(LIBS = 'mylib', LIBPATH = ['.'])
              env.Library(target = 'mylib', source = Split('l1.c l2.c'))
              env.Program(target = 'prog', source = ['p1.c', 'p2.c'])


   DDeeffiinniinngg YYoouurr OOwwnn BBuuiillddeerr OObbjjeecctt
       Notice that when you invoke the Builder, you can leave off  the  target
       file suffix, and SCons will add it automatically.

              bld = Builder(action = 'pdftex < $SOURCES > $TARGET'
                            suffix = '.pdf',
                            src_suffix = '.tex')
              env = Environment(BUILDERS = {'PDFBuilder' : bld})
              env.PDFBuilder(target = 'foo.pdf', source = 'foo.tex')

              # The following creates "bar.pdf" from "bar.tex"
              env.PDFBuilder(target = 'bar', source = 'bar')

       Note  also that the above initialization overwrites the default Builder
       objects, so the Environment created above can not be used call Builders
       like env.Program(), env.Object(), env.StaticLibrary(), etc.


   AAddddiinngg YYoouurr OOwwnn BBuuiillddeerr OObbjjeecctt ttoo aann EEnnvviirroonnmmeenntt
              bld = Builder(action = 'pdftex < $SOURCES > $TARGET'
                            suffix = '.pdf',
                            src_suffix = '.tex')
              env = Environment()
              env.Append(BUILDERS = {'PDFBuilder' : bld})
              env.PDFBuilder(target = 'foo.pdf', source = 'foo.tex')
              env.Program(target = 'bar', source = 'bar.c')

       You  also can use other Pythonic techniques to add to the BUILDERS con-
       struction variable, such as:

              env = Environment()
              env['BUILDERS]['PDFBuilder'] = bld


   DDeeffiinniinngg YYoouurr OOwwnn SSccaannnneerr OObbjjeecctt
              import re

              include_re = re.compile(r'^include\s+(\S+)$', re.M)

              def kfile_scan(node, env, path, arg):
                  contents = node.get_contents()
                  includes = include_re.findall(contents)
                  return includes

              kscan = Scanner(name = 'kfile',
                              function = kfile_scan,
                              argument = None,
                              skeys = ['.k'])
              scanners = Environment().Dictionary('SCANNERS')
              env = Environment(SCANNERS = scanners + [kscan])

              env.Command('foo', 'foo.k', 'kprocess < $SOURCES > $TARGET')

              bar_in = File('bar.in')
              env.Command('bar', bar_in, 'kprocess $SOURCES > $TARGET')
              bar_in.target_scanner = kscan


   CCrreeaattiinngg aa HHiieerraarrcchhiiccaall BBuuiilldd
       Notice that the file names specified  in  a  subdirectory's  SConscript
       file are relative to that subdirectory.

              SConstruct:

                  env = Environment()
                  env.Program(target = 'foo', source = 'foo.c')

                  SConscript('sub/SConscript')

              sub/SConscript:

                  env = Environment()
                  # Builds sub/foo from sub/foo.c
                  env.Program(target = 'foo', source = 'foo.c')

                  SConscript('dir/SConscript')

              sub/dir/SConscript:

                  env = Environment()
                  # Builds sub/dir/foo from sub/dir/foo.c
                  env.Program(target = 'foo', source = 'foo.c')


   SShhaarriinngg VVaarriiaabblleess BBeettwweeeenn SSCCoonnssccrriipptt FFiilleess
       You  must  explicitly  Export() and Import() variables that you want to
       share between SConscript files.

              SConstruct:

                  env = Environment()
                  env.Program(target = 'foo', source = 'foo.c')

                  Export("env")
                  SConscript('subdirectory/SConscript')

              subdirectory/SConscript:

                  Import("env")
                  env.Program(target = 'foo', source = 'foo.c')


   BBuuiillddiinngg MMuullttiippllee VVaarriiaannttss FFrroomm tthhee SSaammee SSoouurrccee
       Use the build_dir keyword argument to the SConscript function to estab-
       lish  one  or more separate build directories for a given source direc-
       tory:

              SConstruct:

                  cppdefines = ['FOO']
                  Export("cppdefines")
                  SConscript('src/SConscript', build_dir='foo')

                  cppdefines = ['BAR']
                  Export("cppdefines")
                  SConscript('src/SConscript', build_dir='bar')

              src/SConscript:

                  Import("cppdefines")
                  env = Environment(CPPDEFINES = cppdefines)
                  env.Program(target = 'src', source = 'src.c')

       Note the use of the Export() method to set the "cppdefines" variable to
       a different value each time we call the SConscript function.


   HHiieerraarrcchhiiccaall BBuuiilldd ooff TTwwoo LLiibbrraarriieess LLiinnkkeedd WWiitthh aa PPrrooggrraamm
              SConstruct:

                  env = Environment(LIBPATH = ['#libA', '#libB'])
                  Export('env')
                  SConscript('libA/SConscript')
                  SConscript('libB/SConscript')
                  SConscript('Main/SConscript')

              libA/SConscript:

                  Import('env')
                  env.Library('a', Split('a1.c a2.c a3.c'))

              libB/SConscript:

                  Import('env')
                  env.Library('b', Split('b1.c b2.c b3.c'))

              Main/SConscript:

                  Import('env')
                  e = env.Copy(LIBS = ['a', 'b'])
                  e.Program('foo', Split('m1.c m2.c m3.c'))

       The '#' in the LIBPATH directories specify that they're relative to the
       top-level directory, so they don't turn into "Main/libA"  when  they're
       used in Main/SConscript.

       Specifying  only  'a'  and  'b'  for  the library names allows SCons to
       append the appropriate library prefix and suffix for the current  plat-
       form (for example, 'liba.a' on POSIX systems,


   CCuussttoommiizziinngg ccoonnttrruuccttiioonn vvaarriiaabblleess ffrroomm tthhee ccoommmmaanndd lliinnee..
       The following would allow the C compiler to be specified on the command
       line or in the file custom.py.

              opts = Options('custom.py')
              opts.Add('CC', 'The C compiler.')
              env = Environment(options=opts)
              Help(opts.GenerateHelpText(env))

       The user could specify the C compiler on the command line:

              scons "CC=my_cc"

       or in the custom.py file:

              CC = 'my_cc'

       or get documentation on the options:

              $ scons -h

              CC: The C compiler.
                  default: None
                  actual: cc



   UUssiinngg MMiiccrroossoofftt VViissuuaall CC++++ pprreeccoommppiilleedd hheeaaddeerrss
       Since windows.h includes everything and the kitchen sink, it  can  take
       quite some time to compile it over and over again for a bunch of object
       files, so Microsoft provides a mechanism to compile a  set  of  headers
       once  and  then  include  the previously compiled headers in any object
       file. This technology is called precompiled headers. The general recipe
       is  to  create  a file named "StdAfx.cpp" that includes a single header
       named "StdAfx.h", and then include every header you want to  precompile
       in  "StdAfx.h",  and  finally include "StdAfx.h" as the first header in
       all the source files you are compiling to object files. For example:

       StdAfx.h:
              #include <windows.h>
              #include <my_big_header.h>

       StdAfx.cpp:
              #include <StdAfx.h>

       Foo.cpp:
              #include <StdAfx.h>

              /* do some stuff */

       Bar.cpp:
              #include <StdAfx.h>

              /* do some other stuff */

       SConstruct:
              env=Environment()
              env['PCHSTOP'] = 'StdAfx.h'
              env['PCH'] = env.PCH('StdAfx.cpp')[0]
              env.Program('MyApp', ['Foo.cpp', 'Bar.cpp'])

       For more information see the document for the PCH builder, and the  PCH
       and  PCHSTOP construction variables. To learn about the details of pre-
       compiled headers consult the MSDN documention for /Yc, /Yu, and /Yp.


   UUssiinngg MMiiccrroossoofftt VViissuuaall CC++++ eexxtteerrnnaall ddeebbuuggggiinngg iinnffoorrmmaattiioonn
       Since including debugging information in programs and shared  libraries
       can  cause  their  size to increase significantly, Microsoft provides a
       mechanism for including the debugging information in an  external  file
       called  a  PDB file. SCons supports PDB files through the PDB construc-
       tion variable.

       SConstruct:
              env=Environment()
              env['PDB'] = 'MyApp.pdb'
              env.Program('MyApp', ['Foo.cpp', 'Bar.cpp'])

       For more information see the document for the  PDB  construction  vari-
       able.


EENNVVIIRROONNMMEENNTT
       SCONS_LIB_DIR
              Specifies  the  directory  that contains the SCons Python module
              directory (e.g. /home/aroach/scons-src-0.01/src/engine).


       SCONSFLAGS
              A string of options that will be used by scons  in  addition  to
              those passed on the command line.


SSEEEE AALLSSOO
       ssccoonnss User Manual, ssccoonnss Design Document, ssccoonnss source code.


AAUUTTHHOORRSS
       Steven Knight <knight@baldmt.com>
       Anthony Roach <aroach@electriceyeball.com>




                                 January 2005                         SCONS(1)
